Metadata-Version: 2.1
Name: django_squirrell_materialize
Version: 1.1
Summary: A Docker and AWS utility package
Home-page: https://github.com/esco/django_ardilla_materialize
Author: ESCO
Author-email: franjcesco@gmail.com
License: UNKNOWN
Description: # Store 
        
        ## DOCUMENTACIÓN
        
        ### `admin`
        ---
        
        Aquí controlamos el formulario de registro de nuestro modelo, es decir, controlamos cómo va a funcionar antes de introducirlo y/o cambiarlo en nuestra base de datos. Cada modelo tiene su propio **`admin.py`**. 
        
        Primero creamos nuestro `ModelForm` y le añadimos sus propiedades. En nustro caso hemos creado el archivo `forms.py` para cada modelo. 
        
        Para este ejemplo estamos usando nuestro modelo ***Producto***.
        
        ```
        class ProductoForm(forms.ModelForm):
            """Form definition for Producto."""
        
            class Meta:
                """Meta definition for Productoform."""
        
                model = Producto
                #fields = ('',)
                exclude = ['idproducto']
        
            def __init__ (self, *args, **kwargs):
        
                super(ProductoForm, self).__init__(*args, **kwargs)
        ```
        A continuación, vamos a incorporar el formulario que tiene relación con nuestro modelo, en este caso su padre. Es algo operativo y tremendamente cómodo. Por lo que tras el código de abajo tendríamos dos formularios en la misma página para poder relacionar los diferentes modelos. 
        >Previamente hemos tenido que relacionar dichos modelos en sus `models.py`.
        
        ```
        class CategoriaProductoInline(admin.TabularInline):
        
            form = ProductoForm
            model = Categoria.idproducto.through
            extra = 3
        ```
        En este apartado creamos el centro de **administración** del formulario **únicamente de cara al BACKEND**. Aquí se decide cómo va a funcionar dicho formulario **en el backend**. Para ampliar información *[click aquí](https://docs.djangoproject.com/en/2.2/ref/contrib/admin/)*
        
        ```
        @admin.register(Producto)
        class ProductoAdmin(admin.ModelAdmin):
        
            form = ProductoForm
            inlines = [CategoriaProductoInline]
            fields = ('nombre',('presentacion','descripcion'), ('talla','precio'),'imagen',)
            readonly_fields = ('nombre',)
            list_display = ['nombre','precio','descripcion',]
            search_fields = ['nombre','precio','descripcion',]
            list_filter = ['nombre',]
            actions = ['set_precio_0',]
        
            def set_precio_0(self, request, queryset):
                for obj in queryset:
                    obj.precio = 0
                    obj.save()
        
            set_precio_0.short_description = 'Convertir precio a 0'
        ```
        - **fields:** se eligen los campos que van a aparecer, si van sin `()` van en una línea solos.
        - **readonly_fields:** hace que sólo sea de lectura el campo elegido.
        - **list_display:** son los campos que van a aparecer en la pestaña de dicho modelo, es decir, dónde aparecen todos los *Productos* en este caso.
        - **search_fields:** son los campos que van a ser buscables, si por ejemplo no incluyésemos *nombre* no podríamos buscar por sus nombres.
        - **list_filter:** crear una categorización navegable según lo que queramos (*nombre, precio, etc*).
        - **actions:** permite incorporar funciones para interactuar con todas las características, las funciones se definen debajo y en este campo únicamente se seleccionan por su nombre. Aparte, se le puede indicar una breve descripción para que aparezca en la página. Si no se define una descripción se llamará como la propia función.
        
        
        ### Paginación
        ---
        
        #### Instalación de la paginación
        
        Para poder empezar a paginar nuestros items simplemente tenemos que importar el siguiente módulo en nuestra vista.
        ```
        from django.core.paginator import Paginator
        ```
        
        #### Cómo utilizar la paginación
        
        Tenemos que pasarle un *Queryset* con todos los objetos que queramos, después definimos el número límite de items por cada página. Para ampliar más información sobre la paginación [click aquí](https://docs.djangoproject.com/en/2.2/topics/pagination/)
        
        ```
        def index(request):
            user_list = User.objects.all()
            page = request.GET.get('page', 1)
        
            paginator = Paginator(user_list, 10)
        ```
        
        ### Filtros en Django
        ---
        
        #### Instalación de filtros
        
        Vamos a usar el *django filter package (2.2.0)*, para más información consultar [aquí](https://django-filter.readthedocs.io/en/latest/guide/usage.html)
        
        Se instala usando `pip install django-filter` y se añade `django_filters` a nuestro `INSTALLED_APPS`. Ya lo tenemos todo listo para empezar. A continuación, contando con que ya tenemos creados nuestros modelos (de no tenerlos los creamos), vamos a crear un archivo `filters.py` dentro de nuestro modelo. En dicho archivo vamos a incluir lo siguiente:
        
        ```
        import django_filters
        
        class ProductFilter(django_filters.FilterSet):
            name = django_filters.CharFilter(lookup_expr='iexact')
        
            price = django_filters.NumberFilter()
            price__gt = django_filters.NumberFilter(field_name='price', lookup_expr='gt')
            price__lt = django_filters.NumberFilter(field_name='price', lookup_expr='lt')
        
            class Meta:
                model = Product
                fields = ['price', 'release_date']
        ```
        
        #### Cómo utilizar los filtros de Django
        
        A partir de aquí podemos añadir los filtros que queramos, respetando siempre lo siguiente:
        
        - `field_name`: se trata del campo del modelo que queremos filtrar, podemos realizar relaciones a través de ellos usando la sintáxis e Django `__`, por ejemplo: `manufacter__name`.
        - `lookup_expr`: es la expresión que vamos a utilizar para realizar el filtro, recordad que cuánto **más representativa** de la acción que realiza mejor. 
        
        >Para ampliar información sobre las expresiones de búsqueda o `lookup_expr` *[click aquí](https://docs.djangoproject.com/en/2.2/ref/models/lookups/#module-django.db.models.lookups)*
        
        La *Meta Class* nos permite añadir campos de filtro sin repetir excesivamente el código del modelo. 
        
        ```
        class ProductFilter(django_filters.FilterSet):
            class Meta:
                model = Product
                fields = ['price', 'release_date']
        ```
        En este caso hemos generado dos filtros "exactos" tanto para *price* como para *release_date*. Adicionalmente, podemos crear un diccionario para ser más precisos a la hora de definir los campos a filtrar.
        
        ```
        class ProductFilter(django_filters.FilterSet):
            class Meta:
                model = Product
                fields = {
                    'price': ['lt', 'gt'],
                    'release_date': ['exact', 'year__gt'],
                }
        ```
        Este ejemplo de arriba creará *pricee__it, price__gt, release_date y release_date__year__gt*. Como se observa no se ha creado un *release_date__exact* ya que el 'exact' viene de forma predeterminada con los filtros de Django, se usa para determinar el requerimiento de ser exacto, en este caso, '*release_date*' sería el exacto.
        
        #### La vista
        
        ```
        def product_list(request):
            filtro = ProductFilter(request.GET, queryset=Product.objects.all())
            return render(request, 'my_app/template.html', {'filter': filtro})
        ```
        Tenemos que tener en cuenta que nos llega un Objeto filtro que contiene propiedades como `ObjectoFiltro.form` que nos permite acceder al formulario que se genera gracias a los campos que hemos puesto en su correspondiente archivo `filters.py`, también nos trae su *Queryset*, al cual podemos acceder simplemente con `.qs`. Por lo que lo más recomendable es capturar en la vista dichas propiedades y enviar las que necesitemos, en vez de enviar directamente el Objecto filtro como hacen en la documentación oficial.
        
        >Si tenemos una paginación simplemente tenemos que pasarle el *Queryset* al *paginator* dentro de nuestra vista. Si le pasamos directamente el Objeto filtro no será capaz de entenderlo..
        
        #### Las urls
        
        ```
        url(r'^list$', views.product_list)
        ```
        Las urls no requieren de ninguna modificación para que los filtros funcionen, podemos dejarlas tal como las tengamos.
        
        
        
        
Platform: UNKNOWN
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Description-Content-Type: text/markdown
