#!/usr/bin/env python3
from Bio.PDB import *
import math, glob
import os, sys, subprocess
import textwrap
import numpy as np
import pandas as pd
import shutil
import io
import warnings
import tempfile
import matplotlib.pyplot as plt
from scipy.stats import gaussian_kde
from mpl_toolkits.mplot3d import Axes3D
from PyQt5.QtGui import QPalette, QColor
from PyQt5.QtCore import Qt, QProcess,  pyqtSlot
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QMessageBox, QDesktopWidget
import errno
from prody import *
from prody.atomic import Atomic, Atom, AtomGroup, Selection, HierView
from prody.utilities import openFile, showFigure, createStringIO, wrapModes
from prody import SETTINGS, PY3K
_version_ = str("v0.6")
plt.rcParams['savefig.dpi'] = 600
ICO = b"/9j/4AAQSkZJRgABAQEAYABgAAD/4QCyRXhpZgAATU0AKgAAAAgABwE+AAUAAAACAAAAYgE/AAUAAAAGAAAAcgMBAAUAAAABAAAAogMDAAEAAAABAAAAAFEQAAEAAAABAQAAAFERAAQAAAABAAAAAFESAAQAAAABAAAAAAAAAAAAAHomAAGGoAAAgIQAAYagAAD6AAABhqAAAIDoAAGGoAAAdTAAAYagAADqYAABhqAAADqYAAGGoAAAF3AAAYagAAGGoAAAsY//2wBDAAcFBQYFBAcGBQYIBwcIChELCgkJChUPEAwRGBUaGRgVGBcbHichGx0lHRcYIi4iJSgpKywrGiAvMy8qMicqKyr/2wBDAQcICAoJChQLCxQqHBgcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKir/wAARCAJYAlgDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6RooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoqO4uIbS3ee6lSGJBlndsBR7mvP/EPxUhtFZdFhjdB/y+XZKRf8BX7zfpVRi5OyOXEYujho81WVvzfoj0MkKpLEADqT2rDu/FljDMYrVXvHXgmLAQH/AHjx+VeCeIPiu2oyNFf65dyIDzFaRCKM/wBT+NZtt4/s7uSOP+0LqNU4UXABQ+x28ivQp4SH/LyS9Ezx62bza/c05W7tfofQD+LnDfN9khH91pCx/MYqS38VGSTH+jTDuI3IP615jpXxFi0tFN94c068tX6XFp1P/fWf516Lol94R8a2hOnwwiVBlognlSx/l/MVFSkqe8NPUMPUr4lc1LEJvtynRWerW14wQExS/wDPOTgn6etXa5C98N3+n5fTZDe2w5+zzH94v+63f+dS6R4jPMcxeRUOHRxiSL6jv/Oud01JXpv5HXDHVKMlDFxt2ktn/kdVRTY5EmjWSJgyMMgjvTqwPXTuFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUEgDJOBWfrOt2Gg2DXepzrFGOFH8Tn0A7mvK9c8Z3/iVmiiY2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e2X+H8sD6mlFWld7I9zGZg8Rl1OnT1qVrJf+3M7/AMGWjQeHluZRiW9c3DD0DfdH/fIFb9IiLHGqIAFUAADsKWs27u59NQoxoUo0o7RSQUUUUjYKKKKAI7i3hu7aS3uY1lhlUq6MMhge1eJeIdEfw/rbaVMd0RzPp8rd1z936jp+Ve41yvxD8OP4g8Mu1mudQsj59sR1Ygcp/wACHH1xWNakpq/VbHj5vl0cdh3FfEtU/wBPmJ8N70Xfg+NQfmgmkjYenzbv/Zq6uvEfhz41tNH1SRNQl8myv9oLMOIphxk+gPQ/QV7cCGAIIIPIIq4T543LymsquDgusVZrtbQKKKKs9UKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigArkviZ4U/wCEv8D3djEoN3CPPtT/ANNF7fiMj8a62imnZ3JlFSTiz4v0yZll8uQFWU4KnqDXWWLebcKT0RePqf8A6386tfGHwqfC/jz+0LRNtjqxMq4HCy/xr+ufxrP0lsSke5r3sFJTaPz7NqDoyaOotxnFakMGRnFZ1mM4rqLW1As2cjtXuTnyRPjJ6yOZvvlJFZKj5j9a1NQPztWYnWuTHfwmdNH4R6feFX4TwKojrVyE8V8wTV2AW8La3A0iSyyygJDCn3ZJM8Aj19M17D4T8OPoltJcXrrJf3IHmlfuxqOiL7Due5ryKeZrYwXkf37WZJhj2Ne9W8yXNtFPGcpIgdT7EZrOo3sfZ8K0aNTmrS1nHReS8iSiiisj7wKKKKACiiigAooooA8j+IPwsvbvUZNV8Jxxublv9JsmYICx6upPH1Fei+FNNu9I8KadYajJ5tzbwhJGDFhn0BPUDp+Fa9FSopO6OanhqVOrKrBWb3CiiiqOkKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAw/F/hSx8Y+HptL1BcbvmhmA+aGQdGH+eRXz/JpF3oetS6bqcYjuoT8wHRh2ZfUGvpysjXvC+k+JIFTVbUSOn+rmQ7ZI/ow5/DpXXhcR7Cd2ro8nM8uWNp2TtJbHjmnR7pFHvXaTRC30hjkfdq03wwjglLafrE6L2SeJZMfiMGqOreG/EsFr5SQx30Sj71u+GP8AwFv6E17jxtCu4pSt6nwNbIMfQ5pcnN6O/wCG5w162XY+9UFrQvrHUIWIuLC7iPP34GH64rOhjmnYrBDJKQcEIhY/pW2LqQnTfKzz44atBcsoNP0ZJVmFxVu18KeIL04g0m5AxnMibB/49iui0z4Y6zM+dRmgtI/Y+Yx/AcfrXzTkkdMMqxlfSFN/db8zmmKvEyN0YEGvYPBFwbnwZpxYktHH5RJ/2SV/pVXS/h/o2nMJJke8kHeY/KP+Ajj866ZESNAkahFHAVRgCs5STPsciyevl8pVKsl7y2X+Y6iiisz6oKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACkVFQEIoXJycDFLRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAH/2Q=="
parser = PDBParser(PERMISSIVE=1)
WORK_PATH = os.path.expanduser('~')


def gromacs_flag(name):
    try:
        devnull = open(os.devnull)
        subprocess.Popen([name], stdout=devnull, stderr=devnull).communicate()
    except OSError as e:
        if e.errno == errno.ENOENT:
            return False
    return True

def iconFromBase64(base64):
    pixmap = QtGui.QPixmap()
    pixmap.loadFromData(QtCore.QByteArray.fromBase64(base64))
    icon = QtGui.QIcon(pixmap)
    return icon

def countModel(file):
    k = 0
    with open(file, 'r') as f:
        for line in f:
            words = line.split()
            for i in words:
                if(i=='MODEL'):
                    k=k+1
    return k
def is_multi_pdb_file(fpath):
    return os.path.isfile(fpath) and os.path.getsize(fpath) > 0 and countModel(fpath)

_help=''' 
    
                                                                                                G_Measures               
                                             
    #########################################################################

    The "Geometric Measures" script that was developed to carry out geometric analysis on protein structures.
    This script support as input MultiPDB files, and the avaliable analysis are: 
    
    1 - Pincer angle.
                            
    Select the residues that will be used to measure the pincer angle. 
   

                (1)              (3)
                    \              /
                      \          /
                        \      /
                          \  / 
                          (2)
    
    2 - Dihedral angle.

    Select the residues that will be used to measure the dihedral angle. 
    

                     (1)             (4)
                       |                 |
                       |                 |
                       |                 |
                       |                 |
                     (2)----------(3)
        
    3 - Triangle area.

    Select the residues that will be used to measure the triangle area. 
    

                            AC
                (1)------------(3)
                    \                /
         AB        \            /     BC
                       \         /
                         \     / 
                          (2)
                            
                           


    4 - PDF (Probability Density Function)
    The Functional Density Function is calculated using different values of mainchain dihedral angles from the considered residue, the mainchain conformation of the equivalent residue between frames.
    
    5 - RMSD

    Compares two protein structures frames (first frame the first frame with the consecutive frames) by computing the root mean square deviation (RMSD).

    6 - RG

    Computes the radius of gyration of the protein and the radii of gyration about the x-, y- and z-axes, as a function of frames.

    7 - FEL
    FEL represents a mapping of all possible conformations a molecule adopted during a simulation, together with their corresponding energy reported as the Gibbs Free Energy. FEL are represented using two variables that reflect specific properties of the system and measure conformational variability. RG measure the torsion angle around a specific bond or the radius of gyration of the protein, and the the RMSD measure the deviation with respective native state (First frame).


The GROMACS program (http://www.gromacs.org/) is required for the 'Converter' and 'FEL' tools.
The only recognized trajectory file format for G_Measures is multi-PDB.
If the user has only XTC trajectory files, the 'Converter' tool can be used.
Click Browse ..., select the multi-PDB file and follow the steps shown in the status bar.

Thank you for using G_Measures!
G_Measures Team
'''
    
def showProtein(*atoms, **kwargs):
    """Show protein representation using :meth:`~mpl_toolkits.mplot3d.Axes3D`.
    This function is designed for generating a quick view of the contents of a
    :class:`~.AtomGroup` or :class:`~.Selection`.    

    Protein atoms matching ``"calpha"`` selection are displayed using solid
    lines by picking a random and unique color per chain.  Line with can
    be adjusted using *lw* argument, e.g. ``lw=12``. Default width is 4.
    Chain colors can be overwritten using chain identifier as in ``A='green'``.

    Water molecule oxygen atoms are represented by red colored circles.  Color
    can be changed using *water* keyword argument, e.g. ``water='aqua'``.
    Water marker and size can be changed using *wmarker* and *wsize* keywords,
    defaults values are ``wmarker='.', wsize=6``.

    Hetero atoms matching ``"hetero and noh"`` selection are represented by
    circles and unique colors are picked at random on a per residue basis.
    Colors can be customized using residue name as in ``NAH='purple'``.  Note
    that this will color all distinct residues with the same name in the same
    color.  Hetero atom marker and size can be changed using *hmarker* and
    *hsize* keywords, default values are ``hmarker='o', hsize=6``.

    ProDy will set the size of axis so the representation is not distorted when
    the shape of figure window is close to a square.  Colors are picked at
    random, except for water oxygens which will always be colored red.
    
    *** Interactive 3D Rendering in Jupyter Notebook ***
    
    If py3Dmol has been imported then it will be used instead to display 
    an interactive viewer.  See :func:`view3D`
    
    
    """

    from prody.dynamics.mode import Mode

    method = kwargs.pop('draw', None)
    modes = kwargs.get('mode', None)
    scale = kwargs.get('scale', 100)

    # modes need to be specifically a list or a tuple (cannot be an array)
    if modes is None:
        n_modes = 0
    else:
        modes = wrapModes(modes)
        n_modes = len(modes)

    if method is None:
        import sys        
        if 'py3Dmol' in sys.modules: 
            method = 'py3Dmol'
        else:
            method = 'matplotlib'
    method = method.lower()
        
    alist = atoms
    for atoms in alist:
        if not isinstance(atoms, Atomic):
            raise TypeError('atoms must be an Atomic instance')
            
    if n_modes and n_modes != len(alist):
        raise RuntimeError('the number of proteins ({0}) does not match that of the modes ({1}).'
                            .format(len(alist), n_modes))

    if '3dmol' in method:
        mol = view3D(*alist, **kwargs)
        return mol
    else:
        import matplotlib.pyplot as plt
        from mpl_toolkits.mplot3d import Axes3D
        cf = plt.gcf()
        show = None
        for child in cf.get_children():
            if isinstance(child, Axes3D):
                show = child
                break
        if show is None:
            show = Axes3D(cf)
        from matplotlib import colors
        cnames = dict(colors.cnames)
        wcolor = kwargs.get('water', 'red').lower()
        avoid = np.array(colors.hex2color(cnames.pop(wcolor, cnames.pop('red'))))
        for cn, val in cnames.copy().items():  # PY3K: OK
            clr = np.array(colors.hex2color(val))
            if clr.sum() > 2.4:
                cnames.pop(cn)
            elif np.abs(avoid - clr).sum() <= 0.6:
                cnames.pop(cn)
        cnames = list(cnames)
        import random
        random.shuffle(cnames)
        cnames_copy = list(cnames)
        min_ = list()
        max_ = list()
        for i, atoms in enumerate(alist):
            if isinstance(atoms, AtomGroup):
                title = atoms.getTitle()
            else:
                title = atoms.getAtomGroup().getTitle()
            calpha = atoms.select('calpha')
            if calpha:
                partition = False
                mode = modes[i] if n_modes else None
                if mode is not None:
                    is3d = False
                    try:
                        arr = mode.getArray()
                        is3d = mode.is3d()
                        n_nodes = mode.numAtoms()
                    except AttributeError:
                        arr = mode
                        is3d = len(arr) == len(calpha)*3
                        n_nodes = len(arr)//3 if is3d else len(arr)
                    if n_nodes != len(calpha):
                        raise RuntimeError('size mismatch between the protein ({0} residues) and the mode ({1} nodes).'
                                            .format(len(calpha), n_nodes))
                    partition = not is3d

                if partition:
                    xyz = calpha._getCoords()
                    chids = calpha.getChids()
                    rbody = []
                    last_sign = np.sign(arr[0])
                    last_chid = chids[0]
                    rcolor = ['red', 'red', 'blue']
                    n = 1
                    for i,a in enumerate(arr):
                        s = np.sign(a)
                        ch = chids[i]
                        if s == 0: s = last_sign
                        if last_sign != s or i == len(arr)-1 or last_chid != ch:
                            if last_chid == ch:
                                rbody.append(i)
                            show.plot(xyz[rbody, 0], xyz[rbody, 1], xyz[rbody, 2],
                                      label=title + '_regid%d'%n,
                                      color=rcolor[int(last_sign+1)],
                                      lw=kwargs.get('lw', 4))
                            rbody = []
                            n += 1
                            last_sign = s
                            last_chid = ch
                        rbody.append(i)
                else:
                    for ch in HierView(calpha, chain=True):
                        xyz = ch._getCoords()
                        chid = ch.getChid()
                        if len(cnames) == 0:
                            cnames = list(cnames_copy)
                        show.plot(xyz[:, 0], xyz[:, 1], xyz[:, 2],
                                label=title + '_' + chid,
                                color=kwargs.get(chid, cnames.pop()).lower(),
                                lw=kwargs.get('lw', 4))
                    
                    if mode is not None:
                        from prody.utilities.drawtools import drawArrow3D
                        XYZ = calpha._getCoords()
                        arr = arr.reshape((n_nodes, 3))
                        XYZ2 = XYZ + arr * scale
                        for i, xyz in enumerate(XYZ):
                            xyz2 = XYZ2[i]
                            mutation_scale = kwargs.pop('mutation_scale', 10)
                            drawArrow3D(xyz, xyz2, mutation_scale=mutation_scale, **kwargs)

            water = atoms.select('water and noh')
            if water:
                xyz = atoms.select('water')._getCoords()
                show.plot(xyz[:, 0], xyz[:, 1], xyz[:, 2], label=title + '_water',
                          color=wcolor,
                          ls='None', marker=kwargs.get('wmarker', '.'),
                          ms=kwargs.get('wsize', 6))
            hetero = atoms.select('not protein and not nucleic and not water')
            if hetero:
                for res in HierView(hetero).iterResidues():
                    xyz = res._getCoords()
                    resname = res.getResname()
                    resnum = str(res.getResnum())
                    chid = res.getChid()
                    if len(cnames) == 0:
                        cnames = list(cnames_copy)
                    show.plot(xyz[:, 0], xyz[:, 1], xyz[:, 2], ls='None',
                              color=kwargs.get(resname, cnames.pop()).lower(),
                              label=title + '_' + chid + '_' + resname + resnum,
                              marker=kwargs.get('hmarker', 'o'),
                              ms=kwargs.get('hsize', 6))
            xyz = atoms._getCoords()
            min_.append(xyz.min(0))
            max_.append(xyz.max(0))

        show.set_xlabel('x')
        show.set_ylabel('y')
        show.set_zlabel('z')
        min_ = np.array(min_).min(0)
        max_ = np.array(max_).max(0)
        center = (max_ + min_) / 2
        half = (max_ - min_).max() / 2
        show.set_xlim3d(center[0]-half, center[0]+half)
        show.set_ylim3d(center[1]-half, center[1]+half)
        show.set_zlim3d(center[2]-half, center[2]+half)
        show.legend(prop={'size': 10})
        plt.axis('off')
        plt.show()   
        
def showdialog(msgtitle,msgtxt):
        mb = QMessageBox()
        mb.setIcon(QMessageBox.Information)
        mb.setWindowTitle(msgtitle)
        mb.setText(msgtxt)
        mb.setStandardButtons(QMessageBox.Ok)
        mb.exec_()

class Ui_Help(object):
    def setupUi(self, Help):
        Help.setObjectName("Help")
        Help.resize(800, 600)
        self.centralwidget = QtWidgets.QWidget(Help)
        self.centralwidget.setObjectName("centralwidget")
        self.scrollArea = QtWidgets.QScrollArea(self.centralwidget)
        self.scrollArea.setGeometry(QtCore.QRect(10, 10, 771, 511))
        self.scrollArea.setWidgetResizable(True)
        self.scrollArea.setObjectName("scrollArea")
        self.scrollAreaWidgetContents = QtWidgets.QWidget()
        self.scrollAreaWidgetContents.setGeometry(QtCore.QRect(0, 0, 769, 509))
        self.scrollAreaWidgetContents.setObjectName("scrollAreaWidgetContents")
        self.plainTextEdit = QtWidgets.QPlainTextEdit(self.scrollAreaWidgetContents)
        self.plainTextEdit.setGeometry(QtCore.QRect(0, 0, 771, 511))
        self.plainTextEdit.setObjectName("plainTextEdit")
        self.scrollArea.setWidget(self.scrollAreaWidgetContents)
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(690, 530, 89, 25))
        self.pushButton.setObjectName("pushButton")
        Help.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(Help)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 22))
        self.menubar.setObjectName("menubar")
        self.menuFile = QtWidgets.QMenu(self.menubar)
        self.menuFile.setObjectName("menuFile")
        Help.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(Help)
        self.statusbar.setObjectName("statusbar")
        Help.setStatusBar(self.statusbar)
        self.actionClose = QtWidgets.QAction(Help)
        self.actionClose.setObjectName("actionClose")
        self.menuFile.addAction(self.actionClose)
        self.menubar.addAction(self.menuFile.menuAction())

        self.retranslateUi(Help)
        QtCore.QMetaObject.connectSlotsByName(Help)



    def retranslateUi(self, Help):
        _translate = QtCore.QCoreApplication.translate
        Help.setWindowTitle(_translate("Help", "G_Measures " + _version_ +" - How to Use"))
        self.pushButton.setText(_translate("Help", "Close"))
        self.menuFile.setTitle(_translate("Help", "File"))
        self.actionClose.setText(_translate("Help", "Close"))

        ################################################ Help
        self.plainTextEdit.setReadOnly(True)
        self.plainTextEdit.setPlainText(_help)
        self.actionClose.triggered.connect(Help.close)
        self.pushButton.clicked.connect(Help.close)

class Ui_Converter(object):
    def setupUi(self, Converter):
        Converter.setObjectName("Converter")
        Converter.resize(800, 335)
        self.centralwidget = QtWidgets.QWidget(Converter)
        self.centralwidget.setObjectName("centralwidget")
        self.groupBox = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox.setGeometry(QtCore.QRect(10, 20, 771, 101))
        self.groupBox.setObjectName("groupBox")
        self.tpr_line = QtWidgets.QLineEdit(self.groupBox)
        self.tpr_line.setGeometry(QtCore.QRect(80, 30, 591, 20))
        self.tpr_line.setObjectName("tpr_line")
        self.bt_tpr = QtWidgets.QPushButton(self.groupBox)
        self.bt_tpr.setGeometry(QtCore.QRect(690, 30, 75, 23))
        self.bt_tpr.setObjectName("bt_tpr")
        self.xtc_line = QtWidgets.QLineEdit(self.groupBox)
        self.xtc_line.setGeometry(QtCore.QRect(80, 60, 591, 20))
        self.xtc_line.setObjectName("xtc_line")
        self.bt_xtc = QtWidgets.QPushButton(self.groupBox)
        self.bt_xtc.setGeometry(QtCore.QRect(690, 60, 75, 23))
        self.bt_xtc.setObjectName("bt_xtc")
        self.label = QtWidgets.QLabel(self.groupBox)
        self.label.setGeometry(QtCore.QRect(10, 30, 71, 16))
        self.label.setObjectName("label")
        self.label_2 = QtWidgets.QLabel(self.groupBox)
        self.label_2.setGeometry(QtCore.QRect(10, 60, 61, 16))
        self.label_2.setObjectName("label_2")
        self.groupBox_2 = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox_2.setGeometry(QtCore.QRect(10, 160, 771, 121))
        self.groupBox_2.setObjectName("groupBox_2")
        self.pdb_line0 = QtWidgets.QLineEdit(self.groupBox_2)
        self.pdb_line0.setGeometry(QtCore.QRect(80, 30, 591, 20))
        self.pdb_line0.setObjectName("pdb_line0")
        self.bt_pdb0 = QtWidgets.QPushButton(self.groupBox_2)
        self.bt_pdb0.setGeometry(QtCore.QRect(690, 30, 75, 23))
        self.bt_pdb0.setObjectName("bt_pdb0")
        self.label_3 = QtWidgets.QLabel(self.groupBox_2)
        self.label_3.setGeometry(QtCore.QRect(10, 30, 71, 16))
        self.label_3.setObjectName("label_3")
        self.line = QtWidgets.QFrame(self.centralwidget)
        self.line.setGeometry(QtCore.QRect(10, 270, 771, 16))
        self.line.setFrameShape(QtWidgets.QFrame.HLine)
        self.line.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line.setObjectName("line")
        self.bt_convert = QtWidgets.QPushButton(self.centralwidget)
        self.bt_convert.setGeometry(QtCore.QRect(10, 230, 75, 23))
        self.bt_convert.setObjectName("bt_convert")
        self.bt_close = QtWidgets.QPushButton(self.centralwidget)
        self.bt_close.setGeometry(QtCore.QRect(90, 290, 75, 23))
        self.bt_close.setObjectName("bt_close")
        self.bt_cancel = QtWidgets.QPushButton(self.centralwidget)
        self.bt_cancel.setGeometry(QtCore.QRect(10, 290, 75, 23))
        self.bt_cancel.setObjectName("bt_cancel")
        Converter.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(Converter)
        self.statusbar.setObjectName("statusbar")
        Converter.setStatusBar(self.statusbar)
        

        self.retranslateUi(Converter)
        QtCore.QMetaObject.connectSlotsByName(Converter)

    def retranslateUi(self, Converter):
        _translate = QtCore.QCoreApplication.translate
        Converter.setWindowTitle(_translate("Converter", "G_Measures " + _version_ +" - Converter"))
        self.groupBox.setTitle(_translate("Converter", "Input files:"))
        self.bt_tpr.setText(_translate("Converter", "Browse"))
        self.bt_xtc.setText(_translate("Converter", "Browse"))
        self.label.setText(_translate("Converter", "TPR File:"))
        self.label_2.setText(_translate("Converter", "XTC File:"))
        self.groupBox_2.setTitle(_translate("Converter", "Output file:"))
        self.bt_pdb0.setText(_translate("Converter", "Browse"))
        self.label_3.setText(_translate("Converter", "PDB File:"))
        self.bt_convert.setText(_translate("Converter", "Convert"))
        self.bt_close.setText(_translate("Converter", "Close"))
        self.bt_cancel.setText(_translate("Converter", "Cancel"))
        
######################################################## converter
        self.tpr_line.setText('No select file.')
        self.tpr_line.setReadOnly(True)
        self.bt_tpr.clicked.connect(self.opentprfile)
        self.xtc_line.setText('No select file.')
        self.xtc_line.setReadOnly(True)
        self.bt_xtc.clicked.connect(self.openxtcfile)
        self.pdb_line0.setText('No file name.')
        self.pdb_line0.setReadOnly(True)
        self.bt_pdb0.clicked.connect(self.save_pdb)
        self.bt_convert.clicked.connect(self.ConvertingXTCFileToPDBFile)
        self.bt_cancel.clicked.connect(self.kill_process)
        self.bt_close.clicked.connect(Converter.close)
        self.process = QProcess()
        self.mylistofprocesses = []
########################################################
	
    
    def kill_process(self):
        self.process.terminate()
        # Wait for Xms and then elevate the situation to terminate
        if not self.process.waitForFinished(10000):
          self.process.kill()
        self.statusbar.showMessage('The process has been canceled.')


    def setupProcess(self):
        
        # Run the process with a given command
        if gromacs_flag('mdrun'):
            cmd ="echo 1, 1 |trjconv -f "+ self.xtc_file[0] +" -s "+ self.tpr_file[0] +" -o "+self.fileName0+" -pbc nojump -ur compact -center"
        elif gromacs_flag('gmx'):
            cmd ="echo 1, 1 |gmx trjconv -f "+ self.xtc_file[0] +" -s "+ self.tpr_file[0] +" -o "+self.fileName0+" -pbc nojump -ur compact -center"
        self.process.start('bash', ['-c', cmd])
        self.process.started.connect(lambda: self.bt_convert.setEnabled(False))
        self.process.finished.connect(lambda: self.bt_convert.setEnabled(True))
        self.process.finished.connect(lambda: self.pdb_line0.clear())
        self.process.finished.connect(lambda: self.xtc_line.clear())
        self.process.finished.connect(lambda: self.tpr_line.clear())
        self.mylistofprocesses.append(self.process)

        status = {QProcess.NotRunning: "Done !",
                  QProcess.Starting: "Starting",
                  QProcess.Running: "Please wait.. Trjconv is running.."}

        self.process.stateChanged.connect(lambda state: self.statusbar.showMessage(status[state]))


    def __del__(self):
        # If QApplication is closed attempt to kill the process
        self.process.terminate()
        # Wait for Xms and then elevate the situation to terminate
        if not self.process.waitForFinished(10000):
          self.process.kill()

    
    
    def opentprfile(self):
        try:
            tpr_dialog = QtWidgets.QFileDialog()
            self.tpr_file = tpr_dialog.getOpenFileName(None, "Select TPR file", WORK_PATH, "TPR files (*.tpr)")
            if os.path.isfile(self.tpr_file[0]):
                self.tpr_line.setText(self.tpr_file[0])
            else:
                self.tpr_line.setText('No select file.')
        except:
            pass

    def openxtcfile(self):
        try:
            xtc_dialog = QtWidgets.QFileDialog()
            self.xtc_file = xtc_dialog.getOpenFileName(None, "Select XTC file", WORK_PATH, "XTC files (*.xtc)")
            if os.path.isfile(self.xtc_file[0]):
                self.xtc_line.setText(self.xtc_file[0])
            else:
                self.xtc_line.setText('No select file.')
        except:
            pass

    def save_pdb(self):
        options = QtWidgets.QFileDialog.Options()
        options |= QtWidgets.QFileDialog.DontUseNativeDialog
        self.fileName, _ = QtWidgets.QFileDialog.getSaveFileName(None,"Save Multi-PDB file",""," Save PDB Files (*.pdb)", options=options)
        if self.fileName:
        	if self.fileName.endswith('.pdb'):
        		self.pdb_line0.setText(self.fileName)
        		self.fileName0 = self.fileName
        	else:
        		self.pdb_line0.setText(self.fileName+'.pdb')
        		self.fileName0 = self.fileName+'.pdb'
        else:
        	self.pdb_line0.setText('No select file.')
    

    def ConvertingXTCFileToPDBFile (self):
        if gromacs_flag('mdrun') or gromacs_flag ('gmx'):
        
            if self.xtc_file[0] and self.tpr_file[0] and self.fileName:
                if os.stat(self.xtc_file[0]).st_size and os.stat(self.tpr_file[0]).st_size != 0:
                    self.setupProcess()         
                else:
                    showdialog('Notice', 'XTC or TPR file not vaid')
            else:
                showdialog('Notice','TPR and XTC files must be selected.')
        else:
            showdialog('Notice', 'GROMACS program must be intalled')       
           
class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(800, 380)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.progressBar = QtWidgets.QProgressBar(self.centralwidget)
        self.progressBar.setGeometry(QtCore.QRect(10, 310, 771, 23))
        self.progressBar.setProperty("value", 24)
        self.progressBar.setObjectName("progressBar")
        self.groupBox = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox.setGeometry(QtCore.QRect(10, 20, 771, 91))
        self.groupBox.setObjectName("groupBox")
        self.pdb_line = QtWidgets.QLineEdit(self.groupBox)
        self.pdb_line.setGeometry(QtCore.QRect(10, 30, 671, 20))
        self.pdb_line.setObjectName("pdb_line")
        self.bt_process = QtWidgets.QPushButton(self.groupBox)
        self.bt_process.setGeometry(QtCore.QRect(10, 60, 75, 23))
        self.bt_process.setObjectName("bt_process")
        self.bt_pdb = QtWidgets.QPushButton(self.groupBox)
        self.bt_pdb.setGeometry(QtCore.QRect(690, 30, 75, 23))
        self.bt_pdb.setObjectName("bt_pdb")
        self.groupBox_2 = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox_2.setGeometry(QtCore.QRect(10, 120, 771, 131))
        self.groupBox_2.setObjectName("groupBox_2")
        self.cb_tool = QtWidgets.QComboBox(self.groupBox_2)
        self.cb_tool.setGeometry(QtCore.QRect(50, 40, 131, 22))
        self.cb_tool.setObjectName("cb_tool")
        self.cb_chain = QtWidgets.QComboBox(self.groupBox_2)
        self.cb_chain.setGeometry(QtCore.QRect(60, 80, 51, 22))
        self.cb_chain.setObjectName("cb_chain")
        self.label_2 = QtWidgets.QLabel(self.groupBox_2)
        self.label_2.setGeometry(QtCore.QRect(10, 40, 47, 13))
        self.label_2.setObjectName("label_2")
        self.label_3 = QtWidgets.QLabel(self.groupBox_2)
        self.label_3.setGeometry(QtCore.QRect(10, 80, 47, 13))
        self.label_3.setObjectName("label_3")
        self.cb_res1 = QtWidgets.QComboBox(self.groupBox_2)
        self.cb_res1.setGeometry(QtCore.QRect(470, 70, 101, 22))
        self.cb_res1.setObjectName("cb_res1")
        self.label_4 = QtWidgets.QLabel(self.groupBox_2)
        self.label_4.setGeometry(QtCore.QRect(390, 70, 71, 16))
        self.label_4.setObjectName("label_4")
        self.label_5 = QtWidgets.QLabel(self.groupBox_2)
        self.label_5.setGeometry(QtCore.QRect(580, 70, 71, 16))
        self.label_5.setObjectName("label_5")
        self.cb_res2 = QtWidgets.QComboBox(self.groupBox_2)
        self.cb_res2.setGeometry(QtCore.QRect(660, 70, 101, 22))
        self.cb_res2.setObjectName("cb_res2")
        self.label_6 = QtWidgets.QLabel(self.groupBox_2)
        self.label_6.setGeometry(QtCore.QRect(390, 100, 71, 16))
        self.label_6.setObjectName("label_6")
        self.cb_res3 = QtWidgets.QComboBox(self.groupBox_2)
        self.cb_res3.setGeometry(QtCore.QRect(470, 100, 101, 22))
        self.cb_res3.setObjectName("cb_res3")
        self.cb_res4 = QtWidgets.QComboBox(self.groupBox_2)
        self.cb_res4.setGeometry(QtCore.QRect(660, 100, 101, 22))
        self.cb_res4.setObjectName("cb_res4")
        self.label_7 = QtWidgets.QLabel(self.groupBox_2)
        self.label_7.setGeometry(QtCore.QRect(580, 100, 71, 16))
        self.label_7.setObjectName("label_7")
        self.label_8 = QtWidgets.QLabel(self.groupBox_2)
        self.label_8.setGeometry(QtCore.QRect(390, 40, 101, 16))
        self.label_8.setObjectName("label_8")
        self.label_9 = QtWidgets.QLabel(self.groupBox_2)
        self.label_9.setGeometry(QtCore.QRect(570, 40, 91, 16))
        self.label_9.setObjectName("label_9")
        self.sb_initial = QtWidgets.QSpinBox(self.groupBox_2)
        self.sb_initial.setGeometry(QtCore.QRect(490, 40, 71, 22))
        self.sb_initial.setObjectName("sb_initial")
        self.sb_final = QtWidgets.QSpinBox(self.groupBox_2)
        self.sb_final.setGeometry(QtCore.QRect(660, 40, 71, 22))
        self.sb_final.setObjectName("sb_final")
        self.bt_plot = QtWidgets.QPushButton(self.centralwidget)
        self.bt_plot.setGeometry(QtCore.QRect(90, 260, 75, 23))
        self.bt_plot.setObjectName("bt_plot")
        self.bt_getcsv = QtWidgets.QPushButton(self.centralwidget)
        self.bt_getcsv.setGeometry(QtCore.QRect(180, 260, 111, 23))
        self.bt_getcsv.setObjectName("bt_getcsv")
        self.line = QtWidgets.QFrame(self.centralwidget)
        self.line.setGeometry(QtCore.QRect(10, 290, 771, 16))
        self.line.setFrameShape(QtWidgets.QFrame.HLine)
        self.line.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line.setObjectName("line")
        self.bt_run = QtWidgets.QPushButton(self.centralwidget)
        self.bt_run.setGeometry(QtCore.QRect(10, 260, 75, 23))
        self.bt_run.setObjectName("bt_run")
        self.cb_selplot = QtWidgets.QComboBox(self.centralwidget)
        self.cb_selplot.setGeometry(QtCore.QRect(310, 260, 50, 23))
        self.cb_selplot.setObjectName("cb_selplot")
        self.label_10 = QtWidgets.QLabel(self.centralwidget)
        self.label_10.setGeometry(QtCore.QRect(350, 260, 100, 23))
        self.label_10.setObjectName("label_10")
        self.sb_frame = QtWidgets.QSpinBox(self.centralwidget)
        self.sb_frame.setGeometry(QtCore.QRect(430, 260, 75, 23))
        self.sb_frame.setObjectName("sb_frame")
        self.bt_getpdb = QtWidgets.QPushButton(self.centralwidget)
        self.bt_getpdb.setGeometry(QtCore.QRect(628, 260, 155, 23))
        self.bt_getpdb.setObjectName("bt_getpdb")
        self.bt_prot_view = QtWidgets.QPushButton(self.centralwidget)
        self.bt_prot_view.setGeometry(QtCore.QRect(520, 260, 100, 23))
        self.bt_prot_view.setObjectName("prot_view")
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 22))
        self.menubar.setObjectName("menubar")
        self.menuHelp = QtWidgets.QMenu(self.menubar)
        self.menuHelp.setObjectName("menuHelp")
        self.menuFile = QtWidgets.QMenu(self.menubar)
        self.menuFile.setObjectName("menuFile")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.actionAbout = QtWidgets.QAction(MainWindow)
        self.actionAbout.setObjectName("actionAbout")
        self.actionHow_to_use = QtWidgets.QAction(MainWindow)
        self.actionHow_to_use.setObjectName("actionHow_to_use")
        self.actionNew = QtWidgets.QAction(MainWindow)
        self.actionNew.setObjectName("actionNew")
        self.actionExit = QtWidgets.QAction(MainWindow)
        self.actionExit.setObjectName("actionExit")
        self.actionConverter = QtWidgets.QAction(MainWindow)
        self.actionConverter.setObjectName("actionConverter")
        self.menuHelp.addAction(self.actionAbout)
        self.menuHelp.addAction(self.actionHow_to_use)
        self.menuFile.addAction(self.actionNew)
        self.menuFile.addAction(self.actionConverter)
        self.menuFile.addAction(self.actionExit)
        self.menubar.addAction(self.menuFile.menuAction())
        self.menubar.addAction(self.menuHelp.menuAction())

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

########################################################## main

        self.progressBar.setProperty("value", 0)
        self.pdb_line.setObjectName("pdb_line")
        self.pdb_line.setText('No select file.')
        self.pdb_line.setReadOnly(True)
        self.bt_process.clicked.connect(self.preprocess)
        self.bt_process.setEnabled(False)
        self.bt_pdb.clicked.connect(self.openpdbfile)
        self.cb_tool.setObjectName("cb_tool")
        self.cb_tool.addItem("Pincer angle")
        self.cb_tool.addItem("Dihedral angle")
        self.cb_tool.addItem("Triangle area")
        self.cb_tool.addItem("PDF")
        self.cb_tool.addItem("RMSD")
        self.cb_tool.addItem("RG")
        self.cb_tool.addItem("FEL")
        self.cb_tool.currentIndexChanged.connect(self.res_hide)
        self.cb_tool.setEnabled(False)
        self.cb_selplot.addItem("2D")
        self.cb_selplot.addItem("3D")
        self.cb_selplot.setVisible(False)
        self.cb_chain.setEnabled(False)
        self.cb_res1.setEnabled(False)
        self.cb_res2.setEnabled(False)
        self.cb_res3.setEnabled(False)
        self.cb_res4.setEnabled(False)
        self.cb_res4.setVisible(False)
        self.label_7.setVisible(False)
        self.sb_initial.setEnabled(False)
        self.sb_final.setEnabled(False)
        self.bt_plot.setEnabled(False)
        self.bt_plot.clicked.connect(self.plottingData)
        self.bt_getcsv.clicked.connect(self.save_csv)
        self.bt_getcsv.setEnabled(False)
        self.bt_run.clicked.connect(self.run_tool)
        self.bt_prot_view.clicked.connect(self.proteinView)
        self.bt_prot_view.setEnabled(False)
        self.bt_run.setEnabled(False)
        self.bt_getpdb.setEnabled(False)
        self.sb_frame.setEnabled(False)
        self.bt_getpdb.clicked.connect(self.save_pdb)
        self.actionAbout.triggered.connect(self.showabout)
        self.actionConverter.triggered.connect(self.conVerter)
        self.actionHow_to_use.triggered.connect(self.heLp)
        self.actionNew.triggered.connect(self.new)
        self.actionExit.triggered.connect(QtWidgets.qApp.quit)
        self.process = QProcess()
        self.mylistofprocesses = []
##################################################################

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "G_Measures " + _version_))
        self.groupBox.setTitle(_translate("MainWindow", "Multi-PDB File:"))
        self.bt_process.setText(_translate("MainWindow", "Process"))
        self.bt_pdb.setText(_translate("MainWindow", "Browse"))
        self.groupBox_2.setTitle(_translate("MainWindow", "Analysis"))
        self.label_2.setText(_translate("MainWindow", "Tool:"))
        self.label_3.setText(_translate("MainWindow", "Chain:"))
        self.label_4.setText(_translate("MainWindow", "Residue 1:"))
        self.label_5.setText(_translate("MainWindow", "Residue 2:"))
        self.label_6.setText(_translate("MainWindow", "Residue 3:"))
        self.label_7.setText(_translate("MainWindow", "Residue 4:"))
        self.label_8.setText(_translate("MainWindow", "Initial Frame:"))
        self.label_9.setText(_translate("MainWindow", "Final Frame:"))
        self.label_10.setText(_translate("MainWindow", "Frame (10 ps):"))
        self.bt_plot.setText(_translate("MainWindow", "Plot"))
        self.bt_getcsv.setText(_translate("MainWindow", "Get CSV file"))
        self.bt_run.setText(_translate("MainWindow", "Run"))
        self.bt_getpdb.setText(_translate("MainWindow", "Get PDB time frame"))
        self.bt_prot_view.setText(_translate("MainWindow", "Show Protein"))
        self.menuHelp.setTitle(_translate("MainWindow", "Help"))
        self.menuFile.setTitle(_translate("MainWindow", "File"))
        self.actionAbout.setText(_translate("MainWindow", "About"))
        self.actionHow_to_use.setText(_translate("MainWindow", "How to use"))
        self.actionNew.setText(_translate("MainWindow", "New"))
        self.actionExit.setText(_translate("MainWindow", "Exit"))
        self.actionConverter.setText(_translate("MainWindow", "Converter"))
        
########################################################## main    
        self.TEMP_PATH = tempfile.mkdtemp()
        self.TABLE_PATH = self.TEMP_PATH+"/output.tbl"
        self.SHAM_PATH = self.TEMP_PATH+"/g_sham2.xvg"

    
    def conVerter(self):
        self.Converter = QtWidgets.QMainWindow()
        self.ui = Ui_Converter()
        self.ui.setupUi(self.Converter)
        self.Converter.show()

    def heLp(self):
        self.Help = QtWidgets.QMainWindow()
        self.ui = Ui_Help()
        self.ui.setupUi(self.Help)
        self.Help.show()

    def showabout(self):
        mb = QMessageBox()
        mb.setWindowTitle('About')
        mb.setText('''
                                                        G_Measures {}
The "Geometric Measures" script that was developed to carry out geometric analysis on protein structures.

Contributors:

Luciano Porto Kagami, Gustavo Machado das Neves, Lus Fernando Saraiva Macedo Timmers, Rafael Andrade Cceres and Vera Lucia Eifler-Lima

         '''.format(_version_)   )
        mb.setStandardButtons(QMessageBox.Ok)
        mb.exec_()    
      
        # Calculate the differntial geometry for all residues (arc length, curvature, writhing, phi and psi)

    def setupProcess(self):
        
        # Run the process with a given command
        if gromacs_flag('mdrun'):
            cmd ='g_sham -f g_sham2.xvg -ls free-energy-landscape.xpm'
        elif gromacs_flag('gmx'):
            cmd = 'gmx sham -f g_sham2.xvg -ls free-energy-landscape.xpm'                    
        self.process.start('bash', ['-c', cmd])
        self.process.finished.connect(lambda: self.dataFEL())
        self.mylistofprocesses.append(self.process)

        status = {QProcess.NotRunning: "Please wait ..",
                  QProcess.Starting: "Starting",
                  QProcess.Running: "Please wait.. Sham is running.."}

        self.process.stateChanged.connect(lambda state: self.statusbar.showMessage(status[state]))
    
    def kill_process(self):
        self.process.terminate()
        # Wait for Xms and then elevate the situation to terminate
        if not self.process.waitForFinished(10000):
          self.process.kill()
        self.statusbar.showMessage('Process has canceled.')

    def res_hide(self):
        if self.cb_tool.currentText() == "Dihedral angle":
            self.label_4.setVisible(True)
            self.cb_res1.setVisible(True)
            self.label_5.setVisible(True)
            self.cb_res2.setVisible(True)
            self.label_6.setVisible(True)
            self.cb_res3.setVisible(True)
            self.label_7.setVisible(True)
            self.cb_res4.setVisible(True)
            try:
            	shutil.rmtree(self.TABLE_PATH)
            except:
            	pass
            self.bt_run.setEnabled(True)
            self.bt_getcsv.setEnabled(False)
            self.bt_plot.setEnabled(False)
            self.statusbar.showMessage('Ready. Select the protein chain, amino acid residues and frame range. After click on Run.')

        elif self.cb_tool.currentText() == "RMSD":
            self.label_4.setVisible(False)
            self.cb_res1.setVisible(False)
            self.label_5.setVisible(False)
            self.cb_res2.setVisible(False)
            self.label_6.setVisible(False)
            self.cb_res3.setVisible(False)
            self.label_7.setVisible(False)
            self.cb_res4.setVisible(False)
            try:
            	shutil.rmtree(self.TABLE_PATH)
            except:
            	pass
            self.bt_run.setEnabled(True)
            self.bt_getcsv.setEnabled(False)
            self.bt_plot.setEnabled(False)
            self.statusbar.showMessage('Ready. Select the protein chain and frame range. After click on Run.')

        elif self.cb_tool.currentText() == "Pincer angle":
            self.label_4.setVisible(True)
            self.cb_res1.setVisible(True)
            self.label_5.setVisible(True)
            self.cb_res2.setVisible(True)
            self.label_6.setVisible(True)
            self.cb_res3.setVisible(True)
            self.label_7.setVisible(False)
            self.cb_res4.setVisible(False)
            try:
            	shutil.rmtree(self.TABLE_PATH)
            except:
            	pass
            self.bt_run.setEnabled(True)
            self.bt_getcsv.setEnabled(False)
            self.bt_plot.setEnabled(False)
            self.statusbar.showMessage('Ready. Select the protein chain, amino acid residues and frame range. After click on Run.')

        elif self.cb_tool.currentText() == "PDF":
        	self.label_4.setVisible(False)
        	self.cb_res1.setVisible(False)
        	self.label_5.setVisible(False)
        	self.cb_res2.setVisible(False)
        	self.label_6.setVisible(False)
        	self.cb_res3.setVisible(False)
        	self.label_7.setVisible(False)
        	self.cb_res4.setVisible(False)
        	try:
        		shutil.rmtree(self.TEMP_PATH+'/data.csv')
        	except:
        		pass
        	self.bt_run.setEnabled(True)
        	self.bt_getcsv.setEnabled(False)
        	self.bt_plot.setEnabled(False)
        	self.statusbar.showMessage('Ready. Select the protein chain and frame range. After click on Run.')

        elif self.cb_tool.currentText() == "RG":
            self.label_4.setVisible(False)
            self.cb_res1.setVisible(False)
            self.label_5.setVisible(False)
            self.cb_res2.setVisible(False)
            self.label_6.setVisible(False)
            self.cb_res3.setVisible(False)
            self.label_7.setVisible(False)
            self.cb_res4.setVisible(False)
            try:
            	shutil.rmtree(self.TABLE_PATH)
            except:
            	pass
            self.bt_run.setEnabled(True)
            self.bt_getcsv.setEnabled(False)
            self.bt_plot.setEnabled(False)
            self.statusbar.showMessage('Ready. Select the protein chain and frame range. After click on Run.')

        elif self.cb_tool.currentText() == "FEL":
            self.label_4.setVisible(False)
            self.cb_res1.setVisible(False)
            self.label_5.setVisible(False)
            self.cb_res2.setVisible(False)
            self.label_6.setVisible(False)
            self.cb_res3.setVisible(False)
            self.label_7.setVisible(False)
            self.cb_res4.setVisible(False)
            self.cb_selplot.setVisible(True)
            try:
            	shutil.rmtree(self.SHAM_PATH)
            except:
            	pass
            self.bt_run.setEnabled(True)
            self.bt_getcsv.setEnabled(False)
            self.bt_plot.setEnabled(False)
            self.statusbar.showMessage('Ready. Select the protein chain and frame range. After click on Run.')
        
        else:
            self.label_4.setVisible(True)
            self.cb_res1.setVisible(True)
            self.label_5.setVisible(True)
            self.cb_res2.setVisible(True)
            self.label_6.setVisible(True)
            self.cb_res3.setVisible(True)
            self.label_7.setVisible(False)
            self.cb_res4.setVisible(False)
            self.statusbar.showMessage('Ready. Select the protein chain, amino acid residues and frame range. After click on Run.')

    
        

    def openpdbfile(self):
        try:
            pdb_dialog = QtWidgets.QFileDialog()
            self.pdb_file = pdb_dialog.getOpenFileName(None, "Select PDB file", WORK_PATH, "PDB files (*.pdb)")
            if os.path.isfile(self.pdb_file[0]):
                self.pdb_line.setText(self.pdb_file[0])
                self.bt_process.setEnabled(True)
                self.statusbar.showMessage('Click in Process ...')
            else:
                self.statusbar.showMessage('')
                self.pdb_line.setText('No select file.')
                self.bt_process.setEnabled(False)        
        except:
            self.statusbar.showMessage('')
            self.pdb_line.setText('No select file.')
            self.bt_process.setEnabled(False)
            self.statusbar.showMessage('')
            self.pdb_line.setText('No select file.')
            self.bt_process.setEnabled(False)
    def list_residues(self):
        res_list = []
        structure = parser.get_structure(self.TEMP_PATH+"/complex_1.pdb",  self.TEMP_PATH+"/complex_1.pdb")
        for model in structure:
            for chain in model:
                for residue in chain:
                    resname = residue.get_resname()
                    resnumber = residue.get_id()
                    if resname != 'HOH':
                        res_list.append(resname+'_'+str(resnumber[1]))
        return res_list
   
    def list_chain(self):
        chain_list = []
        structure = parser.get_structure(self.TEMP_PATH+"/complex_1.pdb",  self.TEMP_PATH+"/complex_1.pdb")
        for model in structure:
            for chain in model:
                chain_list.append(chain.get_id())
        return chain_list

    def preprocess(self):
    	self.statusbar.showMessage('Please wait...Recognizing the multi-PDB file.')
    	showdialog('Notice','Processing time varies by file size. Please wait until the end of the process.')
    	shutil.copy(self.pdb_file[0], self.TEMP_PATH+'/multipdb.pdb')
    	if is_multi_pdb_file(self.TEMP_PATH+'/multipdb.pdb'):
    		self.postprocess()
    	else:
    		showdialog('Error','This file is not a valid Multi-PDB format')
    		self.statusbar.showMessage('Error. Multi-PDB file not recognized.')
        
    def postprocess(self):        
        
        # Get the number of MODELS in the Multi-PDB file
        self.models = countModel(self.TEMP_PATH+'/multipdb.pdb')
        model = 1
        new_text = ""

        # Setting the progress bar
        self.progressBar.setMaximum(self.models)
        count = 0
        for line in open(self.TEMP_PATH+'/multipdb.pdb', "r"):
            line = line.strip()
            if line == "ENDMDL":
                output = open(self.TEMP_PATH+"/complex_" + str(model) + ".pdb", "w")
                output.write(new_text.strip())
                output.close()
                model += 1
                new_text = ""
                # Updating progress bar
                count += 1
                self.progressBar.setValue(count)

            else:
                new_text += line + "\n"
        res_list = self.list_residues()
        ch_list = self.list_chain()
        for item in res_list:
            self.cb_res1.addItem(item)
            self.cb_res2.addItem(item)
            self.cb_res3.addItem(item)
            self.cb_res4.addItem(item)
            
        for item in ch_list:
            self.cb_chain.addItem(str(item))
        self.sb_final.setMaximum(self.models)
        self.sb_final.setValue(self.models)
        self.sb_initial.setMinimum(1)
        self.cb_res1.setEnabled(True)
        self.cb_res2.setEnabled(True)
        self.cb_res3.setEnabled(True)
        self.cb_res4.setEnabled(True)
        self.sb_initial.setEnabled(True)
        self.sb_final.setEnabled(True)
        self.cb_chain.setEnabled(True)
        self.progressBar.setProperty("value", 0)
        self.bt_run.setEnabled(True)
        self.bt_process.setEnabled(False)
        self.bt_pdb.setEnabled(False)
        self.cb_tool.setEnabled(True)
        self.sb_frame.setMaximum(self.models)
        self.sb_frame.setMinimum(1)
        self.statusbar.showMessage('Ready. Select the protein chain, amino acid residues and frame range. After click on Run.')
    
    def dataFEL(self):
        xpm_file = 'free-energy-landscape.xpm'
        xpm_handle = open(xpm_file)
        xpm_data = []
        x_axis, y_axis = [], []
        letter_to_value = {}
        for line in xpm_handle:
            if line.startswith("/* x-axis"):
                x_ax = map(float, line.split()[2:-2]) # We trim the last value
                x_axis = list(x_ax)
            if line.startswith("/* y-axis"):
                y_ax = map(float, line.split()[2:-2]) # We trim the last value
                y_axis = list(y_ax)
            if line.startswith('"') and x_axis and y_axis: # Read data
                xpm_data.insert(0, line.strip().strip(',')[1:-1])
            if line.startswith('"') and len(line.split()) > 4:
                letter = line.split()[0][1:]
                value = float(line.split()[-2][1:-1])
                letter_to_value[letter] = value
        xpm_handle.close()
        txt_values = []
        data = []
        for y_index, data_value in enumerate(xpm_data):
            y_value = y_axis[y_index]
            for x_index, x_value in enumerate(x_axis):
                txt_values.append([x_value, y_value, letter_to_value[data_value[x_index]]])
            for x, y, z in txt_values:
                data.append ([float(x),float(y),float(z)])
        labels = ['RMSD (nm)', 'RG (nm)', 'Gb_E (kj/mol)']
        df = pd.DataFrame.from_records(data, columns=labels)
        df.to_csv('data.csv')                   
        self.bt_plot.setEnabled(True)
        self.bt_getcsv.setEnabled(True)
        self.bt_run.setEnabled(False)
        self.sb_frame.setEnabled(True)
        self.bt_getpdb.setEnabled(True)
        self.bt_prot_view.setEnabled(True)
        self.statusbar.showMessage('Done! Click in Plot or Get CSV File')

    def run_tool(self):
        _res1 = str(self.cb_res1.currentText())
        _res2 = str(self.cb_res2.currentText())
        _res3 = str(self.cb_res3.currentText())
        _res4 = str(self.cb_res4.currentText())
        res1=_res1.split('_')
        res2=_res2.split('_')
        res3=_res3.split('_')
        res4=_res4.split('_')
        trajectory_file=self.TEMP_PATH+'/multipdb.pdb'
        chain=self.cb_chain.currentText()
        final=self.sb_final.value()
        first=self.sb_initial.value()
        self.statusbar.showMessage('Running '+ self.cb_tool.currentText() + ' tool please wait...')

        if self.cb_tool.currentText() == "Pincer angle":
            values = [res1[1],res2[1],res3[1]]
            if len(values) == len(set(values)):
                res_angle=str(res1[1])+','+str(res2[1])+','+str(res3[1])
                dataAll = [] 
                dataArea = []
                dataAngle = []
                dataDihedral = []
                dataRMSD = []
                dataRG = []
                areaLabels = 'Frame\tDist_AB\tDist_AC\tDist_BC\tArea\n'
                angleLabels = 'Frame\tAngle\n'
                dihedralLabels = 'Frame\tDihedral\n'
                rmsLabels = 'Frame\tRMSD\n'
                rgLabels = 'Frame\tRG\n'
                allLabels = 'Frame\tDist_AB\tDist_AC\tDist_BC\tArea\tAngle\tDihedral\tRMSD\tRG\n'
                self.progressBar.setMaximum(final - 1)
                count = 0
                angleRes = res_angle.split(',')
                for frame in range(first ,final):
                        
                    model = parser.get_structure(self.TEMP_PATH+"/complex_" + str(frame) + ".pdb", self.TEMP_PATH+"/complex_" + str(frame) + ".pdb")
                        
                    # Updating progress bar2
                    count += 1
                    self.progressBar.setValue(count)

                    # Calculate pincer angle
                        
                    atom1 = model[0][chain][int(angleRes[0])]['CA']
                    atom2 = model[0][chain][int(angleRes[1])]['CA']
                    atom3 = model[0][chain][int(angleRes[2])]['CA']
                    vector1 = atom1.get_vector()
                    vector2 = atom2.get_vector()
                    vector3 = atom3.get_vector()
                    angle = calc_angle(vector1, vector2, vector3)
                    angleLabels += "%i\t%.2f\n" %(frame,math.degrees(angle))

                dataAngle.append(angleLabels)
                Angleoutput = open(self.TABLE_PATH, "w")
                Angleoutput.writelines(dataAngle)   
                Angleoutput.close()
                self.bt_plot.setEnabled(True)
                self.bt_getcsv.setEnabled(True)
                self.bt_run.setEnabled(False)
                self.sb_frame.setEnabled(True)
                self.bt_getpdb.setEnabled(True)
                self.bt_prot_view.setEnabled(True)
                self.statusbar.showMessage('Done! Click in Plot or Get CSV File')        
                 
            else:
                showdialog('Notice', 'Selected Residues must be differents.')

        elif self.cb_tool.currentText() == "Dihedral angle":
            values = [res1[1],res2[1],res3[1],res4[1]]
            if len(values) == len(set(values)):
                res_dihedral=str(res1[1])+','+str(res2[1])+','+str(res3[1])+','+str(res4[1])
                dataAll = [] 
                dataArea = []
                dataAngle = []
                dataDihedral = []
                dataRMSD = []
                dataRG = []
                areaLabels = 'Frame\tDist_AB\tDist_AC\tDist_BC\tArea\n'
                angleLabels = 'Frame\tAngle\n'
                dihedralLabels = 'Frame\tDihedral\n'
                rmsLabels = 'Frame\tRMSD\n'
                rgLabels = 'Frame\tRG\n'
                allLabels = 'Frame\tDist_AB\tDist_AC\tDist_BC\tArea\tAngle\tDihedral\tRMSD\tRG\n'
                self.progressBar.setMaximum(final - 1)
                count = 0
                dihedralRes = res_dihedral.split(',')
                for frame in range(first ,final):
                            
                    model = parser.get_structure(self.TEMP_PATH+"/complex_" + str(frame) + ".pdb",  self.TEMP_PATH+"/complex_" + str(frame) + ".pdb")
                            
                    # Updating progress bar2
                    count += 1
                    self.progressBar.setValue(count)
                        
                    atom1 = model[0][chain][int(dihedralRes[0])]['CA']
                    atom2 = model[0][chain][int(dihedralRes[1])]['CA']
                    atom3 = model[0][chain][int(dihedralRes[2])]['CA']
                    atom4 = model[0][chain][int(dihedralRes[3])]['CA']
                    vector1 = atom1.get_vector()
                    vector2 = atom2.get_vector()
                    vector3 = atom3.get_vector()
                    vector4 = atom4.get_vector()
                    dihedral = calc_dihedral(vector1, vector2, vector3, vector4)
                    dihedralLabels += "%i\t%.2f\n" %(frame,math.degrees(dihedral))

                dataDihedral.append(dihedralLabels)
                Dihedraloutput = open(self.TABLE_PATH, "w")
                Dihedraloutput.writelines(dataDihedral) 
                Dihedraloutput.close()
                self.bt_plot.setEnabled(True)
                self.bt_getcsv.setEnabled(True)
                self.bt_run.setEnabled(False)
                self.sb_frame.setEnabled(True)
                self.bt_getpdb.setEnabled(True)
                self.bt_prot_view.setEnabled(True)
                self.statusbar.showMessage('Done! Click in Plot or Get CSV File')                    
            else:
                showdialog('Notice', 'Selected Residues must be differents.')

        elif self.cb_tool.currentText() == "Triangle area":
            values = [res1[1],res2[1],res3[1]]
            if len(values) == len(set(values)):
                res_area=str(res1[1])+','+str(res2[1])+','+str(res3[1])
                dataAll = [] 
                dataArea = []
                dataAngle = []
                dataDihedral = []
                dataRMSD = []
                dataRG = []
                areaLabels = 'Frame\tDist_AB\tDist_AC\tDist_BC\tArea\n'
                angleLabels = 'Frame\tAngle\n'
                dihedralLabels = 'Frame\tDihedral\n'
                rmsLabels = 'Frame\tRMSD\n'
                rgLabels = 'Frame\tRG\n'
                allLabels = 'Frame\tDist_AB\tDist_AC\tDist_BC\tArea\tAngle\tDihedral\tRMSD\tRG\n'
                self.progressBar.setMaximum(final - 1)
                count = 0
                areaRes = res_area.split(',')                
                for frame in range(first ,final):
                        
                        
                    model = parser.get_structure(self.TEMP_PATH+"/complex_" + str(frame) + ".pdb",  self.TEMP_PATH+"/complex_" + str(frame) + ".pdb")
                            
                    count += 1
                    self.progressBar.setValue(count)    
                                                                    
                    atom1 = model[0][chain][int(areaRes[0])]['CA']
                    atom2 = model[0][chain][int(areaRes[1])]['CA']
                    atom3 = model[0][chain][int(areaRes[2])]['CA']
                            
                    coordAB = model[0][chain][int(areaRes[0])]['CA'].coord - model[0][chain][int(areaRes[1])]['CA'].coord
                    coordAC = model[0][chain][int(areaRes[0])]['CA'].coord - model[0][chain][int(areaRes[2])]['CA'].coord
                    coordBC = model[0][chain][int(areaRes[1])]['CA'].coord - model[0][chain][int(areaRes[2])]['CA'].coord
                            
                    distAB = np.sqrt(np.sum(coordAB * coordAB))
                    distAC = np.sqrt(np.sum(coordAC * coordAC))
                    distBC = np.sqrt(np.sum(coordBC * coordBC))
                            
                    sPerimeter = (distAB + distAC + distBC) / 2
                            
                    area = (sPerimeter*(sPerimeter-distAB)*(sPerimeter-distAC)*(sPerimeter-distBC)) ** 0.5
                    areaLabels += "%i\t%.2f\t%.2f\t%.2f\t%.2f\n" %(frame, distAB, distAC, distBC, area)

                dataArea.append(areaLabels)
                Triangleoutput = open(self.TABLE_PATH, "w")
                Triangleoutput.writelines(dataArea) 
                Triangleoutput.close()
                self.bt_plot.setEnabled(True)
                self.bt_getcsv.setEnabled(True)
                self.bt_run.setEnabled(False)
                self.sb_frame.setEnabled(True)
                self.bt_getpdb.setEnabled(True)
                self.bt_prot_view.setEnabled(True)
                self.statusbar.showMessage('Done! Click in Plot or Get CSV File')
            else:
                showdialog('Notice', 'Selected Residues must be differents.')

        elif self.cb_tool.currentText() == "PDF":
	            dataAll = [] 
	            dataArea = []
	            dataAngle = []
	            dataDihedral = []
	            dataRMSD = []
	            dataRG = []
	            dataFEL = []
	            FELlabels = ''
	            rmsLabels = ''
	            rgLabels = ''
	            Frame = np.array([])
	            k = 0
	            self.statusbar.showMessage('Running PDF tool (RMSD) please wait...')
	            refStruct = parser.get_structure(self.TABLE_PATH+"/complex_1.pdb",  self.TEMP_PATH+"/complex_1.pdb")
	            refStruct = refStruct[0]
	            refModelChain = refStruct[chain]
	            refCaAtoms = []
	            for refRes in refModelChain:
	                resnum = refRes.get_id()[1]
	                refCaAtoms.append(refRes['CA'])
	            # Setting the progress bar2
	            self.progressBar.setMaximum(final - 1)
	            count = 0
	                            
	            for frame in range(first ,final):
	                            
	                model = parser.get_structure(self.TEMP_PATH+"/complex_" + str(frame) + ".pdb",  self.TEMP_PATH+"/complex_" + str(frame) + ".pdb")
	                            
	                # Updating progress bar2
	                count += 1
	                self.progressBar.setValue(count)     
	                                                                
	                modelStruct = model[0]
	                ModelChain = modelStruct[chain]
	                modelCaAtoms = []
	                for modelRes in ModelChain:
	                    resnum = modelRes.get_id()[1]
	                    modelCaAtoms.append(modelRes['CA'])
	                sup = Superimposer()
	                sup.set_atoms(refCaAtoms, modelCaAtoms)
	                rmsd = sup.rms
	                dataRMSD.append(rmsd)
	            self.progressBar.setProperty("value", 0)
	            refStruct = parser.get_structure(self.TABLE_PATH+"/complex_1.pdb",  self.TEMP_PATH+"/complex_1.pdb")
	            refStruct = refStruct[0]
	            refModelChain = refStruct[chain]
	            refCaAtoms = []
	            for refRes in refModelChain:
	                resnum = refRes.get_id()[1]
	                refCaAtoms.append(refRes['CA'])
	                        
	            # Setting the progress bar2
	            self.progressBar.setMaximum(final - 1)
	            count = 0
	            self.statusbar.showMessage('Running PDF tool (RG) please wait...')                        
	            for frame in range(first ,final):
	                model = parser.get_structure(self.TEMP_PATH+"/complex_" + str(frame) + ".pdb",  self.TEMP_PATH+"/complex_" + str(frame) + ".pdb")
	                count += 1
	                self.progressBar.setValue(count)
	                m = model[0]                
	                allCA = []
	                for chain in m:
	                    for residue in chain:
	                        for atom in residue:
	                            if atom.get_id() == 'CA':
	                                caCoord = atom.get_coord()
	                                allCA.append(caCoord)

	                CoM = sum(allCA)/(len(allCA))
	                allCA2 = []
	                for chain in m:
	                    for residue in chain:
	                        for atom in residue:
	                            if atom.get_id() == 'CA':
	                                caCoord2 = atom.get_coord() - CoM
	                                quadCoord = (caCoord2)**2 * 12.04
	                                allCA2.append(quadCoord)
	                rg = math.sqrt((np.sum(allCA2))/((len(allCA2))*12.04))
	                dataRG.append(rg)
	                k=k+1
	                Frame = np.append(Frame, np.array([k]), axis=0)
	            
	            os.chdir(self.TEMP_PATH)
	            g_data =  pd.DataFrame()
	            g_data['Time (ps)'] = Frame
	            g_data['RMSD (nm)'] = dataRMSD
	            g_data['RG (nm)'] = dataRG
	            g_data.to_csv('data.csv')
	            self.bt_plot.setEnabled(True)
	            self.bt_getcsv.setEnabled(True)
	            self.bt_run.setEnabled(False)
	            self.sb_frame.setEnabled(True)
	            self.bt_getpdb.setEnabled(True)
	            self.bt_prot_view.setEnabled(True)
	            self.statusbar.showMessage('Done! Click in Plot or Get CSV File')

        elif self.cb_tool.currentText() == "RMSD":

                dataAll = [] 
                dataArea = []
                dataAngle = []
                dataDihedral = []
                dataRMSD = []
                dataRG = []
                areaLabels = 'Frame\tDist_AB\tDist_AC\tDist_BC\tArea\n'
                angleLabels = 'Frame\tAngle\n'
                dihedralLabels = 'Frame\tDihedral\n'
                rmsLabels = 'Frame\tRMSD\n'
                rgLabels = 'Frame\tRG\n'
                allLabels = 'Frame\tDist_AB\tDist_AC\tDist_BC\tArea\tAngle\tDihedral\tRMSD\tRG\n'
                
                refStruct = parser.get_structure(self.TABLE_PATH+"/complex_1.pdb",  self.TEMP_PATH+"/complex_1.pdb")
                refStruct = refStruct[0]
                refModelChain = refStruct[chain]
                refCaAtoms = []
                for refRes in refModelChain:
                    resnum = refRes.get_id()[1]
                    refCaAtoms.append(refRes['CA'])
                # Setting the progress bar2
                self.progressBar.setMaximum(final - 1)
                count = 0
                    
                for frame in range(first ,final):
                        
                    model = parser.get_structure(self.TEMP_PATH+"/complex_" + str(frame) + ".pdb",  self.TEMP_PATH+"/complex_" + str(frame) + ".pdb")
                                
                    # Updating progress bar2
                    count += 1
                    self.progressBar.setValue(count) 
                                                    
                    modelStruct = model[0]
                    ModelChain = modelStruct[chain]
                    modelCaAtoms = []
                    for modelRes in ModelChain:
                        resnum = modelRes.get_id()[1]
                        modelCaAtoms.append(modelRes['CA'])
                    sup = Superimposer()
                    sup.set_atoms(refCaAtoms, modelCaAtoms)
                    rmsd = sup.rms
                    rmsLabels += "%i\t%.2f\n" %(frame,rmsd)
                
                dataRMSD.append(rmsLabels)
                RMSDoutput = open(self.TABLE_PATH, "w")
                RMSDoutput.writelines(dataRMSD) 
                RMSDoutput.close()
                self.bt_plot.setEnabled(True)
                self.bt_getcsv.setEnabled(True)
                self.bt_run.setEnabled(False)
                self.sb_frame.setEnabled(True)
                self.bt_getpdb.setEnabled(True)
                self.bt_prot_view.setEnabled(True)
                self.statusbar.showMessage('Done! Click in Plot or Get CSV File')
                         
        elif self.cb_tool.currentText() == "RG":
            
                dataAll = [] 
                dataArea = []
                dataAngle = []
                dataDihedral = []
                dataRMSD = []
                dataRG = []
                areaLabels = 'Frame\tDist_AB\tDist_AC\tDist_BC\tArea\n'
                angleLabels = 'Frame\tAngle\n'
                dihedralLabels = 'Frame\tDihedral\n'
                rmsLabels = 'Frame\tRMSD\n'
                rgLabels = 'Frame\tRG\n'
                allLabels = 'Frame\tDist_AB\tDist_AC\tDist_BC\tArea\tAngle\tDihedral\tRMSD\tRG\n'
                
                refStruct = parser.get_structure(self.TABLE_PATH+"/complex_1.pdb",  self.TEMP_PATH+"/complex_1.pdb")
                refStruct = refStruct[0]
                refModelChain = refStruct[chain]
                refCaAtoms = []
                for refRes in refModelChain:
                    resnum = refRes.get_id()[1]
                    refCaAtoms.append(refRes['CA'])
                
                # Setting the progress bar2
                self.progressBar.setMaximum(final - 1)
                count = 0
                        
                for frame in range(first ,final):
                    model = parser.get_structure(self.TEMP_PATH+"/complex_" + str(frame) + ".pdb",  self.TEMP_PATH+"/complex_" + str(frame) + ".pdb")
                    # Updating progress bar2
                    count += 1
                    self.progressBar.setValue(count) 
                    m = model[0]                
                    allCA = []
                    for chain in m:
                        for residue in chain:
                            for atom in residue:
                                if atom.get_id() == 'CA':
                                    caCoord = atom.get_coord()
                                    allCA.append(caCoord)

                    CoM = sum(allCA)/(len(allCA))
                    allCA2 = []
                    for chain in m:
                        for residue in chain:
                            for atom in residue:
                                if atom.get_id() == 'CA':
                                    caCoord2 = atom.get_coord() - CoM
                                    quadCoord = (caCoord2)**2 * 12.04
                                    allCA2.append(quadCoord)

                    rg = math.sqrt((np.sum(allCA2))/((len(allCA2))*12.04))
                    rgLabels += "%i\t%.2f\n" %(frame,rg)
                
                dataRG.append(rgLabels)
                RGoutput = open(self.TABLE_PATH, "w")
                RGoutput.writelines(dataRG) 
                RGoutput.close()
                self.bt_plot.setEnabled(True)
                self.bt_getcsv.setEnabled(True)
                self.bt_run.setEnabled(False)
                self.sb_frame.setEnabled(True)
                self.bt_getpdb.setEnabled(True)
                self.bt_prot_view.setEnabled(True)
                self.statusbar.showMessage('Done! Click in Plot or Get CSV File')

        elif self.cb_tool.currentText() == "FEL":
            
            if gromacs_flag('mdrun') or gromacs_flag('gmx'):
                dataAll = [] 
                dataArea = []
                dataAngle = []
                dataDihedral = []
                dataRMSD = []
                dataRG = []
                dataFEL = []
                FELlabels = ''
                rmsLabels = ''
                rgLabels = ''
                Frame = np.array([])
                k = 0
                self.statusbar.showMessage('Running FEL tool (RMSD) please wait...')
                refStruct = parser.get_structure(self.TABLE_PATH+"/complex_1.pdb",  self.TEMP_PATH+"/complex_1.pdb")
                refStruct = refStruct[0]
                refModelChain = refStruct[chain]
                refCaAtoms = []
                for refRes in refModelChain:
                    resnum = refRes.get_id()[1]
                    refCaAtoms.append(refRes['CA'])
                # Setting the progress bar2
                self.progressBar.setMaximum(final - 1)
                count = 0
                                
                for frame in range(first ,final):
                                
                    model = parser.get_structure(self.TEMP_PATH+"/complex_" + str(frame) + ".pdb",  self.TEMP_PATH+"/complex_" + str(frame) + ".pdb")
                                
                    # Updating progress bar2
                    count += 1
                    self.progressBar.setValue(count)     
                                                                    
                    modelStruct = model[0]
                    ModelChain = modelStruct[chain]
                    modelCaAtoms = []
                    for modelRes in ModelChain:
                        resnum = modelRes.get_id()[1]
                        modelCaAtoms.append(modelRes['CA'])
                    sup = Superimposer()
                    sup.set_atoms(refCaAtoms, modelCaAtoms)
                    rmsd = sup.rms
                    dataRMSD.append(rmsd)
                self.progressBar.setProperty("value", 0)
                refStruct = parser.get_structure(self.TABLE_PATH+"/complex_1.pdb",  self.TEMP_PATH+"/complex_1.pdb")
                refStruct = refStruct[0]
                refModelChain = refStruct[chain]
                refCaAtoms = []
                for refRes in refModelChain:
                    resnum = refRes.get_id()[1]
                    refCaAtoms.append(refRes['CA'])
                            
                # Setting the progress bar2
                self.progressBar.setMaximum(final - 1)
                count = 0
                self.statusbar.showMessage('Running FEL tool (RG) please wait...')                        
                for frame in range(first ,final):
                    model = parser.get_structure(self.TEMP_PATH+"/complex_" + str(frame) + ".pdb",  self.TEMP_PATH+"/complex_" + str(frame) + ".pdb")
                    count += 1
                    self.progressBar.setValue(count)
                    m = model[0]                
                    allCA = []
                    for chain in m:
                        for residue in chain:
                            for atom in residue:
                                if atom.get_id() == 'CA':
                                    caCoord = atom.get_coord()
                                    allCA.append(caCoord)

                    CoM = sum(allCA)/(len(allCA))
                    allCA2 = []
                    for chain in m:
                        for residue in chain:
                            for atom in residue:
                                if atom.get_id() == 'CA':
                                    caCoord2 = atom.get_coord() - CoM
                                    quadCoord = (caCoord2)**2 * 12.04
                                    allCA2.append(quadCoord)
                    rg = math.sqrt((np.sum(allCA2))/((len(allCA2))*12.04))
                    dataRG.append(rg)
                    k=k+1
                    Frame = np.append(Frame, np.array([k]), axis=0)
                
                os.chdir(self.TEMP_PATH)
                g_data =  pd.DataFrame()
                g_data['a'] = Frame
                g_data['b'] = dataRMSD
                g_data['c'] = dataRG
                g_data.to_csv('g_sham2.xvg', sep='\t', index=False,  header=0)
                with open('g_sham2.xvg', 'r') as fin:
                    data = fin.read().splitlines(True)
                with open('g_sham2.xvg', 'w') as fout:
                    fout.writelines(data[1:])
                os.chdir(self.TEMP_PATH)
                self.setupProcess()                        
                   
            else:
                showdialog('Notice', 'GROMACS program must be intalled') 
              
    def plottingData(self):
        if self.cb_tool.currentText() == "Pincer angle":
            option='Angle'
            data=self.TABLE_PATH
            df = pd.read_csv(data, delimiter= '\t', header=0, sep='\t')
        elif self.cb_tool.currentText() == "Dihedral angle":
            option='Dihedral'
            data=self.TABLE_PATH
            df = pd.read_csv(data, delimiter= '\t', header=0, sep='\t')
        elif self.cb_tool.currentText() == "Triangle area":
            option='Area'
            data=self.TABLE_PATH
            df = pd.read_csv(data, delimiter= '\t', header=0, sep='\t')
        elif self.cb_tool.currentText() == "PDF":
            option='PDF'
            df = pd.read_csv(self.TEMP_PATH+'/data.csv')
        elif self.cb_tool.currentText() == "RMSD":
            option='RMSD'
            data=self.TABLE_PATH
            df = pd.read_csv(data, delimiter= '\t', header=0, sep='\t')
        elif self.cb_tool.currentText() == "RG":
            option = 'RG'
            data=self.TABLE_PATH
            df = pd.read_csv(data, delimiter= '\t', header=0, sep='\t')
        elif self.cb_tool.currentText() == "FEL":
            option='FEL'
            data = self.TEMP_PATH+'/data.csv'
            
        if option == 'PDF':

            fig, (ax1) = plt.subplots(nrows=1)            
            # Setting data
            x = df['RMSD (nm)']
            y = df['RG (nm)']

            # Calculate the point density
            xy = np.vstack([x,y])
            z = gaussian_kde(xy)(xy)

            # Sort the points by density, so that the densest points are plotted last
            idx = z.argsort()
            x, y, z = x[idx], y[idx], z[idx]

            # Setting plot type 
            pdf = ax1.scatter(x, y, c = z, s = 50, edgecolor = '', cmap=plt.cm.jet)

            # Plot title
            ax1.set_title('RMSD by RG')

            # Hide right and top spines
            ax1.spines['right'].set_visible(False)
            ax1.spines['top'].set_visible(False)
            ax1.yaxis.set_ticks_position('left')
            ax1.xaxis.set_ticks_position('bottom')

            # Set x and y limits
            xmin = df['RMSD (nm)'].min() - 1
            xmax = df['RMSD (nm)'].max() + 1
            ymin = df['RG (nm)'].min() - 1
            ymax = df['RG (nm)'].max() + 1        
            plt.xlim(xmin, xmax)
            plt.ylim(ymin, ymax)

            # Set x and y labels
            plt.xlabel('RMSD (nm)')
            plt.ylabel('RG (nm)')

            # Adding the color bar 
            colbar = plt.colorbar(pdf)
            colbar.set_label('Probability Density Function')     
            plt.show()

        elif option != 'PDF' and option != 'FEL':

            fig, (ax1) = plt.subplots(nrows=1)
            ax1.plot(df['Frame'], df[option])
            ax1.set_title(option + ' by Time')
            ax1.spines['right'].set_visible(False)
            ax1.spines['top'].set_visible(False)
            ax1.yaxis.set_ticks_position('left')
            ax1.xaxis.set_ticks_position('bottom')
            plt.xlabel('Frame (10 ps)')
            xmin1 = df['Frame'].min() - 1
            xmax1 = df['Frame'].max() + 1
            plt.xlim(xmin1, xmax1)
            plt.ylabel(option)        
            plt.show()
        
        elif option == 'FEL':
        	if self.cb_selplot.currentText() == "3D":
	            df = pd.read_csv(data)
	            fig = plt.figure(figsize=(15,10))
	            fig.suptitle('Free Energy Landscape', fontsize=20)
	            ax = fig.gca(projection='3d')
	            ax.set_xlabel('RMSD (nm)', fontsize=15)
	            ax.set_ylabel('RG (nm)', fontsize=15)
	            ax.set_zlabel('Gibbs Free Energy (kj/mol)', fontsize=15)
	            ax = fig.gca(projection='3d')
	            ax.plot_trisurf(df['RMSD (nm)'], df['RG (nm)'], df['Gb_E (kj/mol)'], cmap=plt.cm.jet, linewidth=0, antialiased=False)
	                
	            # to Add a color bar which maps values to colors.
	            surf=ax.plot_trisurf(df['RMSD (nm)'], df['RG (nm)'], df['Gb_E (kj/mol)'], cmap=plt.cm.jet, linewidth=0, antialiased=False)
	            colbar = fig.colorbar( surf, shrink=0.5, aspect=5)
	            colbar.set_label('Gibbs Free Energy (kj/mol)')
	            ax.tricontourf(df['RMSD (nm)'], df['RG (nm)'], df['Gb_E (kj/mol)'], zdir='z', offset=-1, cmap=plt.cm.jet)
	                
	            # Rotate it
	            ax.view_init(30, 15)
	            plt.show()
	        else:
	        	df = pd.read_csv(data)
	        	z = df['Gb_E (kj/mol)']
	        	X = df['RMSD (nm)']
	        	Y = df['RG (nm)']
	        	fig, ax = plt.subplots()
	        	fig.suptitle('Free Energy Landscape', fontsize=20)
	        	trico = ax.tricontourf(df['RMSD (nm)'], df['RG (nm)'], df['Gb_E (kj/mol)'], zdir='z', offset=-1, cmap=plt.cm.jet)
	        	ax.set_xlabel('RMSD (nm)', fontsize=15)
	        	ax.set_ylabel('RG (nm)', fontsize=15)
	        	colbar = fig.colorbar(trico, shrink=0.5, aspect=5)
	        	colbar.set_label('Gibbs Free Energy (kj/mol)')
	        	plt.show()

    def clean_temp_files(self):
    	try:
    		shutil.rmtree(self.TEMP_PATH)
    	except:
    		pass



    def new(self):
        
        showdialog('Notice', 'Please wait .. Deleting the temporary folder may take a few minutes.')
        shutil.rmtree(self.TEMP_PATH)
        self.TEMP_PATH = tempfile.mkdtemp()
        self.pdb_line.clear()
        self.cb_res1.clear()
        self.cb_res2.clear()
        self.cb_res3.clear()
        self.cb_res4.clear()
        self.cb_chain.clear()
        self.bt_pdb.setEnabled(True)
        self.bt_getcsv.setEnabled(False)
        self.bt_plot.setEnabled(False)
        self.sb_final.setValue(0)
        self.sb_initial.setValue(0)
        self.statusbar.showMessage('Ready...')



    def save_csv(self):
        options = QtWidgets.QFileDialog.Options()
        options |= QtWidgets.QFileDialog.DontUseNativeDialog
        fileName, _ = QtWidgets.QFileDialog.getSaveFileName(None,"Save CSV file",""," Save CSV Files (*.csv)", options=options)
        if fileName:
            if self.cb_tool.currentText() != "FEL" and self.cb_tool.currentText() != "PDF":
                data=self.TABLE_PATH
                df = pd.read_csv(data, delimiter= '\t', sep='\t')
                if fileName.endswith('.csv'):
                	df.to_csv(fileName)
                else:
                	df.to_csv(fileName+'.csv')
            elif self.cb_tool.currentText() == "PDF":
            	df = pd.read_csv(self.TEMP_PATH+'/data.csv')

            	if fileName.endswith('.csv'):
            		df.to_csv(fileName)
            	else:
                	df.to_csv(fileName+'.csv')
            else:
                if os.path.exists(self.TEMP_PATH+'/data.csv'):
                	if fileName.endswith('.csv'):
                		shutil.copy(self.TEMP_PATH+'/data.csv', fileName)
                	else:
                		shutil.copy(self.TEMP_PATH+'/data.csv', fileName+'.csv')
        else:
            print('Error')

    def save_pdb(self):
        options = QtWidgets.QFileDialog.Options()
        options |= QtWidgets.QFileDialog.DontUseNativeDialog
        fileName, _ = QtWidgets.QFileDialog.getSaveFileName(None,"Save PDB file",""," Save PDB Files (*.pdb)", options=options)
        frame_time = self.sb_frame.value()
        if fileName:
        	if fileName.endswith('.pdb'):
        		shutil.copy(self.TEMP_PATH+"/complex_" + str(frame_time) + ".pdb", fileName)
        	else:
        		shutil.copy(self.TEMP_PATH+"/complex_" + str(frame_time) + ".pdb", fileName+'.pdb')
        else:
            print('Error')        	
    
    def closeEvent(self):
        print('Bye')
        self.clean_temp_files
        sys.exit(0)

    def proteinView(self):
    	_res1 = str(self.cb_res1.currentText())
    	_res2 = str(self.cb_res2.currentText())
    	_res3 = str(self.cb_res3.currentText())
    	_res4 = str(self.cb_res4.currentText())
    	res1=_res1.split('_')
    	res2=_res2.split('_')
    	res3=_res3.split('_')
    	res4=_res4.split('_')
    	frame_time = self.sb_frame.value()
    	prot = parsePDB(self.TEMP_PATH+"/complex_" + str(frame_time) + ".pdb")
    	prot0 =  parsePDB(self.TEMP_PATH+"/complex_1.pdb")
    	if self.cb_tool.currentText() == "Pincer angle" or self.cb_tool.currentText() == "Triangle area":
    		selres = prot.select('resnum {0} {1} {2}'.format(res1[1], res2[1], res3[1]))
    		selres0 = prot0.select('resnum {0} {1} {2}'.format(res1[1], res2[1], res3[1]))
    	elif self.cb_tool.currentText() == "PDF" or self.cb_tool.currentText() == "RMSD" or self.cb_tool.currentText() == "RG" or self.cb_tool.currentText() == "FEL":
    		selres = None
    		selres0 = None
    	elif self.cb_tool.currentText() == "Dihedral angle":
    		selres = prot.select('resnum {0} {1} {2} {3}'.format(res1[1], res2[1], res3[1], res4[1]))
    		selres0 = prot0.select('resnum {0} {1} {2} {3}'.format(res1[1], res2[1], res3[1], res4[1]))

    	showProtein(prot0, prot, selres0, selres)   

def call_main():
    import sys
    app = QtWidgets.QApplication(sys.argv)
    icon = iconFromBase64(ICO)
    app.setWindowIcon(icon)
    app.setStyle('Fusion')
    palette = QPalette()
    palette.setColor(QPalette.Window, QColor(53, 53, 53))
    palette.setColor(QPalette.WindowText, Qt.white)
    palette.setColor(QPalette.Base, QColor(25, 25, 25))
    palette.setColor(QPalette.AlternateBase, QColor(53, 53, 53))
    palette.setColor(QPalette.ToolTipBase, Qt.white)
    palette.setColor(QPalette.ToolTipText, Qt.white)
    palette.setColor(QPalette.Text, Qt.white)
    palette.setColor(QPalette.Button, QColor(53, 53, 53))
    palette.setColor(QPalette.ButtonText, Qt.white)
    palette.setColor(QPalette.BrightText, Qt.red)
    palette.setColor(QPalette.Link, QColor(42, 130, 218))
    palette.setColor(QPalette.Highlight, QColor(42, 130, 218))
    palette.setColor(QPalette.HighlightedText, Qt.black)
    app.setPalette(palette)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    app.aboutToQuit.connect(ui.closeEvent)
    MainWindow.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
	call_main()