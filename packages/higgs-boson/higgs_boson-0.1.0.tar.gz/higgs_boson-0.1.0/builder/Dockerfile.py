# This file is part of Higgs Boson.
#
# Copyright (c) BitBoson
#
# Higgs Boson is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Higgs Boson is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Higgs Boson.  If not, see <https://www.gnu.org/licenses/>.
#
# Written by:
#     - Tyler Parcell <OriginLegend>
#

import os
import shutil
import subprocess
from builder import Utils


def build_docker_image(project_dir: str, docker_file_path: str,
                       cache_dir: str, docker_image_name: str) -> bool:
    """
    Function used to build the supplied docker image (by file-path)
    :param project_dir: String representing the project directory to initialize
    :param docker_file_path: String representing the dockerfile to use
    :param docker_image_name: String representing the docker image name
    :param cache_dir: String representing the project cache directory to use
    :return: Boolean indicating whether the process was successful or not
    """

    # Create a return flag
    ret_flag = False

    # Normalize the project directory and dockerfile paths
    cache_dir = os.path.normpath(cache_dir)
    project_dir = os.path.normpath(project_dir)
    docker_file_path = os.path.normpath(docker_file_path)

    # Indicate that we are building the docker image
    Utils.tprint('Setting-Up Higgs Builder Docker Image ... ')

    # Setup the reference to the existing docker ignore file
    docker_ignore_path = os.path.join(project_dir, '.dockerignore')

    # Hand the case where the docker ignore file already exists
    backed_up_docker_ignore = None
    original_docker_ignore_contents = None
    if os.path.isfile(docker_ignore_path):

        # Copy the existing docker ignore file to a safe spot
        backed_up_docker_ignore = os.path.join(project_dir, cache_dir,
                                               '.dockerignore')
        shutil.copyfile(docker_ignore_path, backed_up_docker_ignore)

        # Read in the original docker ignore file's contents so that we can
        # merge them with the new docker ignore file
        original_docker_ignore_contents = []
        with open(backed_up_docker_ignore) as original_docker_ignore:
            original_docker_ignore_contents.append(
                original_docker_ignore.readline())

    # Write the temporary docker ignore file to the project directory
    with open(docker_ignore_path, 'w') as docker_ignore:

        # Even though this file should be deleted, write the auto-generated
        # header information so that people know not to mess with it
        docker_ignore.write('# THIS IS AN AUTOGENERATED FILE USING HIGGS\n')
        docker_ignore.write('# DO NOT EDIT (UNLESS YOU KNOW WHAT\'S UP)\n')
        docker_ignore.write('\n')

        # Write in any existing docker ignore file contents
        if original_docker_ignore_contents is not None:
            for original_ignore_line in original_docker_ignore_contents:
                docker_ignore.write(original_ignore_line)

        # Add in some spacing before our auto-generated content
        docker_ignore.write('\n\n')

        # Add in the Higgs path into the docker ignore file
        # But then add in the exception for the higgs installation
        docker_ignore.write(os.path.join(cache_dir, 'build') + '\n')
        docker_ignore.write(os.path.join(cache_dir, 'external') + '\n')
        docker_ignore.write(os.path.join(cache_dir, 'peru') + '\n')

    # Call the docker build process using the specified dockerfile
    error_msg = None
    try:
        subprocess.check_output(['docker', 'build',
                                 '-t', str(docker_image_name),
                                 '-f', docker_file_path, project_dir],
                                stderr=error_msg)
        ret_flag = True
    except Exception:
        Utils.tprint('\n' + str(error_msg), newline=True)

    # Indicate the status/result of the operation
    if ret_flag:
        Utils.tprint(Utils.Constants.LOG_OK, newline=True)
    else:
        Utils.tprint(Utils.Constants.LOG_FAIL, newline=True)

    # Copy-back the original docker ignore file (if it was present)
    os.remove(docker_ignore_path)
    if backed_up_docker_ignore is not None:
        shutil.copyfile(backed_up_docker_ignore, docker_ignore_path)

    # Return the return flag
    return ret_flag


def execute_docker_image_command(docker_image_name: str, command: str) -> bool:
    """
    Function used to execute the given command on the specified docker image
    :param docker_image_name: String representing the docker image name
    :param command: String representing the command (and arguments) to execute
                    on the given docker image
    :return: Boolean indicating whether the process was successful or not
    """

    # Create a return flag
    ret_flag = False

    # Get the current working directory
    current_working_directory = os.getcwd()

    # Call the docker build process using the specified dockerfile
    error_msg = None
    try:
        process = subprocess.Popen(['docker', 'run', '--rm', '-w', '/app',
                                    '-v',
                                    ':'.join([current_working_directory,
                                              '/app']),
                                    '-t', docker_image_name]
                                   + command.split(' '),
                                   stdout=subprocess.PIPE,
                                   stderr=error_msg)
        for c in iter(lambda: process.stdout.read(1), b''):
            Utils.tprint(c.decode())
        ret_flag = True
    except Exception:
        Utils.tprint('\n' + str(error_msg), newline=True)

    # Return the return flag
    return ret_flag
