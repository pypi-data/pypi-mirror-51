################################################################################
#          This file was automatically generated. Please do not edit.          #
################################################################################

import javawrappers.java.lang
import javawrappers.java.util
import javawrappers.java.math

from jpype.types import *
from typing import Union

from typing import overload

class BigInteger:
	@overload
	def __init__(self, arg0: Union[int, JInt], arg1: javawrappers.java.util.Random, ): ...
	@overload
	def __init__(self, arg0: javawrappers.java.lang.String, ): ...
	@overload
	def __init__(self, arg0: JArray(JByte, 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ): ...
	@overload
	def __init__(self, arg0: Union[int, JInt], arg1: Union[int, JInt], arg2: javawrappers.java.util.Random, ): ...
	@overload
	def __init__(self, arg0: Union[int, JInt], arg1: JArray(JByte, 1), arg2: Union[int, JInt], arg3: Union[int, JInt], ): ...
	@overload
	def __init__(self, arg0: JArray(JByte, 1), ): ...
	@overload
	def __init__(self, arg0: Union[int, JInt], arg1: JArray(JByte, 1), ): ...
	@overload
	def __init__(self, arg0: javawrappers.java.lang.String, arg1: Union[int, JInt], ): ...
	class UnsafeHolder:
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def notify(self, ) -> None: ...


	def bitLength(self, ) -> Union[int, JInt]: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def getLowestSetBit(self, ) -> Union[int, JInt]: ...
	def mod(self, arg0: javawrappers.java.math.BigInteger, ) -> javawrappers.java.math.BigInteger: ...
	def byteValueExact(self, ) -> JByte: ...
	def gcd(self, arg0: javawrappers.java.math.BigInteger, ) -> javawrappers.java.math.BigInteger: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.math.BigInteger, ) -> Union[int, JInt]: ...
	def sqrtAndRemainder(self, ) -> JArray(javawrappers.java.math.BigInteger, 1): ...
	def shiftLeft(self, arg0: Union[int, JInt], ) -> javawrappers.java.math.BigInteger: ...
	def sqrt(self, ) -> javawrappers.java.math.BigInteger: ...
	def shortValue(self, ) -> Union[int, JShort]: ...
	def clearBit(self, arg0: Union[int, JInt], ) -> javawrappers.java.math.BigInteger: ...
	def signum(self, ) -> Union[int, JInt]: ...
	def add(self, arg0: javawrappers.java.math.BigInteger, ) -> javawrappers.java.math.BigInteger: ...
	def subtract(self, arg0: javawrappers.java.math.BigInteger, ) -> javawrappers.java.math.BigInteger: ...
	def floatValue(self, ) -> Union[float, JFloat]: ...
	def doubleValue(self, ) -> Union[float, JDouble]: ...
	def isProbablePrime(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	def nextProbablePrime(self, ) -> javawrappers.java.math.BigInteger: ...
	def testBit(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	def shiftRight(self, arg0: Union[int, JInt], ) -> javawrappers.java.math.BigInteger: ...
	def divideAndRemainder(self, arg0: javawrappers.java.math.BigInteger, ) -> JArray(javawrappers.java.math.BigInteger, 1): ...
	def modPow(self, arg0: javawrappers.java.math.BigInteger, arg1: javawrappers.java.math.BigInteger, ) -> javawrappers.java.math.BigInteger: ...
	def andNot(self, arg0: javawrappers.java.math.BigInteger, ) -> javawrappers.java.math.BigInteger: ...
	def intValueExact(self, ) -> Union[int, JInt]: ...
	def modInverse(self, arg0: javawrappers.java.math.BigInteger, ) -> javawrappers.java.math.BigInteger: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def longValueExact(self, ) -> Union[long, JLong]: ...
	def notifyAll(self, ) -> None: ...
	def setBit(self, arg0: Union[int, JInt], ) -> javawrappers.java.math.BigInteger: ...
	def shortValueExact(self, ) -> Union[int, JShort]: ...
	def notify(self, ) -> None: ...
	def longValue(self, ) -> Union[long, JLong]: ...
	def not_(self, ) -> javawrappers.java.math.BigInteger: ...
	def min(self, arg0: javawrappers.java.math.BigInteger, ) -> javawrappers.java.math.BigInteger: ...
	@overload
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def hashCode(self, ) -> Union[int, JInt]: ...
	def and(self, arg0: javawrappers.java.math.BigInteger, ) -> javawrappers.java.math.BigInteger: ...
	def pow(self, arg0: Union[int, JInt], ) -> javawrappers.java.math.BigInteger: ...
	def divide(self, arg0: javawrappers.java.math.BigInteger, ) -> javawrappers.java.math.BigInteger: ...
	def xor(self, arg0: javawrappers.java.math.BigInteger, ) -> javawrappers.java.math.BigInteger: ...
	def multiply(self, arg0: javawrappers.java.math.BigInteger, ) -> javawrappers.java.math.BigInteger: ...
	def flipBit(self, arg0: Union[int, JInt], ) -> javawrappers.java.math.BigInteger: ...
	def or_(self, arg0: javawrappers.java.math.BigInteger, ) -> javawrappers.java.math.BigInteger: ...
	def max(self, arg0: javawrappers.java.math.BigInteger, ) -> javawrappers.java.math.BigInteger: ...
	@staticmethod
	def valueOf(arg0: Union[long, JLong], ) -> javawrappers.java.math.BigInteger: ...
	def intValue(self, ) -> Union[int, JInt]: ...
	def abs(self, ) -> javawrappers.java.math.BigInteger: ...
	def negate(self, ) -> javawrappers.java.math.BigInteger: ...
	def toByteArray(self, ) -> JArray(JByte, 1): ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def toString(self, arg0: Union[int, JInt], ) -> javawrappers.java.lang.String: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def bitCount(self, ) -> Union[int, JInt]: ...
	def remainder(self, arg0: javawrappers.java.math.BigInteger, ) -> javawrappers.java.math.BigInteger: ...
	@staticmethod
	def probablePrime(arg0: Union[int, JInt], arg1: javawrappers.java.util.Random, ) -> javawrappers.java.math.BigInteger: ...
	def byteValue(self, ) -> JByte: ...


class BigDecimal:
	@overload
	def __init__(self, arg0: Union[long, JLong], arg1: javawrappers.java.math.MathContext, ): ...
	@overload
	def __init__(self, arg0: javawrappers.java.math.BigInteger, arg1: javawrappers.java.math.MathContext, ): ...
	@overload
	def __init__(self, arg0: javawrappers.java.math.BigInteger, ): ...
	@overload
	def __init__(self, arg0: Union[float, JDouble], arg1: javawrappers.java.math.MathContext, ): ...
	@overload
	def __init__(self, arg0: Union[float, JDouble], ): ...
	@overload
	def __init__(self, arg0: Union[long, JLong], ): ...
	@overload
	def __init__(self, arg0: Union[int, JInt], arg1: javawrappers.java.math.MathContext, ): ...
	@overload
	def __init__(self, arg0: Union[int, JInt], ): ...
	@overload
	def __init__(self, arg0: javawrappers.java.math.BigInteger, arg1: Union[int, JInt], arg2: javawrappers.java.math.MathContext, ): ...
	@overload
	def __init__(self, arg0: JArray(Union[string, JString], 1), arg1: Union[int, JInt], arg2: Union[int, JInt], arg3: javawrappers.java.math.MathContext, ): ...
	@overload
	def __init__(self, arg0: JArray(Union[string, JString], 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ): ...
	@overload
	def __init__(self, arg0: javawrappers.java.math.BigInteger, arg1: Union[int, JInt], ): ...
	@overload
	def __init__(self, arg0: javawrappers.java.lang.String, arg1: javawrappers.java.math.MathContext, ): ...
	@overload
	def __init__(self, arg0: javawrappers.java.lang.String, ): ...
	@overload
	def __init__(self, arg0: JArray(Union[string, JString], 1), arg1: javawrappers.java.math.MathContext, ): ...
	@overload
	def __init__(self, arg0: JArray(Union[string, JString], 1), ): ...
	class UnsafeHolder:
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def notify(self, ) -> None: ...


	class StringBuilderHelper:
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def notify(self, ) -> None: ...


	class LongOverflow:
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		@staticmethod
		def check(arg0: javawrappers.java.math.BigDecimal, ) -> None: ...
		def notify(self, ) -> None: ...


	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def movePointLeft(self, arg0: Union[int, JInt], ) -> javawrappers.java.math.BigDecimal: ...
	def precision(self, ) -> Union[int, JInt]: ...
	def byteValueExact(self, ) -> JByte: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.math.BigDecimal, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	def sqrt(self, arg0: javawrappers.java.math.MathContext, ) -> javawrappers.java.math.BigDecimal: ...
	def shortValue(self, ) -> Union[int, JShort]: ...
	def signum(self, ) -> Union[int, JInt]: ...
	@overload
	def add(self, arg0: javawrappers.java.math.BigDecimal, ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	def add(self, arg0: javawrappers.java.math.BigDecimal, arg1: javawrappers.java.math.MathContext, ) -> javawrappers.java.math.BigDecimal: ...
	def toBigIntegerExact(self, ) -> javawrappers.java.math.BigInteger: ...
	@overload
	def setScale(self, arg0: Union[int, JInt], arg1: javawrappers.java.math.RoundingMode, ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	def setScale(self, arg0: Union[int, JInt], ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	def setScale(self, arg0: Union[int, JInt], arg1: Union[int, JInt], ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	def subtract(self, arg0: javawrappers.java.math.BigDecimal, ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	def subtract(self, arg0: javawrappers.java.math.BigDecimal, arg1: javawrappers.java.math.MathContext, ) -> javawrappers.java.math.BigDecimal: ...
	def floatValue(self, ) -> Union[float, JFloat]: ...
	@staticmethod
	def check(arg0: javawrappers.java.math.BigDecimal, ) -> None: ...
	def doubleValue(self, ) -> Union[float, JDouble]: ...
	@overload
	def divideToIntegralValue(self, arg0: javawrappers.java.math.BigDecimal, ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	def divideToIntegralValue(self, arg0: javawrappers.java.math.BigDecimal, arg1: javawrappers.java.math.MathContext, ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	def plus(self, arg0: javawrappers.java.math.MathContext, ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	def plus(self, ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	def divideAndRemainder(self, arg0: javawrappers.java.math.BigDecimal, arg1: javawrappers.java.math.MathContext, ) -> JArray(javawrappers.java.math.BigDecimal, 1): ...
	@overload
	def divideAndRemainder(self, arg0: javawrappers.java.math.BigDecimal, ) -> JArray(javawrappers.java.math.BigDecimal, 1): ...
	def ulp(self, ) -> javawrappers.java.math.BigDecimal: ...
	def stripTrailingZeros(self, ) -> javawrappers.java.math.BigDecimal: ...
	def intValueExact(self, ) -> Union[int, JInt]: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def longValueExact(self, ) -> Union[long, JLong]: ...
	def notifyAll(self, ) -> None: ...
	def scale(self, ) -> Union[int, JInt]: ...
	def toBigInteger(self, ) -> javawrappers.java.math.BigInteger: ...
	def toPlainString(self, ) -> javawrappers.java.lang.String: ...
	def shortValueExact(self, ) -> Union[int, JShort]: ...
	def notify(self, ) -> None: ...
	def longValue(self, ) -> Union[long, JLong]: ...
	def min(self, arg0: javawrappers.java.math.BigDecimal, ) -> javawrappers.java.math.BigDecimal: ...
	def unscaledValue(self, ) -> javawrappers.java.math.BigInteger: ...
	@overload
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def hashCode(self, ) -> Union[int, JInt]: ...
	def scaleByPowerOfTen(self, arg0: Union[int, JInt], ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	def pow(self, arg0: Union[int, JInt], arg1: javawrappers.java.math.MathContext, ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	def pow(self, arg0: Union[int, JInt], ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	def divide(self, arg0: javawrappers.java.math.BigDecimal, arg1: javawrappers.java.math.MathContext, ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	def divide(self, arg0: javawrappers.java.math.BigDecimal, ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	def divide(self, arg0: javawrappers.java.math.BigDecimal, arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	def divide(self, arg0: javawrappers.java.math.BigDecimal, arg1: Union[int, JInt], arg2: javawrappers.java.math.RoundingMode, ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	def divide(self, arg0: javawrappers.java.math.BigDecimal, arg1: Union[int, JInt], ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	def divide(self, arg0: javawrappers.java.math.BigDecimal, arg1: javawrappers.java.math.RoundingMode, ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	def multiply(self, arg0: javawrappers.java.math.BigDecimal, arg1: javawrappers.java.math.MathContext, ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	def multiply(self, arg0: javawrappers.java.math.BigDecimal, ) -> javawrappers.java.math.BigDecimal: ...
	def toEngineeringString(self, ) -> javawrappers.java.lang.String: ...
	def max(self, arg0: javawrappers.java.math.BigDecimal, ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	@staticmethod
	def valueOf(arg0: Union[long, JLong], ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	@staticmethod
	def valueOf(arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	@staticmethod
	def valueOf(arg0: Union[float, JDouble], ) -> javawrappers.java.math.BigDecimal: ...
	def intValue(self, ) -> Union[int, JInt]: ...
	@overload
	def abs(self, arg0: javawrappers.java.math.MathContext, ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	def abs(self, ) -> javawrappers.java.math.BigDecimal: ...
	def round(self, arg0: javawrappers.java.math.MathContext, ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	def negate(self, ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	def negate(self, arg0: javawrappers.java.math.MathContext, ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def movePointRight(self, arg0: Union[int, JInt], ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def remainder(self, arg0: javawrappers.java.math.BigDecimal, ) -> javawrappers.java.math.BigDecimal: ...
	@overload
	def remainder(self, arg0: javawrappers.java.math.BigDecimal, arg1: javawrappers.java.math.MathContext, ) -> javawrappers.java.math.BigDecimal: ...
	def byteValue(self, ) -> JByte: ...


class RoundingMode:
	UP: RoundingMode = ...
	DOWN: RoundingMode = ...
	CEILING: RoundingMode = ...
	FLOOR: RoundingMode = ...
	HALF_UP: RoundingMode = ...
	HALF_DOWN: RoundingMode = ...
	HALF_EVEN: RoundingMode = ...
	UNNECESSARY: RoundingMode = ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def getDeclaringClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	@staticmethod
	def valueOf(arg0: javawrappers.java.lang.Class, arg1: javawrappers.java.lang.String, ) -> javawrappers.java.lang.Enum: ...
	@overload
	@staticmethod
	def valueOf(arg0: Union[int, JInt], ) -> javawrappers.java.math.RoundingMode: ...
	@overload
	@staticmethod
	def valueOf(arg0: javawrappers.java.lang.String, ) -> javawrappers.java.math.RoundingMode: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@staticmethod
	def values() -> JArray(javawrappers.java.math.RoundingMode, 1): ...
	def name(self, ) -> javawrappers.java.lang.String: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Enum, ) -> Union[int, JInt]: ...
	def notify(self, ) -> None: ...
	def ordinal(self, ) -> Union[int, JInt]: ...


class MathContext:
	@overload
	def __init__(self, arg0: Union[int, JInt], ): ...
	@overload
	def __init__(self, arg0: javawrappers.java.lang.String, ): ...
	@overload
	def __init__(self, arg0: Union[int, JInt], arg1: javawrappers.java.math.RoundingMode, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def getRoundingMode(self, ) -> javawrappers.java.math.RoundingMode: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def notify(self, ) -> None: ...
	def getPrecision(self, ) -> Union[int, JInt]: ...


