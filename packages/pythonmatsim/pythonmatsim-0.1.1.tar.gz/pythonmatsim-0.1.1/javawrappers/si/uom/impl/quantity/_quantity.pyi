################################################################################
#          This file was automatically generated. Please do not edit.          #
################################################################################

import javawrappers.javax.measure
import javawrappers.java.lang
import javawrappers.si.uom.impl.quantity
import javawrappers.tec.uom.se
import javawrappers.java.math

from jpype.types import *
from typing import Union

from typing import overload

class MassAmount:
	def __init__(self, arg0: javawrappers.java.lang.Number, arg1: javawrappers.javax.measure.Unit, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def notifyAll(self, ) -> None: ...
	def decimalValue(self, arg0: javawrappers.javax.measure.Unit, arg1: javawrappers.java.math.MathContext, ) -> javawrappers.java.math.BigDecimal: ...
	def isBig(self, ) -> Union[int, JBoolean]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JInt]: ...
	def notify(self, ) -> None: ...
	@overload
	def asType(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def asType(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def isEquivalentTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	def isGreaterThanOrEqualTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	@staticmethod
	def of(arg0: Union[float, JFloat], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: Union[float, JDouble], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: Union[int, JInt], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: Union[long, JLong], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: Union[int, JShort], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: JByte, arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	def divide(self, arg0: javawrappers.javax.measure.Quantity, arg1: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def divide(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def divide(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def divide(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def divide(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def multiply(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def multiply(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def multiply(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def multiply(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def multiply(self, arg0: javawrappers.javax.measure.Quantity, arg1: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def add(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def add(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def isLessThan(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	@overload
	def inverse(self, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def inverse(self, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def inverse(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def intValue(self, arg0: javawrappers.javax.measure.Unit, ) -> Union[int, JInt]: ...
	def toSI(self, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def subtract(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def subtract(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	def isGreaterThan(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	@staticmethod
	def parse(arg0: javawrappers.java.lang.CharSequence, ) -> javawrappers.javax.measure.Quantity: ...
	def doubleValue(self, arg0: javawrappers.javax.measure.Unit, ) -> Union[float, JDouble]: ...
	@overload
	def getValue(self, ) -> javawrappers.java.lang.Object: ...
	@overload
	def getValue(self, ) -> javawrappers.java.lang.Number: ...
	def isLessThanOrEqualTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.tec.uom.se.AbstractQuantity, arg1: Union[float, JDouble], arg2: javawrappers.javax.measure.Unit, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def to(self, arg0: javawrappers.javax.measure.Unit, arg1: javawrappers.java.math.MathContext, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def to(self, arg0: javawrappers.javax.measure.Unit, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def to(self, arg0: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def getUnit(self, ) -> javawrappers.javax.measure.Unit: ...


class AccelerationAmount:
	def __init__(self, arg0: javawrappers.java.lang.Number, arg1: javawrappers.javax.measure.Unit, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def notifyAll(self, ) -> None: ...
	def decimalValue(self, arg0: javawrappers.javax.measure.Unit, arg1: javawrappers.java.math.MathContext, ) -> javawrappers.java.math.BigDecimal: ...
	def isBig(self, ) -> Union[int, JBoolean]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JInt]: ...
	def notify(self, ) -> None: ...
	@overload
	def asType(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def asType(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def isEquivalentTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	def isGreaterThanOrEqualTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	@staticmethod
	def of(arg0: Union[float, JFloat], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: Union[float, JDouble], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: Union[int, JInt], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: Union[long, JLong], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: Union[int, JShort], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: JByte, arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: javawrappers.java.lang.Number, arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.si.uom.impl.quantity.AccelerationAmount: ...
	@overload
	def divide(self, arg0: javawrappers.javax.measure.Quantity, arg1: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def divide(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def divide(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def divide(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def divide(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def multiply(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def multiply(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def multiply(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def multiply(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def multiply(self, arg0: javawrappers.javax.measure.Quantity, arg1: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def add(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def add(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def isLessThan(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	@overload
	def inverse(self, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def inverse(self, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def inverse(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def intValue(self, arg0: javawrappers.javax.measure.Unit, ) -> Union[int, JInt]: ...
	def toSI(self, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def subtract(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def subtract(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	def isGreaterThan(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	@staticmethod
	def parse(arg0: javawrappers.java.lang.CharSequence, ) -> javawrappers.javax.measure.Quantity: ...
	def doubleValue(self, arg0: javawrappers.javax.measure.Unit, ) -> Union[float, JDouble]: ...
	@overload
	def getValue(self, ) -> javawrappers.java.lang.Object: ...
	@overload
	def getValue(self, ) -> javawrappers.java.lang.Number: ...
	def isLessThanOrEqualTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.tec.uom.se.AbstractQuantity, arg1: Union[float, JDouble], arg2: javawrappers.javax.measure.Unit, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def to(self, arg0: javawrappers.javax.measure.Unit, arg1: javawrappers.java.math.MathContext, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def to(self, arg0: javawrappers.javax.measure.Unit, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def to(self, arg0: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def getUnit(self, ) -> javawrappers.javax.measure.Unit: ...


class LengthAmount:
	def __init__(self, arg0: javawrappers.java.lang.Number, arg1: javawrappers.javax.measure.Unit, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def notifyAll(self, ) -> None: ...
	def decimalValue(self, arg0: javawrappers.javax.measure.Unit, arg1: javawrappers.java.math.MathContext, ) -> javawrappers.java.math.BigDecimal: ...
	def isBig(self, ) -> Union[int, JBoolean]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JInt]: ...
	def notify(self, ) -> None: ...
	@overload
	def asType(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def asType(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def isEquivalentTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	def isGreaterThanOrEqualTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	@staticmethod
	def of(arg0: Union[float, JFloat], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: Union[float, JDouble], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: Union[int, JInt], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: Union[long, JLong], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: Union[int, JShort], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: JByte, arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	def divide(self, arg0: javawrappers.javax.measure.Quantity, arg1: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def divide(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def divide(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def divide(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def divide(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def multiply(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def multiply(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def multiply(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def multiply(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def multiply(self, arg0: javawrappers.javax.measure.Quantity, arg1: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def add(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def add(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def isLessThan(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	@overload
	def inverse(self, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def inverse(self, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def inverse(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def intValue(self, arg0: javawrappers.javax.measure.Unit, ) -> Union[int, JInt]: ...
	def toSI(self, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def subtract(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def subtract(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	def isGreaterThan(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	@staticmethod
	def parse(arg0: javawrappers.java.lang.CharSequence, ) -> javawrappers.javax.measure.Quantity: ...
	def doubleValue(self, arg0: javawrappers.javax.measure.Unit, ) -> Union[float, JDouble]: ...
	@overload
	def getValue(self, ) -> javawrappers.java.lang.Object: ...
	@overload
	def getValue(self, ) -> javawrappers.java.lang.Number: ...
	def isLessThanOrEqualTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.tec.uom.se.AbstractQuantity, arg1: Union[float, JDouble], arg2: javawrappers.javax.measure.Unit, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def to(self, arg0: javawrappers.javax.measure.Unit, arg1: javawrappers.java.math.MathContext, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def to(self, arg0: javawrappers.javax.measure.Unit, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def to(self, arg0: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def getUnit(self, ) -> javawrappers.javax.measure.Unit: ...


class TemperatureAmount:
	def __init__(self, arg0: javawrappers.java.lang.Number, arg1: javawrappers.javax.measure.Unit, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def notifyAll(self, ) -> None: ...
	def decimalValue(self, arg0: javawrappers.javax.measure.Unit, arg1: javawrappers.java.math.MathContext, ) -> javawrappers.java.math.BigDecimal: ...
	def lt(self, arg0: javawrappers.si.uom.impl.quantity.TemperatureAmount, ) -> Union[int, JBoolean]: ...
	def isBig(self, ) -> Union[int, JBoolean]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JInt]: ...
	def notify(self, ) -> None: ...
	@overload
	def asType(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def asType(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def isEquivalentTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	def isGreaterThanOrEqualTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	@staticmethod
	def of(arg0: Union[float, JFloat], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: Union[float, JDouble], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: Union[int, JInt], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: Union[long, JLong], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: Union[int, JShort], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: JByte, arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	def getScalar(self, ) -> javawrappers.java.lang.Double: ...
	def isZero(self, ) -> Union[int, JBoolean]: ...
	@overload
	def divide(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def divide(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def divide(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.si.uom.impl.quantity.TemperatureAmount: ...
	@overload
	def divide(self, arg0: javawrappers.java.lang.Double, ) -> javawrappers.si.uom.impl.quantity.TemperatureAmount: ...
	@overload
	def divide(self, arg0: javawrappers.javax.measure.Quantity, arg1: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def divide(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def divide(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def multiply(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.si.uom.impl.quantity.TemperatureAmount: ...
	@overload
	def multiply(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def multiply(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def multiply(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def multiply(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def multiply(self, arg0: javawrappers.javax.measure.Quantity, arg1: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def ge(self, arg0: javawrappers.si.uom.impl.quantity.TemperatureAmount, ) -> Union[int, JBoolean]: ...
	@overload
	def add(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def add(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def add(self, arg0: javawrappers.si.uom.impl.quantity.TemperatureAmount, ) -> javawrappers.si.uom.impl.quantity.TemperatureAmount: ...
	def isLessThan(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	@overload
	def inverse(self, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def inverse(self, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def inverse(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def intValue(self, arg0: javawrappers.javax.measure.Unit, ) -> Union[int, JInt]: ...
	def toSI(self, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def subtract(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def subtract(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def subtract(self, arg0: javawrappers.si.uom.impl.quantity.TemperatureAmount, ) -> javawrappers.si.uom.impl.quantity.TemperatureAmount: ...
	def isGreaterThan(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	@staticmethod
	def parse(arg0: javawrappers.java.lang.CharSequence, ) -> javawrappers.javax.measure.Quantity: ...
	def doubleValue(self, arg0: javawrappers.javax.measure.Unit, ) -> Union[float, JDouble]: ...
	@overload
	def getValue(self, ) -> javawrappers.java.lang.Object: ...
	@overload
	def getValue(self, ) -> javawrappers.java.lang.Number: ...
	def isLessThanOrEqualTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.tec.uom.se.AbstractQuantity, arg1: Union[float, JDouble], arg2: javawrappers.javax.measure.Unit, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def le(self, arg0: javawrappers.si.uom.impl.quantity.TemperatureAmount, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def to(self, arg0: javawrappers.javax.measure.Unit, arg1: javawrappers.java.math.MathContext, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def to(self, arg0: javawrappers.javax.measure.Unit, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def to(self, arg0: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def getUnit(self, ) -> javawrappers.javax.measure.Unit: ...


class ForceAmount:
	@overload
	def __init__(self, arg0: javawrappers.java.lang.Number, arg1: javawrappers.javax.measure.Unit, ): ...
	@overload
	def __init__(self, arg0: Union[float, JDouble], arg1: javawrappers.javax.measure.Unit, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def notifyAll(self, ) -> None: ...
	def decimalValue(self, arg0: javawrappers.javax.measure.Unit, arg1: javawrappers.java.math.MathContext, ) -> javawrappers.java.math.BigDecimal: ...
	def isBig(self, ) -> Union[int, JBoolean]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JInt]: ...
	def notify(self, ) -> None: ...
	@overload
	def asType(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def asType(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def isEquivalentTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	def isGreaterThanOrEqualTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	@staticmethod
	def of(arg0: Union[float, JFloat], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: Union[float, JDouble], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: Union[int, JInt], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: Union[long, JLong], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: Union[int, JShort], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: JByte, arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	def divide(self, arg0: javawrappers.javax.measure.Quantity, arg1: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def divide(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def divide(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def divide(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def divide(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def multiply(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def multiply(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def multiply(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def multiply(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def multiply(self, arg0: javawrappers.javax.measure.Quantity, arg1: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def add(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def add(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def isLessThan(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	@overload
	def inverse(self, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def inverse(self, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def inverse(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def intValue(self, arg0: javawrappers.javax.measure.Unit, ) -> Union[int, JInt]: ...
	def toSI(self, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def subtract(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def subtract(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	def isGreaterThan(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	@staticmethod
	def parse(arg0: javawrappers.java.lang.CharSequence, ) -> javawrappers.javax.measure.Quantity: ...
	def doubleValue(self, arg0: javawrappers.javax.measure.Unit, ) -> Union[float, JDouble]: ...
	@overload
	def getValue(self, ) -> javawrappers.java.lang.Object: ...
	@overload
	def getValue(self, ) -> javawrappers.java.lang.Number: ...
	def isLessThanOrEqualTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.tec.uom.se.AbstractQuantity, arg1: Union[float, JDouble], arg2: javawrappers.javax.measure.Unit, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def to(self, arg0: javawrappers.javax.measure.Unit, arg1: javawrappers.java.math.MathContext, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def to(self, arg0: javawrappers.javax.measure.Unit, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def to(self, arg0: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def getUnit(self, ) -> javawrappers.javax.measure.Unit: ...


