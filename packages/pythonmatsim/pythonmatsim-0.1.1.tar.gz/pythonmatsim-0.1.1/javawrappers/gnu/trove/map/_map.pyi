################################################################################
#          This file was automatically generated. Please do not edit.          #
################################################################################

import javawrappers.java.util
import javawrappers.java.lang
import javawrappers.gnu.trove.function
import javawrappers.gnu.trove.set
import javawrappers.gnu.trove.procedure
import javawrappers.gnu.trove
import javawrappers.java.util.function
import javawrappers.gnu.trove.map
import javawrappers.gnu.trove.iterator

from jpype.types import *
from typing import Union

from typing import overload

class TLongShortMap:
	def getNoEntryValue(self, ) -> Union[int, JShort]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TLongShortProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[long, JLong], arg1: Union[int, JShort], arg2: Union[int, JShort], ) -> Union[int, JShort]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TShortFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[long, JLong], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[long, JLong], 1), ) -> JArray(Union[long, JLong], 1): ...
	def containsKey(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[int, JShort], 1), ) -> JArray(Union[int, JShort], 1): ...
	@overload
	def values(self, ) -> JArray(Union[int, JShort], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TShortCollection: ...
	def containsValue(self, arg0: Union[int, JShort], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[long, JLong], arg1: Union[int, JShort], ) -> Union[int, JShort]: ...
	def remove(self, arg0: Union[long, JLong], ) -> Union[int, JShort]: ...
	def getNoEntryKey(self, ) -> Union[long, JLong]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TLongShortIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TShortProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TLongShortMap, ) -> None: ...
	def get(self, arg0: Union[long, JLong], ) -> Union[int, JShort]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TLongProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TLongShortProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TLongSet: ...
	def putIfAbsent(self, arg0: Union[long, JLong], arg1: Union[int, JShort], ) -> Union[int, JShort]: ...
	def adjustValue(self, arg0: Union[long, JLong], arg1: Union[int, JShort], ) -> Union[int, JBoolean]: ...


class TByteIntMap:
	def getNoEntryValue(self, ) -> Union[int, JInt]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TByteIntProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: JByte, arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> Union[int, JInt]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TIntFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(JByte, 1): ...
	@overload
	def keys(self, arg0: JArray(JByte, 1), ) -> JArray(JByte, 1): ...
	def containsKey(self, arg0: JByte, ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[int, JInt], 1), ) -> JArray(Union[int, JInt], 1): ...
	@overload
	def values(self, ) -> JArray(Union[int, JInt], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: JByte, ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TIntCollection: ...
	def containsValue(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: JByte, arg1: Union[int, JInt], ) -> Union[int, JInt]: ...
	def remove(self, arg0: JByte, ) -> Union[int, JInt]: ...
	def getNoEntryKey(self, ) -> JByte: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TByteIntIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TIntProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TByteIntMap, ) -> None: ...
	def get(self, arg0: JByte, ) -> Union[int, JInt]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TByteProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TByteIntProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TByteSet: ...
	def putIfAbsent(self, arg0: JByte, arg1: Union[int, JInt], ) -> Union[int, JInt]: ...
	def adjustValue(self, arg0: JByte, arg1: Union[int, JInt], ) -> Union[int, JBoolean]: ...


class TFloatObjectMap:
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TFloatObjectProcedure, ) -> Union[int, JBoolean]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TObjectFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[float, JFloat], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[float, JFloat], 1), ) -> JArray(Union[float, JFloat], 1): ...
	def containsKey(self, arg0: Union[float, JFloat], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(javawrappers.java.lang.Object, 1), ) -> JArray(javawrappers.java.lang.Object, 1): ...
	@overload
	def values(self, ) -> JArray(javawrappers.java.lang.Object, 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def valueCollection(self, ) -> javawrappers.java.util.Collection: ...
	def containsValue(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[float, JFloat], arg1: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...
	def remove(self, arg0: Union[float, JFloat], ) -> javawrappers.java.lang.Object: ...
	def getNoEntryKey(self, ) -> Union[float, JFloat]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TFloatObjectIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TObjectProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TFloatObjectMap, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def get(self, arg0: Union[float, JFloat], ) -> javawrappers.java.lang.Object: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TFloatProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TFloatObjectProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TFloatSet: ...
	def putIfAbsent(self, arg0: Union[float, JFloat], arg1: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...


class TFloatIntMap:
	def getNoEntryValue(self, ) -> Union[int, JInt]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TFloatIntProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[float, JFloat], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> Union[int, JInt]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TIntFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[float, JFloat], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[float, JFloat], 1), ) -> JArray(Union[float, JFloat], 1): ...
	def containsKey(self, arg0: Union[float, JFloat], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[int, JInt], 1), ) -> JArray(Union[int, JInt], 1): ...
	@overload
	def values(self, ) -> JArray(Union[int, JInt], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[float, JFloat], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TIntCollection: ...
	def containsValue(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[float, JFloat], arg1: Union[int, JInt], ) -> Union[int, JInt]: ...
	def remove(self, arg0: Union[float, JFloat], ) -> Union[int, JInt]: ...
	def getNoEntryKey(self, ) -> Union[float, JFloat]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TFloatIntIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TIntProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TFloatIntMap, ) -> None: ...
	def get(self, arg0: Union[float, JFloat], ) -> Union[int, JInt]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TFloatProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TFloatIntProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TFloatSet: ...
	def putIfAbsent(self, arg0: Union[float, JFloat], arg1: Union[int, JInt], ) -> Union[int, JInt]: ...
	def adjustValue(self, arg0: Union[float, JFloat], arg1: Union[int, JInt], ) -> Union[int, JBoolean]: ...


class TObjectFloatMap:
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TObjectFloatProcedure, ) -> Union[int, JBoolean]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TFloatFunction, ) -> None: ...
	@overload
	def keys(self, arg0: JArray(javawrappers.java.lang.Object, 1), ) -> JArray(javawrappers.java.lang.Object, 1): ...
	@overload
	def keys(self, ) -> JArray(javawrappers.java.lang.Object, 1): ...
	@overload
	def values(self, ) -> JArray(Union[float, JFloat], 1): ...
	@overload
	def values(self, arg0: JArray(Union[float, JFloat], 1), ) -> JArray(Union[float, JFloat], 1): ...
	def increment(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TFloatCollection: ...
	def containsValue(self, arg0: Union[float, JFloat], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: javawrappers.java.lang.Object, arg1: Union[float, JFloat], ) -> Union[float, JFloat]: ...
	def remove(self, arg0: javawrappers.java.lang.Object, ) -> Union[float, JFloat]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TObjectFloatIterator: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TObjectFloatMap, ) -> None: ...
	def get(self, arg0: javawrappers.java.lang.Object, ) -> Union[float, JFloat]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TObjectFloatProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.java.util.Set: ...
	def getNoEntryValue(self, ) -> Union[float, JFloat]: ...
	def adjustOrPutValue(self, arg0: javawrappers.java.lang.Object, arg1: Union[float, JFloat], arg2: Union[float, JFloat], ) -> Union[float, JFloat]: ...
	def containsKey(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TFloatProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TObjectProcedure, ) -> Union[int, JBoolean]: ...
	def putIfAbsent(self, arg0: javawrappers.java.lang.Object, arg1: Union[float, JFloat], ) -> Union[float, JFloat]: ...
	def adjustValue(self, arg0: javawrappers.java.lang.Object, arg1: Union[float, JFloat], ) -> Union[int, JBoolean]: ...


class TCharByteMap:
	def getNoEntryValue(self, ) -> JByte: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TCharByteProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[string, JString], arg1: JByte, arg2: JByte, ) -> JByte: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TByteFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[string, JString], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[string, JString], 1), ) -> JArray(Union[string, JString], 1): ...
	def containsKey(self, arg0: Union[string, JString], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(JByte, 1), ) -> JArray(JByte, 1): ...
	@overload
	def values(self, ) -> JArray(JByte, 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[string, JString], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TByteCollection: ...
	def containsValue(self, arg0: JByte, ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[string, JString], arg1: JByte, ) -> JByte: ...
	def remove(self, arg0: Union[string, JString], ) -> JByte: ...
	def getNoEntryKey(self, ) -> Union[string, JString]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TCharByteIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TByteProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TCharByteMap, ) -> None: ...
	def get(self, arg0: Union[string, JString], ) -> JByte: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TCharProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TCharByteProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TCharSet: ...
	def putIfAbsent(self, arg0: Union[string, JString], arg1: JByte, ) -> JByte: ...
	def adjustValue(self, arg0: Union[string, JString], arg1: JByte, ) -> Union[int, JBoolean]: ...


class TLongCharMap:
	def getNoEntryValue(self, ) -> Union[string, JString]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TLongCharProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[long, JLong], arg1: Union[string, JString], arg2: Union[string, JString], ) -> Union[string, JString]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TCharFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[long, JLong], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[long, JLong], 1), ) -> JArray(Union[long, JLong], 1): ...
	def containsKey(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[string, JString], 1), ) -> JArray(Union[string, JString], 1): ...
	@overload
	def values(self, ) -> JArray(Union[string, JString], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TCharCollection: ...
	def containsValue(self, arg0: Union[string, JString], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[long, JLong], arg1: Union[string, JString], ) -> Union[string, JString]: ...
	def remove(self, arg0: Union[long, JLong], ) -> Union[string, JString]: ...
	def getNoEntryKey(self, ) -> Union[long, JLong]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TLongCharIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TCharProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TLongCharMap, ) -> None: ...
	def get(self, arg0: Union[long, JLong], ) -> Union[string, JString]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TLongProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TLongCharProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TLongSet: ...
	def putIfAbsent(self, arg0: Union[long, JLong], arg1: Union[string, JString], ) -> Union[string, JString]: ...
	def adjustValue(self, arg0: Union[long, JLong], arg1: Union[string, JString], ) -> Union[int, JBoolean]: ...


class TIntObjectMap:
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TIntObjectProcedure, ) -> Union[int, JBoolean]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TObjectFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[int, JInt], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[int, JInt], 1), ) -> JArray(Union[int, JInt], 1): ...
	def containsKey(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(javawrappers.java.lang.Object, 1), ) -> JArray(javawrappers.java.lang.Object, 1): ...
	@overload
	def values(self, ) -> JArray(javawrappers.java.lang.Object, 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def valueCollection(self, ) -> javawrappers.java.util.Collection: ...
	def containsValue(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[int, JInt], arg1: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...
	def remove(self, arg0: Union[int, JInt], ) -> javawrappers.java.lang.Object: ...
	def getNoEntryKey(self, ) -> Union[int, JInt]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TIntObjectIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TObjectProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TIntObjectMap, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def get(self, arg0: Union[int, JInt], ) -> javawrappers.java.lang.Object: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TIntProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TIntObjectProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TIntSet: ...
	def putIfAbsent(self, arg0: Union[int, JInt], arg1: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...


class TIntDoubleMap:
	def getNoEntryValue(self, ) -> Union[float, JDouble]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TIntDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[int, JInt], arg1: Union[float, JDouble], arg2: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TDoubleFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[int, JInt], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[int, JInt], 1), ) -> JArray(Union[int, JInt], 1): ...
	def containsKey(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[float, JDouble], 1), ) -> JArray(Union[float, JDouble], 1): ...
	@overload
	def values(self, ) -> JArray(Union[float, JDouble], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TDoubleCollection: ...
	def containsValue(self, arg0: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[int, JInt], arg1: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def remove(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	def getNoEntryKey(self, ) -> Union[int, JInt]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TIntDoubleIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TIntDoubleMap, ) -> None: ...
	def get(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TIntProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TIntDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TIntSet: ...
	def putIfAbsent(self, arg0: Union[int, JInt], arg1: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def adjustValue(self, arg0: Union[int, JInt], arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...


class TDoubleIntMap:
	def getNoEntryValue(self, ) -> Union[int, JInt]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TDoubleIntProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> Union[int, JInt]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TIntFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[float, JDouble], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[float, JDouble], 1), ) -> JArray(Union[float, JDouble], 1): ...
	def containsKey(self, arg0: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[int, JInt], 1), ) -> JArray(Union[int, JInt], 1): ...
	@overload
	def values(self, ) -> JArray(Union[int, JInt], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TIntCollection: ...
	def containsValue(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], ) -> Union[int, JInt]: ...
	def remove(self, arg0: Union[float, JDouble], ) -> Union[int, JInt]: ...
	def getNoEntryKey(self, ) -> Union[float, JDouble]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TDoubleIntIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TIntProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TDoubleIntMap, ) -> None: ...
	def get(self, arg0: Union[float, JDouble], ) -> Union[int, JInt]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TDoubleIntProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TDoubleSet: ...
	def putIfAbsent(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], ) -> Union[int, JInt]: ...
	def adjustValue(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], ) -> Union[int, JBoolean]: ...


class TDoubleShortMap:
	def getNoEntryValue(self, ) -> Union[int, JShort]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TDoubleShortProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[float, JDouble], arg1: Union[int, JShort], arg2: Union[int, JShort], ) -> Union[int, JShort]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TShortFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[float, JDouble], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[float, JDouble], 1), ) -> JArray(Union[float, JDouble], 1): ...
	def containsKey(self, arg0: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[int, JShort], 1), ) -> JArray(Union[int, JShort], 1): ...
	@overload
	def values(self, ) -> JArray(Union[int, JShort], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TShortCollection: ...
	def containsValue(self, arg0: Union[int, JShort], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[float, JDouble], arg1: Union[int, JShort], ) -> Union[int, JShort]: ...
	def remove(self, arg0: Union[float, JDouble], ) -> Union[int, JShort]: ...
	def getNoEntryKey(self, ) -> Union[float, JDouble]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TDoubleShortIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TShortProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TDoubleShortMap, ) -> None: ...
	def get(self, arg0: Union[float, JDouble], ) -> Union[int, JShort]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TDoubleShortProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TDoubleSet: ...
	def putIfAbsent(self, arg0: Union[float, JDouble], arg1: Union[int, JShort], ) -> Union[int, JShort]: ...
	def adjustValue(self, arg0: Union[float, JDouble], arg1: Union[int, JShort], ) -> Union[int, JBoolean]: ...


class TIntShortMap:
	def getNoEntryValue(self, ) -> Union[int, JShort]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TIntShortProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[int, JInt], arg1: Union[int, JShort], arg2: Union[int, JShort], ) -> Union[int, JShort]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TShortFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[int, JInt], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[int, JInt], 1), ) -> JArray(Union[int, JInt], 1): ...
	def containsKey(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[int, JShort], 1), ) -> JArray(Union[int, JShort], 1): ...
	@overload
	def values(self, ) -> JArray(Union[int, JShort], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TShortCollection: ...
	def containsValue(self, arg0: Union[int, JShort], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[int, JInt], arg1: Union[int, JShort], ) -> Union[int, JShort]: ...
	def remove(self, arg0: Union[int, JInt], ) -> Union[int, JShort]: ...
	def getNoEntryKey(self, ) -> Union[int, JInt]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TIntShortIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TShortProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TIntShortMap, ) -> None: ...
	def get(self, arg0: Union[int, JInt], ) -> Union[int, JShort]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TIntProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TIntShortProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TIntSet: ...
	def putIfAbsent(self, arg0: Union[int, JInt], arg1: Union[int, JShort], ) -> Union[int, JShort]: ...
	def adjustValue(self, arg0: Union[int, JInt], arg1: Union[int, JShort], ) -> Union[int, JBoolean]: ...


class TFloatCharMap:
	def getNoEntryValue(self, ) -> Union[string, JString]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TFloatCharProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[float, JFloat], arg1: Union[string, JString], arg2: Union[string, JString], ) -> Union[string, JString]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TCharFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[float, JFloat], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[float, JFloat], 1), ) -> JArray(Union[float, JFloat], 1): ...
	def containsKey(self, arg0: Union[float, JFloat], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[string, JString], 1), ) -> JArray(Union[string, JString], 1): ...
	@overload
	def values(self, ) -> JArray(Union[string, JString], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[float, JFloat], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TCharCollection: ...
	def containsValue(self, arg0: Union[string, JString], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[float, JFloat], arg1: Union[string, JString], ) -> Union[string, JString]: ...
	def remove(self, arg0: Union[float, JFloat], ) -> Union[string, JString]: ...
	def getNoEntryKey(self, ) -> Union[float, JFloat]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TFloatCharIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TCharProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TFloatCharMap, ) -> None: ...
	def get(self, arg0: Union[float, JFloat], ) -> Union[string, JString]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TFloatProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TFloatCharProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TFloatSet: ...
	def putIfAbsent(self, arg0: Union[float, JFloat], arg1: Union[string, JString], ) -> Union[string, JString]: ...
	def adjustValue(self, arg0: Union[float, JFloat], arg1: Union[string, JString], ) -> Union[int, JBoolean]: ...


class TMap:
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TObjectObjectProcedure, ) -> Union[int, JBoolean]: ...
	def getOrDefault(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TObjectFunction, ) -> None: ...
	def computeIfAbsent(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.util.function.Function, ) -> javawrappers.java.lang.Object: ...
	def values(self, ) -> javawrappers.java.util.Collection: ...
	@overload
	def replace(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...
	@overload
	def replace(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Object, arg2: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def replaceAll(self, arg0: javawrappers.java.util.function.BiFunction, ) -> None: ...
	def containsValue(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def put(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...
	@overload
	def remove(self, arg0: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...
	@overload
	def remove(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def compute(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.util.function.BiFunction, ) -> javawrappers.java.lang.Object: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	def merge(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Object, arg2: javawrappers.java.util.function.BiFunction, ) -> javawrappers.java.lang.Object: ...
	def get(self, arg0: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TObjectObjectProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.java.util.Set: ...
	def entrySet(self, ) -> javawrappers.java.util.Set: ...
	def containsKey(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def forEach(self, arg0: javawrappers.java.util.function.BiConsumer, ) -> None: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def computeIfPresent(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.util.function.BiFunction, ) -> javawrappers.java.lang.Object: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TObjectProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TObjectProcedure, ) -> Union[int, JBoolean]: ...
	def putIfAbsent(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...


class TLongDoubleMap:
	def getNoEntryValue(self, ) -> Union[float, JDouble]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TLongDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[long, JLong], arg1: Union[float, JDouble], arg2: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TDoubleFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[long, JLong], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[long, JLong], 1), ) -> JArray(Union[long, JLong], 1): ...
	def containsKey(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[float, JDouble], 1), ) -> JArray(Union[float, JDouble], 1): ...
	@overload
	def values(self, ) -> JArray(Union[float, JDouble], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TDoubleCollection: ...
	def containsValue(self, arg0: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[long, JLong], arg1: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def remove(self, arg0: Union[long, JLong], ) -> Union[float, JDouble]: ...
	def getNoEntryKey(self, ) -> Union[long, JLong]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TLongDoubleIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TLongDoubleMap, ) -> None: ...
	def get(self, arg0: Union[long, JLong], ) -> Union[float, JDouble]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TLongProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TLongDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TLongSet: ...
	def putIfAbsent(self, arg0: Union[long, JLong], arg1: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def adjustValue(self, arg0: Union[long, JLong], arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...


class TCharShortMap:
	def getNoEntryValue(self, ) -> Union[int, JShort]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TCharShortProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[string, JString], arg1: Union[int, JShort], arg2: Union[int, JShort], ) -> Union[int, JShort]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TShortFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[string, JString], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[string, JString], 1), ) -> JArray(Union[string, JString], 1): ...
	def containsKey(self, arg0: Union[string, JString], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[int, JShort], 1), ) -> JArray(Union[int, JShort], 1): ...
	@overload
	def values(self, ) -> JArray(Union[int, JShort], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[string, JString], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TShortCollection: ...
	def containsValue(self, arg0: Union[int, JShort], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[string, JString], arg1: Union[int, JShort], ) -> Union[int, JShort]: ...
	def remove(self, arg0: Union[string, JString], ) -> Union[int, JShort]: ...
	def getNoEntryKey(self, ) -> Union[string, JString]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TCharShortIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TShortProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TCharShortMap, ) -> None: ...
	def get(self, arg0: Union[string, JString], ) -> Union[int, JShort]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TCharProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TCharShortProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TCharSet: ...
	def putIfAbsent(self, arg0: Union[string, JString], arg1: Union[int, JShort], ) -> Union[int, JShort]: ...
	def adjustValue(self, arg0: Union[string, JString], arg1: Union[int, JShort], ) -> Union[int, JBoolean]: ...


class TIntCharMap:
	def getNoEntryValue(self, ) -> Union[string, JString]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TIntCharProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[int, JInt], arg1: Union[string, JString], arg2: Union[string, JString], ) -> Union[string, JString]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TCharFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[int, JInt], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[int, JInt], 1), ) -> JArray(Union[int, JInt], 1): ...
	def containsKey(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[string, JString], 1), ) -> JArray(Union[string, JString], 1): ...
	@overload
	def values(self, ) -> JArray(Union[string, JString], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TCharCollection: ...
	def containsValue(self, arg0: Union[string, JString], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[int, JInt], arg1: Union[string, JString], ) -> Union[string, JString]: ...
	def remove(self, arg0: Union[int, JInt], ) -> Union[string, JString]: ...
	def getNoEntryKey(self, ) -> Union[int, JInt]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TIntCharIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TCharProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TIntCharMap, ) -> None: ...
	def get(self, arg0: Union[int, JInt], ) -> Union[string, JString]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TIntProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TIntCharProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TIntSet: ...
	def putIfAbsent(self, arg0: Union[int, JInt], arg1: Union[string, JString], ) -> Union[string, JString]: ...
	def adjustValue(self, arg0: Union[int, JInt], arg1: Union[string, JString], ) -> Union[int, JBoolean]: ...


class TLongLongMap:
	def getNoEntryValue(self, ) -> Union[long, JLong]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TLongLongProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[long, JLong], arg1: Union[long, JLong], arg2: Union[long, JLong], ) -> Union[long, JLong]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TLongFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[long, JLong], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[long, JLong], 1), ) -> JArray(Union[long, JLong], 1): ...
	def containsKey(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[long, JLong], 1), ) -> JArray(Union[long, JLong], 1): ...
	@overload
	def values(self, ) -> JArray(Union[long, JLong], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TLongCollection: ...
	def containsValue(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[long, JLong], arg1: Union[long, JLong], ) -> Union[long, JLong]: ...
	def remove(self, arg0: Union[long, JLong], ) -> Union[long, JLong]: ...
	def getNoEntryKey(self, ) -> Union[long, JLong]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TLongLongIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TLongProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TLongLongMap, ) -> None: ...
	def get(self, arg0: Union[long, JLong], ) -> Union[long, JLong]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TLongProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TLongLongProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TLongSet: ...
	def putIfAbsent(self, arg0: Union[long, JLong], arg1: Union[long, JLong], ) -> Union[long, JLong]: ...
	def adjustValue(self, arg0: Union[long, JLong], arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...


class TObjectIntMap:
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TObjectIntProcedure, ) -> Union[int, JBoolean]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TIntFunction, ) -> None: ...
	@overload
	def keys(self, arg0: JArray(javawrappers.java.lang.Object, 1), ) -> JArray(javawrappers.java.lang.Object, 1): ...
	@overload
	def keys(self, ) -> JArray(javawrappers.java.lang.Object, 1): ...
	@overload
	def values(self, ) -> JArray(Union[int, JInt], 1): ...
	@overload
	def values(self, arg0: JArray(Union[int, JInt], 1), ) -> JArray(Union[int, JInt], 1): ...
	def increment(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TIntCollection: ...
	def containsValue(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: javawrappers.java.lang.Object, arg1: Union[int, JInt], ) -> Union[int, JInt]: ...
	def remove(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TObjectIntIterator: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TObjectIntMap, ) -> None: ...
	def get(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TObjectIntProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.java.util.Set: ...
	def getNoEntryValue(self, ) -> Union[int, JInt]: ...
	def adjustOrPutValue(self, arg0: javawrappers.java.lang.Object, arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> Union[int, JInt]: ...
	def containsKey(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TIntProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TObjectProcedure, ) -> Union[int, JBoolean]: ...
	def putIfAbsent(self, arg0: javawrappers.java.lang.Object, arg1: Union[int, JInt], ) -> Union[int, JInt]: ...
	def adjustValue(self, arg0: javawrappers.java.lang.Object, arg1: Union[int, JInt], ) -> Union[int, JBoolean]: ...


class TFloatFloatMap:
	def getNoEntryValue(self, ) -> Union[float, JFloat]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TFloatFloatProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[float, JFloat], arg1: Union[float, JFloat], arg2: Union[float, JFloat], ) -> Union[float, JFloat]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TFloatFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[float, JFloat], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[float, JFloat], 1), ) -> JArray(Union[float, JFloat], 1): ...
	def containsKey(self, arg0: Union[float, JFloat], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[float, JFloat], 1), ) -> JArray(Union[float, JFloat], 1): ...
	@overload
	def values(self, ) -> JArray(Union[float, JFloat], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[float, JFloat], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TFloatCollection: ...
	def containsValue(self, arg0: Union[float, JFloat], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[float, JFloat], arg1: Union[float, JFloat], ) -> Union[float, JFloat]: ...
	def remove(self, arg0: Union[float, JFloat], ) -> Union[float, JFloat]: ...
	def getNoEntryKey(self, ) -> Union[float, JFloat]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TFloatFloatIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TFloatProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TFloatFloatMap, ) -> None: ...
	def get(self, arg0: Union[float, JFloat], ) -> Union[float, JFloat]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TFloatProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TFloatFloatProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TFloatSet: ...
	def putIfAbsent(self, arg0: Union[float, JFloat], arg1: Union[float, JFloat], ) -> Union[float, JFloat]: ...
	def adjustValue(self, arg0: Union[float, JFloat], arg1: Union[float, JFloat], ) -> Union[int, JBoolean]: ...


class TLongObjectMap:
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TLongObjectProcedure, ) -> Union[int, JBoolean]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TObjectFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[long, JLong], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[long, JLong], 1), ) -> JArray(Union[long, JLong], 1): ...
	def containsKey(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(javawrappers.java.lang.Object, 1), ) -> JArray(javawrappers.java.lang.Object, 1): ...
	@overload
	def values(self, ) -> JArray(javawrappers.java.lang.Object, 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def valueCollection(self, ) -> javawrappers.java.util.Collection: ...
	def containsValue(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[long, JLong], arg1: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...
	def remove(self, arg0: Union[long, JLong], ) -> javawrappers.java.lang.Object: ...
	def getNoEntryKey(self, ) -> Union[long, JLong]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TLongObjectIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TObjectProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TLongObjectMap, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def get(self, arg0: Union[long, JLong], ) -> javawrappers.java.lang.Object: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TLongProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TLongObjectProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TLongSet: ...
	def putIfAbsent(self, arg0: Union[long, JLong], arg1: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...


class TCharFloatMap:
	def getNoEntryValue(self, ) -> Union[float, JFloat]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TCharFloatProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[string, JString], arg1: Union[float, JFloat], arg2: Union[float, JFloat], ) -> Union[float, JFloat]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TFloatFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[string, JString], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[string, JString], 1), ) -> JArray(Union[string, JString], 1): ...
	def containsKey(self, arg0: Union[string, JString], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[float, JFloat], 1), ) -> JArray(Union[float, JFloat], 1): ...
	@overload
	def values(self, ) -> JArray(Union[float, JFloat], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[string, JString], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TFloatCollection: ...
	def containsValue(self, arg0: Union[float, JFloat], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[string, JString], arg1: Union[float, JFloat], ) -> Union[float, JFloat]: ...
	def remove(self, arg0: Union[string, JString], ) -> Union[float, JFloat]: ...
	def getNoEntryKey(self, ) -> Union[string, JString]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TCharFloatIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TFloatProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TCharFloatMap, ) -> None: ...
	def get(self, arg0: Union[string, JString], ) -> Union[float, JFloat]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TCharProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TCharFloatProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TCharSet: ...
	def putIfAbsent(self, arg0: Union[string, JString], arg1: Union[float, JFloat], ) -> Union[float, JFloat]: ...
	def adjustValue(self, arg0: Union[string, JString], arg1: Union[float, JFloat], ) -> Union[int, JBoolean]: ...


class TIntByteMap:
	def getNoEntryValue(self, ) -> JByte: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TIntByteProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[int, JInt], arg1: JByte, arg2: JByte, ) -> JByte: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TByteFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[int, JInt], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[int, JInt], 1), ) -> JArray(Union[int, JInt], 1): ...
	def containsKey(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(JByte, 1), ) -> JArray(JByte, 1): ...
	@overload
	def values(self, ) -> JArray(JByte, 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TByteCollection: ...
	def containsValue(self, arg0: JByte, ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[int, JInt], arg1: JByte, ) -> JByte: ...
	def remove(self, arg0: Union[int, JInt], ) -> JByte: ...
	def getNoEntryKey(self, ) -> Union[int, JInt]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TIntByteIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TByteProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TIntByteMap, ) -> None: ...
	def get(self, arg0: Union[int, JInt], ) -> JByte: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TIntProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TIntByteProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TIntSet: ...
	def putIfAbsent(self, arg0: Union[int, JInt], arg1: JByte, ) -> JByte: ...
	def adjustValue(self, arg0: Union[int, JInt], arg1: JByte, ) -> Union[int, JBoolean]: ...


class TDoubleLongMap:
	def getNoEntryValue(self, ) -> Union[long, JLong]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TDoubleLongProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[float, JDouble], arg1: Union[long, JLong], arg2: Union[long, JLong], ) -> Union[long, JLong]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TLongFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[float, JDouble], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[float, JDouble], 1), ) -> JArray(Union[float, JDouble], 1): ...
	def containsKey(self, arg0: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[long, JLong], 1), ) -> JArray(Union[long, JLong], 1): ...
	@overload
	def values(self, ) -> JArray(Union[long, JLong], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TLongCollection: ...
	def containsValue(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[float, JDouble], arg1: Union[long, JLong], ) -> Union[long, JLong]: ...
	def remove(self, arg0: Union[float, JDouble], ) -> Union[long, JLong]: ...
	def getNoEntryKey(self, ) -> Union[float, JDouble]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TDoubleLongIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TLongProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TDoubleLongMap, ) -> None: ...
	def get(self, arg0: Union[float, JDouble], ) -> Union[long, JLong]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TDoubleLongProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TDoubleSet: ...
	def putIfAbsent(self, arg0: Union[float, JDouble], arg1: Union[long, JLong], ) -> Union[long, JLong]: ...
	def adjustValue(self, arg0: Union[float, JDouble], arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...


class TLongIntMap:
	def getNoEntryValue(self, ) -> Union[int, JInt]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TLongIntProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[long, JLong], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> Union[int, JInt]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TIntFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[long, JLong], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[long, JLong], 1), ) -> JArray(Union[long, JLong], 1): ...
	def containsKey(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[int, JInt], 1), ) -> JArray(Union[int, JInt], 1): ...
	@overload
	def values(self, ) -> JArray(Union[int, JInt], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TIntCollection: ...
	def containsValue(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> Union[int, JInt]: ...
	def remove(self, arg0: Union[long, JLong], ) -> Union[int, JInt]: ...
	def getNoEntryKey(self, ) -> Union[long, JLong]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TLongIntIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TIntProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TLongIntMap, ) -> None: ...
	def get(self, arg0: Union[long, JLong], ) -> Union[int, JInt]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TLongProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TLongIntProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TLongSet: ...
	def putIfAbsent(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> Union[int, JInt]: ...
	def adjustValue(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> Union[int, JBoolean]: ...


class TCharObjectMap:
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TCharObjectProcedure, ) -> Union[int, JBoolean]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TObjectFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[string, JString], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[string, JString], 1), ) -> JArray(Union[string, JString], 1): ...
	def containsKey(self, arg0: Union[string, JString], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(javawrappers.java.lang.Object, 1), ) -> JArray(javawrappers.java.lang.Object, 1): ...
	@overload
	def values(self, ) -> JArray(javawrappers.java.lang.Object, 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def valueCollection(self, ) -> javawrappers.java.util.Collection: ...
	def containsValue(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[string, JString], arg1: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...
	def remove(self, arg0: Union[string, JString], ) -> javawrappers.java.lang.Object: ...
	def getNoEntryKey(self, ) -> Union[string, JString]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TCharObjectIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TObjectProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TCharObjectMap, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def get(self, arg0: Union[string, JString], ) -> javawrappers.java.lang.Object: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TCharProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TCharObjectProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TCharSet: ...
	def putIfAbsent(self, arg0: Union[string, JString], arg1: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...


class TByteLongMap:
	def getNoEntryValue(self, ) -> Union[long, JLong]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TByteLongProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: JByte, arg1: Union[long, JLong], arg2: Union[long, JLong], ) -> Union[long, JLong]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TLongFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(JByte, 1): ...
	@overload
	def keys(self, arg0: JArray(JByte, 1), ) -> JArray(JByte, 1): ...
	def containsKey(self, arg0: JByte, ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[long, JLong], 1), ) -> JArray(Union[long, JLong], 1): ...
	@overload
	def values(self, ) -> JArray(Union[long, JLong], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: JByte, ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TLongCollection: ...
	def containsValue(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: JByte, arg1: Union[long, JLong], ) -> Union[long, JLong]: ...
	def remove(self, arg0: JByte, ) -> Union[long, JLong]: ...
	def getNoEntryKey(self, ) -> JByte: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TByteLongIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TLongProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TByteLongMap, ) -> None: ...
	def get(self, arg0: JByte, ) -> Union[long, JLong]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TByteProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TByteLongProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TByteSet: ...
	def putIfAbsent(self, arg0: JByte, arg1: Union[long, JLong], ) -> Union[long, JLong]: ...
	def adjustValue(self, arg0: JByte, arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...


class TByteDoubleMap:
	def getNoEntryValue(self, ) -> Union[float, JDouble]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TByteDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: JByte, arg1: Union[float, JDouble], arg2: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TDoubleFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(JByte, 1): ...
	@overload
	def keys(self, arg0: JArray(JByte, 1), ) -> JArray(JByte, 1): ...
	def containsKey(self, arg0: JByte, ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[float, JDouble], 1), ) -> JArray(Union[float, JDouble], 1): ...
	@overload
	def values(self, ) -> JArray(Union[float, JDouble], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: JByte, ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TDoubleCollection: ...
	def containsValue(self, arg0: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: JByte, arg1: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def remove(self, arg0: JByte, ) -> Union[float, JDouble]: ...
	def getNoEntryKey(self, ) -> JByte: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TByteDoubleIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TByteDoubleMap, ) -> None: ...
	def get(self, arg0: JByte, ) -> Union[float, JDouble]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TByteProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TByteDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TByteSet: ...
	def putIfAbsent(self, arg0: JByte, arg1: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def adjustValue(self, arg0: JByte, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...


class TCharDoubleMap:
	def getNoEntryValue(self, ) -> Union[float, JDouble]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TCharDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[string, JString], arg1: Union[float, JDouble], arg2: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TDoubleFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[string, JString], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[string, JString], 1), ) -> JArray(Union[string, JString], 1): ...
	def containsKey(self, arg0: Union[string, JString], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[float, JDouble], 1), ) -> JArray(Union[float, JDouble], 1): ...
	@overload
	def values(self, ) -> JArray(Union[float, JDouble], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[string, JString], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TDoubleCollection: ...
	def containsValue(self, arg0: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[string, JString], arg1: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def remove(self, arg0: Union[string, JString], ) -> Union[float, JDouble]: ...
	def getNoEntryKey(self, ) -> Union[string, JString]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TCharDoubleIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TCharDoubleMap, ) -> None: ...
	def get(self, arg0: Union[string, JString], ) -> Union[float, JDouble]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TCharProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TCharDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TCharSet: ...
	def putIfAbsent(self, arg0: Union[string, JString], arg1: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def adjustValue(self, arg0: Union[string, JString], arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...


class TDoubleCharMap:
	def getNoEntryValue(self, ) -> Union[string, JString]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TDoubleCharProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[float, JDouble], arg1: Union[string, JString], arg2: Union[string, JString], ) -> Union[string, JString]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TCharFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[float, JDouble], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[float, JDouble], 1), ) -> JArray(Union[float, JDouble], 1): ...
	def containsKey(self, arg0: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[string, JString], 1), ) -> JArray(Union[string, JString], 1): ...
	@overload
	def values(self, ) -> JArray(Union[string, JString], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TCharCollection: ...
	def containsValue(self, arg0: Union[string, JString], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[float, JDouble], arg1: Union[string, JString], ) -> Union[string, JString]: ...
	def remove(self, arg0: Union[float, JDouble], ) -> Union[string, JString]: ...
	def getNoEntryKey(self, ) -> Union[float, JDouble]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TDoubleCharIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TCharProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TDoubleCharMap, ) -> None: ...
	def get(self, arg0: Union[float, JDouble], ) -> Union[string, JString]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TDoubleCharProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TDoubleSet: ...
	def putIfAbsent(self, arg0: Union[float, JDouble], arg1: Union[string, JString], ) -> Union[string, JString]: ...
	def adjustValue(self, arg0: Union[float, JDouble], arg1: Union[string, JString], ) -> Union[int, JBoolean]: ...


class TCharIntMap:
	def getNoEntryValue(self, ) -> Union[int, JInt]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TCharIntProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[string, JString], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> Union[int, JInt]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TIntFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[string, JString], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[string, JString], 1), ) -> JArray(Union[string, JString], 1): ...
	def containsKey(self, arg0: Union[string, JString], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[int, JInt], 1), ) -> JArray(Union[int, JInt], 1): ...
	@overload
	def values(self, ) -> JArray(Union[int, JInt], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[string, JString], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TIntCollection: ...
	def containsValue(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[string, JString], arg1: Union[int, JInt], ) -> Union[int, JInt]: ...
	def remove(self, arg0: Union[string, JString], ) -> Union[int, JInt]: ...
	def getNoEntryKey(self, ) -> Union[string, JString]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TCharIntIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TIntProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TCharIntMap, ) -> None: ...
	def get(self, arg0: Union[string, JString], ) -> Union[int, JInt]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TCharProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TCharIntProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TCharSet: ...
	def putIfAbsent(self, arg0: Union[string, JString], arg1: Union[int, JInt], ) -> Union[int, JInt]: ...
	def adjustValue(self, arg0: Union[string, JString], arg1: Union[int, JInt], ) -> Union[int, JBoolean]: ...


class TLongFloatMap:
	def getNoEntryValue(self, ) -> Union[float, JFloat]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TLongFloatProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[long, JLong], arg1: Union[float, JFloat], arg2: Union[float, JFloat], ) -> Union[float, JFloat]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TFloatFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[long, JLong], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[long, JLong], 1), ) -> JArray(Union[long, JLong], 1): ...
	def containsKey(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[float, JFloat], 1), ) -> JArray(Union[float, JFloat], 1): ...
	@overload
	def values(self, ) -> JArray(Union[float, JFloat], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TFloatCollection: ...
	def containsValue(self, arg0: Union[float, JFloat], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[long, JLong], arg1: Union[float, JFloat], ) -> Union[float, JFloat]: ...
	def remove(self, arg0: Union[long, JLong], ) -> Union[float, JFloat]: ...
	def getNoEntryKey(self, ) -> Union[long, JLong]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TLongFloatIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TFloatProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TLongFloatMap, ) -> None: ...
	def get(self, arg0: Union[long, JLong], ) -> Union[float, JFloat]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TLongProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TLongFloatProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TLongSet: ...
	def putIfAbsent(self, arg0: Union[long, JLong], arg1: Union[float, JFloat], ) -> Union[float, JFloat]: ...
	def adjustValue(self, arg0: Union[long, JLong], arg1: Union[float, JFloat], ) -> Union[int, JBoolean]: ...


class TShortDoubleMap:
	def getNoEntryValue(self, ) -> Union[float, JDouble]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TShortDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[int, JShort], arg1: Union[float, JDouble], arg2: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TDoubleFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[int, JShort], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[int, JShort], 1), ) -> JArray(Union[int, JShort], 1): ...
	def containsKey(self, arg0: Union[int, JShort], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[float, JDouble], 1), ) -> JArray(Union[float, JDouble], 1): ...
	@overload
	def values(self, ) -> JArray(Union[float, JDouble], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[int, JShort], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TDoubleCollection: ...
	def containsValue(self, arg0: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[int, JShort], arg1: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def remove(self, arg0: Union[int, JShort], ) -> Union[float, JDouble]: ...
	def getNoEntryKey(self, ) -> Union[int, JShort]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TShortDoubleIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TShortDoubleMap, ) -> None: ...
	def get(self, arg0: Union[int, JShort], ) -> Union[float, JDouble]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TShortProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TShortDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TShortSet: ...
	def putIfAbsent(self, arg0: Union[int, JShort], arg1: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def adjustValue(self, arg0: Union[int, JShort], arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...


class TFloatByteMap:
	def getNoEntryValue(self, ) -> JByte: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TFloatByteProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[float, JFloat], arg1: JByte, arg2: JByte, ) -> JByte: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TByteFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[float, JFloat], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[float, JFloat], 1), ) -> JArray(Union[float, JFloat], 1): ...
	def containsKey(self, arg0: Union[float, JFloat], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(JByte, 1), ) -> JArray(JByte, 1): ...
	@overload
	def values(self, ) -> JArray(JByte, 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[float, JFloat], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TByteCollection: ...
	def containsValue(self, arg0: JByte, ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[float, JFloat], arg1: JByte, ) -> JByte: ...
	def remove(self, arg0: Union[float, JFloat], ) -> JByte: ...
	def getNoEntryKey(self, ) -> Union[float, JFloat]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TFloatByteIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TByteProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TFloatByteMap, ) -> None: ...
	def get(self, arg0: Union[float, JFloat], ) -> JByte: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TFloatProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TFloatByteProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TFloatSet: ...
	def putIfAbsent(self, arg0: Union[float, JFloat], arg1: JByte, ) -> JByte: ...
	def adjustValue(self, arg0: Union[float, JFloat], arg1: JByte, ) -> Union[int, JBoolean]: ...


class TShortObjectMap:
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TShortObjectProcedure, ) -> Union[int, JBoolean]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TObjectFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[int, JShort], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[int, JShort], 1), ) -> JArray(Union[int, JShort], 1): ...
	def containsKey(self, arg0: Union[int, JShort], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(javawrappers.java.lang.Object, 1), ) -> JArray(javawrappers.java.lang.Object, 1): ...
	@overload
	def values(self, ) -> JArray(javawrappers.java.lang.Object, 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def valueCollection(self, ) -> javawrappers.java.util.Collection: ...
	def containsValue(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[int, JShort], arg1: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...
	def remove(self, arg0: Union[int, JShort], ) -> javawrappers.java.lang.Object: ...
	def getNoEntryKey(self, ) -> Union[int, JShort]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TShortObjectIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TObjectProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TShortObjectMap, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def get(self, arg0: Union[int, JShort], ) -> javawrappers.java.lang.Object: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TShortProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TShortObjectProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TShortSet: ...
	def putIfAbsent(self, arg0: Union[int, JShort], arg1: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...


class TShortFloatMap:
	def getNoEntryValue(self, ) -> Union[float, JFloat]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TShortFloatProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[int, JShort], arg1: Union[float, JFloat], arg2: Union[float, JFloat], ) -> Union[float, JFloat]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TFloatFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[int, JShort], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[int, JShort], 1), ) -> JArray(Union[int, JShort], 1): ...
	def containsKey(self, arg0: Union[int, JShort], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[float, JFloat], 1), ) -> JArray(Union[float, JFloat], 1): ...
	@overload
	def values(self, ) -> JArray(Union[float, JFloat], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[int, JShort], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TFloatCollection: ...
	def containsValue(self, arg0: Union[float, JFloat], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[int, JShort], arg1: Union[float, JFloat], ) -> Union[float, JFloat]: ...
	def remove(self, arg0: Union[int, JShort], ) -> Union[float, JFloat]: ...
	def getNoEntryKey(self, ) -> Union[int, JShort]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TShortFloatIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TFloatProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TShortFloatMap, ) -> None: ...
	def get(self, arg0: Union[int, JShort], ) -> Union[float, JFloat]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TShortProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TShortFloatProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TShortSet: ...
	def putIfAbsent(self, arg0: Union[int, JShort], arg1: Union[float, JFloat], ) -> Union[float, JFloat]: ...
	def adjustValue(self, arg0: Union[int, JShort], arg1: Union[float, JFloat], ) -> Union[int, JBoolean]: ...


class TIntLongMap:
	def getNoEntryValue(self, ) -> Union[long, JLong]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TIntLongProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[int, JInt], arg1: Union[long, JLong], arg2: Union[long, JLong], ) -> Union[long, JLong]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TLongFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[int, JInt], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[int, JInt], 1), ) -> JArray(Union[int, JInt], 1): ...
	def containsKey(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[long, JLong], 1), ) -> JArray(Union[long, JLong], 1): ...
	@overload
	def values(self, ) -> JArray(Union[long, JLong], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TLongCollection: ...
	def containsValue(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[int, JInt], arg1: Union[long, JLong], ) -> Union[long, JLong]: ...
	def remove(self, arg0: Union[int, JInt], ) -> Union[long, JLong]: ...
	def getNoEntryKey(self, ) -> Union[int, JInt]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TIntLongIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TLongProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TIntLongMap, ) -> None: ...
	def get(self, arg0: Union[int, JInt], ) -> Union[long, JLong]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TIntProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TIntLongProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TIntSet: ...
	def putIfAbsent(self, arg0: Union[int, JInt], arg1: Union[long, JLong], ) -> Union[long, JLong]: ...
	def adjustValue(self, arg0: Union[int, JInt], arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...


class TObjectCharMap:
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TObjectCharProcedure, ) -> Union[int, JBoolean]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TCharFunction, ) -> None: ...
	@overload
	def keys(self, arg0: JArray(javawrappers.java.lang.Object, 1), ) -> JArray(javawrappers.java.lang.Object, 1): ...
	@overload
	def keys(self, ) -> JArray(javawrappers.java.lang.Object, 1): ...
	@overload
	def values(self, ) -> JArray(Union[string, JString], 1): ...
	@overload
	def values(self, arg0: JArray(Union[string, JString], 1), ) -> JArray(Union[string, JString], 1): ...
	def increment(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TCharCollection: ...
	def containsValue(self, arg0: Union[string, JString], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: javawrappers.java.lang.Object, arg1: Union[string, JString], ) -> Union[string, JString]: ...
	def remove(self, arg0: javawrappers.java.lang.Object, ) -> Union[string, JString]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TObjectCharIterator: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TObjectCharMap, ) -> None: ...
	def get(self, arg0: javawrappers.java.lang.Object, ) -> Union[string, JString]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TObjectCharProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.java.util.Set: ...
	def getNoEntryValue(self, ) -> Union[string, JString]: ...
	def adjustOrPutValue(self, arg0: javawrappers.java.lang.Object, arg1: Union[string, JString], arg2: Union[string, JString], ) -> Union[string, JString]: ...
	def containsKey(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TCharProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TObjectProcedure, ) -> Union[int, JBoolean]: ...
	def putIfAbsent(self, arg0: javawrappers.java.lang.Object, arg1: Union[string, JString], ) -> Union[string, JString]: ...
	def adjustValue(self, arg0: javawrappers.java.lang.Object, arg1: Union[string, JString], ) -> Union[int, JBoolean]: ...


class TCharLongMap:
	def getNoEntryValue(self, ) -> Union[long, JLong]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TCharLongProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[string, JString], arg1: Union[long, JLong], arg2: Union[long, JLong], ) -> Union[long, JLong]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TLongFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[string, JString], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[string, JString], 1), ) -> JArray(Union[string, JString], 1): ...
	def containsKey(self, arg0: Union[string, JString], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[long, JLong], 1), ) -> JArray(Union[long, JLong], 1): ...
	@overload
	def values(self, ) -> JArray(Union[long, JLong], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[string, JString], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TLongCollection: ...
	def containsValue(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[string, JString], arg1: Union[long, JLong], ) -> Union[long, JLong]: ...
	def remove(self, arg0: Union[string, JString], ) -> Union[long, JLong]: ...
	def getNoEntryKey(self, ) -> Union[string, JString]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TCharLongIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TLongProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TCharLongMap, ) -> None: ...
	def get(self, arg0: Union[string, JString], ) -> Union[long, JLong]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TCharProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TCharLongProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TCharSet: ...
	def putIfAbsent(self, arg0: Union[string, JString], arg1: Union[long, JLong], ) -> Union[long, JLong]: ...
	def adjustValue(self, arg0: Union[string, JString], arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...


class TByteObjectMap:
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TByteObjectProcedure, ) -> Union[int, JBoolean]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TObjectFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(JByte, 1): ...
	@overload
	def keys(self, arg0: JArray(JByte, 1), ) -> JArray(JByte, 1): ...
	def containsKey(self, arg0: JByte, ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(javawrappers.java.lang.Object, 1), ) -> JArray(javawrappers.java.lang.Object, 1): ...
	@overload
	def values(self, ) -> JArray(javawrappers.java.lang.Object, 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def valueCollection(self, ) -> javawrappers.java.util.Collection: ...
	def containsValue(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def put(self, arg0: JByte, arg1: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...
	def remove(self, arg0: JByte, ) -> javawrappers.java.lang.Object: ...
	def getNoEntryKey(self, ) -> JByte: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TByteObjectIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TObjectProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TByteObjectMap, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def get(self, arg0: JByte, ) -> javawrappers.java.lang.Object: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TByteProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TByteObjectProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TByteSet: ...
	def putIfAbsent(self, arg0: JByte, arg1: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...


class TDoubleDoubleMap:
	def getNoEntryValue(self, ) -> Union[float, JDouble]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TDoubleDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TDoubleFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[float, JDouble], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[float, JDouble], 1), ) -> JArray(Union[float, JDouble], 1): ...
	def containsKey(self, arg0: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[float, JDouble], 1), ) -> JArray(Union[float, JDouble], 1): ...
	@overload
	def values(self, ) -> JArray(Union[float, JDouble], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TDoubleCollection: ...
	def containsValue(self, arg0: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def remove(self, arg0: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def getNoEntryKey(self, ) -> Union[float, JDouble]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TDoubleDoubleIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TDoubleDoubleMap, ) -> None: ...
	def get(self, arg0: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TDoubleDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TDoubleSet: ...
	def putIfAbsent(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def adjustValue(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...


class TFloatShortMap:
	def getNoEntryValue(self, ) -> Union[int, JShort]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TFloatShortProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[float, JFloat], arg1: Union[int, JShort], arg2: Union[int, JShort], ) -> Union[int, JShort]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TShortFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[float, JFloat], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[float, JFloat], 1), ) -> JArray(Union[float, JFloat], 1): ...
	def containsKey(self, arg0: Union[float, JFloat], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[int, JShort], 1), ) -> JArray(Union[int, JShort], 1): ...
	@overload
	def values(self, ) -> JArray(Union[int, JShort], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[float, JFloat], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TShortCollection: ...
	def containsValue(self, arg0: Union[int, JShort], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[float, JFloat], arg1: Union[int, JShort], ) -> Union[int, JShort]: ...
	def remove(self, arg0: Union[float, JFloat], ) -> Union[int, JShort]: ...
	def getNoEntryKey(self, ) -> Union[float, JFloat]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TFloatShortIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TShortProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TFloatShortMap, ) -> None: ...
	def get(self, arg0: Union[float, JFloat], ) -> Union[int, JShort]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TFloatProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TFloatShortProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TFloatSet: ...
	def putIfAbsent(self, arg0: Union[float, JFloat], arg1: Union[int, JShort], ) -> Union[int, JShort]: ...
	def adjustValue(self, arg0: Union[float, JFloat], arg1: Union[int, JShort], ) -> Union[int, JBoolean]: ...


class TIntFloatMap:
	def getNoEntryValue(self, ) -> Union[float, JFloat]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TIntFloatProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[int, JInt], arg1: Union[float, JFloat], arg2: Union[float, JFloat], ) -> Union[float, JFloat]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TFloatFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[int, JInt], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[int, JInt], 1), ) -> JArray(Union[int, JInt], 1): ...
	def containsKey(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[float, JFloat], 1), ) -> JArray(Union[float, JFloat], 1): ...
	@overload
	def values(self, ) -> JArray(Union[float, JFloat], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TFloatCollection: ...
	def containsValue(self, arg0: Union[float, JFloat], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[int, JInt], arg1: Union[float, JFloat], ) -> Union[float, JFloat]: ...
	def remove(self, arg0: Union[int, JInt], ) -> Union[float, JFloat]: ...
	def getNoEntryKey(self, ) -> Union[int, JInt]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TIntFloatIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TFloatProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TIntFloatMap, ) -> None: ...
	def get(self, arg0: Union[int, JInt], ) -> Union[float, JFloat]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TIntProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TIntFloatProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TIntSet: ...
	def putIfAbsent(self, arg0: Union[int, JInt], arg1: Union[float, JFloat], ) -> Union[float, JFloat]: ...
	def adjustValue(self, arg0: Union[int, JInt], arg1: Union[float, JFloat], ) -> Union[int, JBoolean]: ...


class TByteCharMap:
	def getNoEntryValue(self, ) -> Union[string, JString]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TByteCharProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: JByte, arg1: Union[string, JString], arg2: Union[string, JString], ) -> Union[string, JString]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TCharFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(JByte, 1): ...
	@overload
	def keys(self, arg0: JArray(JByte, 1), ) -> JArray(JByte, 1): ...
	def containsKey(self, arg0: JByte, ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[string, JString], 1), ) -> JArray(Union[string, JString], 1): ...
	@overload
	def values(self, ) -> JArray(Union[string, JString], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: JByte, ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TCharCollection: ...
	def containsValue(self, arg0: Union[string, JString], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: JByte, arg1: Union[string, JString], ) -> Union[string, JString]: ...
	def remove(self, arg0: JByte, ) -> Union[string, JString]: ...
	def getNoEntryKey(self, ) -> JByte: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TByteCharIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TCharProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TByteCharMap, ) -> None: ...
	def get(self, arg0: JByte, ) -> Union[string, JString]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TByteProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TByteCharProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TByteSet: ...
	def putIfAbsent(self, arg0: JByte, arg1: Union[string, JString], ) -> Union[string, JString]: ...
	def adjustValue(self, arg0: JByte, arg1: Union[string, JString], ) -> Union[int, JBoolean]: ...


class TShortShortMap:
	def getNoEntryValue(self, ) -> Union[int, JShort]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TShortShortProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[int, JShort], arg1: Union[int, JShort], arg2: Union[int, JShort], ) -> Union[int, JShort]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TShortFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[int, JShort], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[int, JShort], 1), ) -> JArray(Union[int, JShort], 1): ...
	def containsKey(self, arg0: Union[int, JShort], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[int, JShort], 1), ) -> JArray(Union[int, JShort], 1): ...
	@overload
	def values(self, ) -> JArray(Union[int, JShort], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[int, JShort], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TShortCollection: ...
	def containsValue(self, arg0: Union[int, JShort], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[int, JShort], arg1: Union[int, JShort], ) -> Union[int, JShort]: ...
	def remove(self, arg0: Union[int, JShort], ) -> Union[int, JShort]: ...
	def getNoEntryKey(self, ) -> Union[int, JShort]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TShortShortIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TShortProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TShortShortMap, ) -> None: ...
	def get(self, arg0: Union[int, JShort], ) -> Union[int, JShort]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TShortProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TShortShortProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TShortSet: ...
	def putIfAbsent(self, arg0: Union[int, JShort], arg1: Union[int, JShort], ) -> Union[int, JShort]: ...
	def adjustValue(self, arg0: Union[int, JShort], arg1: Union[int, JShort], ) -> Union[int, JBoolean]: ...


class TDoubleObjectMap:
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TDoubleObjectProcedure, ) -> Union[int, JBoolean]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TObjectFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[float, JDouble], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[float, JDouble], 1), ) -> JArray(Union[float, JDouble], 1): ...
	def containsKey(self, arg0: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(javawrappers.java.lang.Object, 1), ) -> JArray(javawrappers.java.lang.Object, 1): ...
	@overload
	def values(self, ) -> JArray(javawrappers.java.lang.Object, 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def valueCollection(self, ) -> javawrappers.java.util.Collection: ...
	def containsValue(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[float, JDouble], arg1: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...
	def remove(self, arg0: Union[float, JDouble], ) -> javawrappers.java.lang.Object: ...
	def getNoEntryKey(self, ) -> Union[float, JDouble]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TDoubleObjectIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TObjectProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TDoubleObjectMap, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def get(self, arg0: Union[float, JDouble], ) -> javawrappers.java.lang.Object: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TDoubleObjectProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TDoubleSet: ...
	def putIfAbsent(self, arg0: Union[float, JDouble], arg1: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...


class TObjectShortMap:
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TObjectShortProcedure, ) -> Union[int, JBoolean]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TShortFunction, ) -> None: ...
	@overload
	def keys(self, arg0: JArray(javawrappers.java.lang.Object, 1), ) -> JArray(javawrappers.java.lang.Object, 1): ...
	@overload
	def keys(self, ) -> JArray(javawrappers.java.lang.Object, 1): ...
	@overload
	def values(self, ) -> JArray(Union[int, JShort], 1): ...
	@overload
	def values(self, arg0: JArray(Union[int, JShort], 1), ) -> JArray(Union[int, JShort], 1): ...
	def increment(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TShortCollection: ...
	def containsValue(self, arg0: Union[int, JShort], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: javawrappers.java.lang.Object, arg1: Union[int, JShort], ) -> Union[int, JShort]: ...
	def remove(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JShort]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TObjectShortIterator: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TObjectShortMap, ) -> None: ...
	def get(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JShort]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TObjectShortProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.java.util.Set: ...
	def getNoEntryValue(self, ) -> Union[int, JShort]: ...
	def adjustOrPutValue(self, arg0: javawrappers.java.lang.Object, arg1: Union[int, JShort], arg2: Union[int, JShort], ) -> Union[int, JShort]: ...
	def containsKey(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TShortProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TObjectProcedure, ) -> Union[int, JBoolean]: ...
	def putIfAbsent(self, arg0: javawrappers.java.lang.Object, arg1: Union[int, JShort], ) -> Union[int, JShort]: ...
	def adjustValue(self, arg0: javawrappers.java.lang.Object, arg1: Union[int, JShort], ) -> Union[int, JBoolean]: ...


class TByteFloatMap:
	def getNoEntryValue(self, ) -> Union[float, JFloat]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TByteFloatProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: JByte, arg1: Union[float, JFloat], arg2: Union[float, JFloat], ) -> Union[float, JFloat]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TFloatFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(JByte, 1): ...
	@overload
	def keys(self, arg0: JArray(JByte, 1), ) -> JArray(JByte, 1): ...
	def containsKey(self, arg0: JByte, ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[float, JFloat], 1), ) -> JArray(Union[float, JFloat], 1): ...
	@overload
	def values(self, ) -> JArray(Union[float, JFloat], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: JByte, ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TFloatCollection: ...
	def containsValue(self, arg0: Union[float, JFloat], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: JByte, arg1: Union[float, JFloat], ) -> Union[float, JFloat]: ...
	def remove(self, arg0: JByte, ) -> Union[float, JFloat]: ...
	def getNoEntryKey(self, ) -> JByte: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TByteFloatIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TFloatProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TByteFloatMap, ) -> None: ...
	def get(self, arg0: JByte, ) -> Union[float, JFloat]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TByteProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TByteFloatProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TByteSet: ...
	def putIfAbsent(self, arg0: JByte, arg1: Union[float, JFloat], ) -> Union[float, JFloat]: ...
	def adjustValue(self, arg0: JByte, arg1: Union[float, JFloat], ) -> Union[int, JBoolean]: ...


class TShortByteMap:
	def getNoEntryValue(self, ) -> JByte: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TShortByteProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[int, JShort], arg1: JByte, arg2: JByte, ) -> JByte: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TByteFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[int, JShort], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[int, JShort], 1), ) -> JArray(Union[int, JShort], 1): ...
	def containsKey(self, arg0: Union[int, JShort], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(JByte, 1), ) -> JArray(JByte, 1): ...
	@overload
	def values(self, ) -> JArray(JByte, 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[int, JShort], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TByteCollection: ...
	def containsValue(self, arg0: JByte, ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[int, JShort], arg1: JByte, ) -> JByte: ...
	def remove(self, arg0: Union[int, JShort], ) -> JByte: ...
	def getNoEntryKey(self, ) -> Union[int, JShort]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TShortByteIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TByteProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TShortByteMap, ) -> None: ...
	def get(self, arg0: Union[int, JShort], ) -> JByte: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TShortProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TShortByteProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TShortSet: ...
	def putIfAbsent(self, arg0: Union[int, JShort], arg1: JByte, ) -> JByte: ...
	def adjustValue(self, arg0: Union[int, JShort], arg1: JByte, ) -> Union[int, JBoolean]: ...


class TCharCharMap:
	def getNoEntryValue(self, ) -> Union[string, JString]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TCharCharProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[string, JString], arg1: Union[string, JString], arg2: Union[string, JString], ) -> Union[string, JString]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TCharFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[string, JString], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[string, JString], 1), ) -> JArray(Union[string, JString], 1): ...
	def containsKey(self, arg0: Union[string, JString], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[string, JString], 1), ) -> JArray(Union[string, JString], 1): ...
	@overload
	def values(self, ) -> JArray(Union[string, JString], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[string, JString], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TCharCollection: ...
	def containsValue(self, arg0: Union[string, JString], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[string, JString], arg1: Union[string, JString], ) -> Union[string, JString]: ...
	def remove(self, arg0: Union[string, JString], ) -> Union[string, JString]: ...
	def getNoEntryKey(self, ) -> Union[string, JString]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TCharCharIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TCharProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TCharCharMap, ) -> None: ...
	def get(self, arg0: Union[string, JString], ) -> Union[string, JString]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TCharProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TCharCharProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TCharSet: ...
	def putIfAbsent(self, arg0: Union[string, JString], arg1: Union[string, JString], ) -> Union[string, JString]: ...
	def adjustValue(self, arg0: Union[string, JString], arg1: Union[string, JString], ) -> Union[int, JBoolean]: ...


class TFloatLongMap:
	def getNoEntryValue(self, ) -> Union[long, JLong]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TFloatLongProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[float, JFloat], arg1: Union[long, JLong], arg2: Union[long, JLong], ) -> Union[long, JLong]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TLongFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[float, JFloat], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[float, JFloat], 1), ) -> JArray(Union[float, JFloat], 1): ...
	def containsKey(self, arg0: Union[float, JFloat], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[long, JLong], 1), ) -> JArray(Union[long, JLong], 1): ...
	@overload
	def values(self, ) -> JArray(Union[long, JLong], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[float, JFloat], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TLongCollection: ...
	def containsValue(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[float, JFloat], arg1: Union[long, JLong], ) -> Union[long, JLong]: ...
	def remove(self, arg0: Union[float, JFloat], ) -> Union[long, JLong]: ...
	def getNoEntryKey(self, ) -> Union[float, JFloat]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TFloatLongIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TLongProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TFloatLongMap, ) -> None: ...
	def get(self, arg0: Union[float, JFloat], ) -> Union[long, JLong]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TFloatProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TFloatLongProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TFloatSet: ...
	def putIfAbsent(self, arg0: Union[float, JFloat], arg1: Union[long, JLong], ) -> Union[long, JLong]: ...
	def adjustValue(self, arg0: Union[float, JFloat], arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...


class TDoubleFloatMap:
	def getNoEntryValue(self, ) -> Union[float, JFloat]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TDoubleFloatProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[float, JDouble], arg1: Union[float, JFloat], arg2: Union[float, JFloat], ) -> Union[float, JFloat]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TFloatFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[float, JDouble], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[float, JDouble], 1), ) -> JArray(Union[float, JDouble], 1): ...
	def containsKey(self, arg0: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[float, JFloat], 1), ) -> JArray(Union[float, JFloat], 1): ...
	@overload
	def values(self, ) -> JArray(Union[float, JFloat], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TFloatCollection: ...
	def containsValue(self, arg0: Union[float, JFloat], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[float, JDouble], arg1: Union[float, JFloat], ) -> Union[float, JFloat]: ...
	def remove(self, arg0: Union[float, JDouble], ) -> Union[float, JFloat]: ...
	def getNoEntryKey(self, ) -> Union[float, JDouble]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TDoubleFloatIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TFloatProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TDoubleFloatMap, ) -> None: ...
	def get(self, arg0: Union[float, JDouble], ) -> Union[float, JFloat]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TDoubleFloatProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TDoubleSet: ...
	def putIfAbsent(self, arg0: Union[float, JDouble], arg1: Union[float, JFloat], ) -> Union[float, JFloat]: ...
	def adjustValue(self, arg0: Union[float, JDouble], arg1: Union[float, JFloat], ) -> Union[int, JBoolean]: ...


class TByteByteMap:
	def getNoEntryValue(self, ) -> JByte: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TByteByteProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: JByte, arg1: JByte, arg2: JByte, ) -> JByte: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TByteFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(JByte, 1): ...
	@overload
	def keys(self, arg0: JArray(JByte, 1), ) -> JArray(JByte, 1): ...
	def containsKey(self, arg0: JByte, ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(JByte, 1), ) -> JArray(JByte, 1): ...
	@overload
	def values(self, ) -> JArray(JByte, 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: JByte, ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TByteCollection: ...
	def containsValue(self, arg0: JByte, ) -> Union[int, JBoolean]: ...
	def put(self, arg0: JByte, arg1: JByte, ) -> JByte: ...
	def remove(self, arg0: JByte, ) -> JByte: ...
	def getNoEntryKey(self, ) -> JByte: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TByteByteIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TByteProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TByteByteMap, ) -> None: ...
	def get(self, arg0: JByte, ) -> JByte: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TByteProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TByteByteProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TByteSet: ...
	def putIfAbsent(self, arg0: JByte, arg1: JByte, ) -> JByte: ...
	def adjustValue(self, arg0: JByte, arg1: JByte, ) -> Union[int, JBoolean]: ...


class TObjectDoubleMap:
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TObjectDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TDoubleFunction, ) -> None: ...
	@overload
	def keys(self, arg0: JArray(javawrappers.java.lang.Object, 1), ) -> JArray(javawrappers.java.lang.Object, 1): ...
	@overload
	def keys(self, ) -> JArray(javawrappers.java.lang.Object, 1): ...
	@overload
	def values(self, ) -> JArray(Union[float, JDouble], 1): ...
	@overload
	def values(self, arg0: JArray(Union[float, JDouble], 1), ) -> JArray(Union[float, JDouble], 1): ...
	def increment(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TDoubleCollection: ...
	def containsValue(self, arg0: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: javawrappers.java.lang.Object, arg1: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def remove(self, arg0: javawrappers.java.lang.Object, ) -> Union[float, JDouble]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TObjectDoubleIterator: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TObjectDoubleMap, ) -> None: ...
	def get(self, arg0: javawrappers.java.lang.Object, ) -> Union[float, JDouble]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TObjectDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.java.util.Set: ...
	def getNoEntryValue(self, ) -> Union[float, JDouble]: ...
	def adjustOrPutValue(self, arg0: javawrappers.java.lang.Object, arg1: Union[float, JDouble], arg2: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def containsKey(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TObjectProcedure, ) -> Union[int, JBoolean]: ...
	def putIfAbsent(self, arg0: javawrappers.java.lang.Object, arg1: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def adjustValue(self, arg0: javawrappers.java.lang.Object, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...


class TByteShortMap:
	def getNoEntryValue(self, ) -> Union[int, JShort]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TByteShortProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: JByte, arg1: Union[int, JShort], arg2: Union[int, JShort], ) -> Union[int, JShort]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TShortFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(JByte, 1): ...
	@overload
	def keys(self, arg0: JArray(JByte, 1), ) -> JArray(JByte, 1): ...
	def containsKey(self, arg0: JByte, ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[int, JShort], 1), ) -> JArray(Union[int, JShort], 1): ...
	@overload
	def values(self, ) -> JArray(Union[int, JShort], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: JByte, ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TShortCollection: ...
	def containsValue(self, arg0: Union[int, JShort], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: JByte, arg1: Union[int, JShort], ) -> Union[int, JShort]: ...
	def remove(self, arg0: JByte, ) -> Union[int, JShort]: ...
	def getNoEntryKey(self, ) -> JByte: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TByteShortIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TShortProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TByteShortMap, ) -> None: ...
	def get(self, arg0: JByte, ) -> Union[int, JShort]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TByteProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TByteShortProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TByteSet: ...
	def putIfAbsent(self, arg0: JByte, arg1: Union[int, JShort], ) -> Union[int, JShort]: ...
	def adjustValue(self, arg0: JByte, arg1: Union[int, JShort], ) -> Union[int, JBoolean]: ...


class TShortIntMap:
	def getNoEntryValue(self, ) -> Union[int, JInt]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TShortIntProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[int, JShort], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> Union[int, JInt]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TIntFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[int, JShort], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[int, JShort], 1), ) -> JArray(Union[int, JShort], 1): ...
	def containsKey(self, arg0: Union[int, JShort], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[int, JInt], 1), ) -> JArray(Union[int, JInt], 1): ...
	@overload
	def values(self, ) -> JArray(Union[int, JInt], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[int, JShort], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TIntCollection: ...
	def containsValue(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[int, JShort], arg1: Union[int, JInt], ) -> Union[int, JInt]: ...
	def remove(self, arg0: Union[int, JShort], ) -> Union[int, JInt]: ...
	def getNoEntryKey(self, ) -> Union[int, JShort]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TShortIntIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TIntProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TShortIntMap, ) -> None: ...
	def get(self, arg0: Union[int, JShort], ) -> Union[int, JInt]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TShortProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TShortIntProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TShortSet: ...
	def putIfAbsent(self, arg0: Union[int, JShort], arg1: Union[int, JInt], ) -> Union[int, JInt]: ...
	def adjustValue(self, arg0: Union[int, JShort], arg1: Union[int, JInt], ) -> Union[int, JBoolean]: ...


class TShortLongMap:
	def getNoEntryValue(self, ) -> Union[long, JLong]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TShortLongProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[int, JShort], arg1: Union[long, JLong], arg2: Union[long, JLong], ) -> Union[long, JLong]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TLongFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[int, JShort], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[int, JShort], 1), ) -> JArray(Union[int, JShort], 1): ...
	def containsKey(self, arg0: Union[int, JShort], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[long, JLong], 1), ) -> JArray(Union[long, JLong], 1): ...
	@overload
	def values(self, ) -> JArray(Union[long, JLong], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[int, JShort], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TLongCollection: ...
	def containsValue(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[int, JShort], arg1: Union[long, JLong], ) -> Union[long, JLong]: ...
	def remove(self, arg0: Union[int, JShort], ) -> Union[long, JLong]: ...
	def getNoEntryKey(self, ) -> Union[int, JShort]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TShortLongIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TLongProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TShortLongMap, ) -> None: ...
	def get(self, arg0: Union[int, JShort], ) -> Union[long, JLong]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TShortProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TShortLongProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TShortSet: ...
	def putIfAbsent(self, arg0: Union[int, JShort], arg1: Union[long, JLong], ) -> Union[long, JLong]: ...
	def adjustValue(self, arg0: Union[int, JShort], arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...


class TLongByteMap:
	def getNoEntryValue(self, ) -> JByte: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TLongByteProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[long, JLong], arg1: JByte, arg2: JByte, ) -> JByte: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TByteFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[long, JLong], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[long, JLong], 1), ) -> JArray(Union[long, JLong], 1): ...
	def containsKey(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(JByte, 1), ) -> JArray(JByte, 1): ...
	@overload
	def values(self, ) -> JArray(JByte, 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TByteCollection: ...
	def containsValue(self, arg0: JByte, ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[long, JLong], arg1: JByte, ) -> JByte: ...
	def remove(self, arg0: Union[long, JLong], ) -> JByte: ...
	def getNoEntryKey(self, ) -> Union[long, JLong]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TLongByteIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TByteProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TLongByteMap, ) -> None: ...
	def get(self, arg0: Union[long, JLong], ) -> JByte: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TLongProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TLongByteProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TLongSet: ...
	def putIfAbsent(self, arg0: Union[long, JLong], arg1: JByte, ) -> JByte: ...
	def adjustValue(self, arg0: Union[long, JLong], arg1: JByte, ) -> Union[int, JBoolean]: ...


class TObjectByteMap:
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TObjectByteProcedure, ) -> Union[int, JBoolean]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TByteFunction, ) -> None: ...
	@overload
	def keys(self, arg0: JArray(javawrappers.java.lang.Object, 1), ) -> JArray(javawrappers.java.lang.Object, 1): ...
	@overload
	def keys(self, ) -> JArray(javawrappers.java.lang.Object, 1): ...
	@overload
	def values(self, ) -> JArray(JByte, 1): ...
	@overload
	def values(self, arg0: JArray(JByte, 1), ) -> JArray(JByte, 1): ...
	def increment(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TByteCollection: ...
	def containsValue(self, arg0: JByte, ) -> Union[int, JBoolean]: ...
	def put(self, arg0: javawrappers.java.lang.Object, arg1: JByte, ) -> JByte: ...
	def remove(self, arg0: javawrappers.java.lang.Object, ) -> JByte: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TObjectByteIterator: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TObjectByteMap, ) -> None: ...
	def get(self, arg0: javawrappers.java.lang.Object, ) -> JByte: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TObjectByteProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.java.util.Set: ...
	def getNoEntryValue(self, ) -> JByte: ...
	def adjustOrPutValue(self, arg0: javawrappers.java.lang.Object, arg1: JByte, arg2: JByte, ) -> JByte: ...
	def containsKey(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TByteProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TObjectProcedure, ) -> Union[int, JBoolean]: ...
	def putIfAbsent(self, arg0: javawrappers.java.lang.Object, arg1: JByte, ) -> JByte: ...
	def adjustValue(self, arg0: javawrappers.java.lang.Object, arg1: JByte, ) -> Union[int, JBoolean]: ...


class TFloatDoubleMap:
	def getNoEntryValue(self, ) -> Union[float, JDouble]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TFloatDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[float, JFloat], arg1: Union[float, JDouble], arg2: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TDoubleFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[float, JFloat], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[float, JFloat], 1), ) -> JArray(Union[float, JFloat], 1): ...
	def containsKey(self, arg0: Union[float, JFloat], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[float, JDouble], 1), ) -> JArray(Union[float, JDouble], 1): ...
	@overload
	def values(self, ) -> JArray(Union[float, JDouble], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[float, JFloat], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TDoubleCollection: ...
	def containsValue(self, arg0: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[float, JFloat], arg1: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def remove(self, arg0: Union[float, JFloat], ) -> Union[float, JDouble]: ...
	def getNoEntryKey(self, ) -> Union[float, JFloat]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TFloatDoubleIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TFloatDoubleMap, ) -> None: ...
	def get(self, arg0: Union[float, JFloat], ) -> Union[float, JDouble]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TFloatProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TFloatDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TFloatSet: ...
	def putIfAbsent(self, arg0: Union[float, JFloat], arg1: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def adjustValue(self, arg0: Union[float, JFloat], arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...


class TDoubleByteMap:
	def getNoEntryValue(self, ) -> JByte: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TDoubleByteProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[float, JDouble], arg1: JByte, arg2: JByte, ) -> JByte: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TByteFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[float, JDouble], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[float, JDouble], 1), ) -> JArray(Union[float, JDouble], 1): ...
	def containsKey(self, arg0: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(JByte, 1), ) -> JArray(JByte, 1): ...
	@overload
	def values(self, ) -> JArray(JByte, 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TByteCollection: ...
	def containsValue(self, arg0: JByte, ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[float, JDouble], arg1: JByte, ) -> JByte: ...
	def remove(self, arg0: Union[float, JDouble], ) -> JByte: ...
	def getNoEntryKey(self, ) -> Union[float, JDouble]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TDoubleByteIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TByteProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TDoubleByteMap, ) -> None: ...
	def get(self, arg0: Union[float, JDouble], ) -> JByte: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TDoubleProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TDoubleByteProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TDoubleSet: ...
	def putIfAbsent(self, arg0: Union[float, JDouble], arg1: JByte, ) -> JByte: ...
	def adjustValue(self, arg0: Union[float, JDouble], arg1: JByte, ) -> Union[int, JBoolean]: ...


class TObjectLongMap:
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TObjectLongProcedure, ) -> Union[int, JBoolean]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TLongFunction, ) -> None: ...
	@overload
	def keys(self, arg0: JArray(javawrappers.java.lang.Object, 1), ) -> JArray(javawrappers.java.lang.Object, 1): ...
	@overload
	def keys(self, ) -> JArray(javawrappers.java.lang.Object, 1): ...
	@overload
	def values(self, ) -> JArray(Union[long, JLong], 1): ...
	@overload
	def values(self, arg0: JArray(Union[long, JLong], 1), ) -> JArray(Union[long, JLong], 1): ...
	def increment(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TLongCollection: ...
	def containsValue(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: javawrappers.java.lang.Object, arg1: Union[long, JLong], ) -> Union[long, JLong]: ...
	def remove(self, arg0: javawrappers.java.lang.Object, ) -> Union[long, JLong]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TObjectLongIterator: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TObjectLongMap, ) -> None: ...
	def get(self, arg0: javawrappers.java.lang.Object, ) -> Union[long, JLong]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TObjectLongProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.java.util.Set: ...
	def getNoEntryValue(self, ) -> Union[long, JLong]: ...
	def adjustOrPutValue(self, arg0: javawrappers.java.lang.Object, arg1: Union[long, JLong], arg2: Union[long, JLong], ) -> Union[long, JLong]: ...
	def containsKey(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TLongProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TObjectProcedure, ) -> Union[int, JBoolean]: ...
	def putIfAbsent(self, arg0: javawrappers.java.lang.Object, arg1: Union[long, JLong], ) -> Union[long, JLong]: ...
	def adjustValue(self, arg0: javawrappers.java.lang.Object, arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...


class TShortCharMap:
	def getNoEntryValue(self, ) -> Union[string, JString]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TShortCharProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[int, JShort], arg1: Union[string, JString], arg2: Union[string, JString], ) -> Union[string, JString]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TCharFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[int, JShort], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[int, JShort], 1), ) -> JArray(Union[int, JShort], 1): ...
	def containsKey(self, arg0: Union[int, JShort], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[string, JString], 1), ) -> JArray(Union[string, JString], 1): ...
	@overload
	def values(self, ) -> JArray(Union[string, JString], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[int, JShort], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TCharCollection: ...
	def containsValue(self, arg0: Union[string, JString], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[int, JShort], arg1: Union[string, JString], ) -> Union[string, JString]: ...
	def remove(self, arg0: Union[int, JShort], ) -> Union[string, JString]: ...
	def getNoEntryKey(self, ) -> Union[int, JShort]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TShortCharIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TCharProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TShortCharMap, ) -> None: ...
	def get(self, arg0: Union[int, JShort], ) -> Union[string, JString]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TShortProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TShortCharProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TShortSet: ...
	def putIfAbsent(self, arg0: Union[int, JShort], arg1: Union[string, JString], ) -> Union[string, JString]: ...
	def adjustValue(self, arg0: Union[int, JShort], arg1: Union[string, JString], ) -> Union[int, JBoolean]: ...


class TIntIntMap:
	def getNoEntryValue(self, ) -> Union[int, JInt]: ...
	def forEachEntry(self, arg0: javawrappers.gnu.trove.procedure.TIntIntProcedure, ) -> Union[int, JBoolean]: ...
	def adjustOrPutValue(self, arg0: Union[int, JInt], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> Union[int, JInt]: ...
	def transformValues(self, arg0: javawrappers.gnu.trove.function.TIntFunction, ) -> None: ...
	@overload
	def keys(self, ) -> JArray(Union[int, JInt], 1): ...
	@overload
	def keys(self, arg0: JArray(Union[int, JInt], 1), ) -> JArray(Union[int, JInt], 1): ...
	def containsKey(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	@overload
	def values(self, arg0: JArray(Union[int, JInt], 1), ) -> JArray(Union[int, JInt], 1): ...
	@overload
	def values(self, ) -> JArray(Union[int, JInt], 1): ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def increment(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	def valueCollection(self, ) -> javawrappers.gnu.trove.TIntCollection: ...
	def containsValue(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	def put(self, arg0: Union[int, JInt], arg1: Union[int, JInt], ) -> Union[int, JInt]: ...
	def remove(self, arg0: Union[int, JInt], ) -> Union[int, JInt]: ...
	def getNoEntryKey(self, ) -> Union[int, JInt]: ...
	def iterator(self, ) -> javawrappers.gnu.trove.iterator.TIntIntIterator: ...
	def forEachValue(self, arg0: javawrappers.gnu.trove.procedure.TIntProcedure, ) -> Union[int, JBoolean]: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def putAll(self, arg0: javawrappers.gnu.trove.map.TIntIntMap, ) -> None: ...
	def get(self, arg0: Union[int, JInt], ) -> Union[int, JInt]: ...
	def forEachKey(self, arg0: javawrappers.gnu.trove.procedure.TIntProcedure, ) -> Union[int, JBoolean]: ...
	def retainEntries(self, arg0: javawrappers.gnu.trove.procedure.TIntIntProcedure, ) -> Union[int, JBoolean]: ...
	def keySet(self, ) -> javawrappers.gnu.trove.set.TIntSet: ...
	def putIfAbsent(self, arg0: Union[int, JInt], arg1: Union[int, JInt], ) -> Union[int, JInt]: ...
	def adjustValue(self, arg0: Union[int, JInt], arg1: Union[int, JInt], ) -> Union[int, JBoolean]: ...


