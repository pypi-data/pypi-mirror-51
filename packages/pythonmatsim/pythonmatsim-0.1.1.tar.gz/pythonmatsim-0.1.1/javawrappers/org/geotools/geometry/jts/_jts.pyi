################################################################################
#          This file was automatically generated. Please do not edit.          #
################################################################################

import javawrappers.java.util
import javawrappers.org.opengis.geometry
import javawrappers.org.geotools.geometry.jts
import javawrappers.java.awt.geom
import javawrappers.org.opengis.referencing.operation
import javawrappers.java.util.stream
import javawrappers.org.geotools.factory
import javawrappers.org.opengis.referencing.crs
import javawrappers.javax.imageio.spi
import javawrappers.org.locationtech.jts.geom.impl
import javawrappers.java.awt
import javawrappers.java.lang
import javawrappers.java.io
import javawrappers.java.util.function
import javawrappers.org.locationtech.jts.geom
import javawrappers.org.geotools.geometry

from jpype.types import *
from typing import Union

from typing import overload

class MultiCurvedGeometry:
	def toCurvedText(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def linearize(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def linearize(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getTolerance(self, ) -> Union[float, JDouble]: ...
	def getCoordinatesDimension(self, ) -> Union[int, JInt]: ...


class PreciseCoordinateSequenceTransformer:
	def __init__(self, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def transform(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, arg1: javawrappers.org.opengis.referencing.operation.MathTransform, ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	def setFlatness(self, arg0: Union[float, JDouble], ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def getFlatness(self, ) -> Union[float, JDouble]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def notify(self, ) -> None: ...


class ReferencedEnvelope:
	@overload
	def __init__(self, arg0: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ): ...
	@overload
	def __init__(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], arg4: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ): ...
	@overload
	def __init__(self, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, arg1: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.opengis.geometry.Envelope, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.opengis.geometry.BoundingBox, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.geotools.geometry.jts.ReferencedEnvelope, ): ...
	@overload
	def __init__(self, arg0: javawrappers.java.awt.geom.Rectangle2D, arg1: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def getCenter(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	@overload
	def expandToInclude(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> None: ...
	@overload
	def expandToInclude(self, arg0: javawrappers.org.opengis.geometry.DirectPosition, ) -> None: ...
	@overload
	def expandToInclude(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> None: ...
	@overload
	def expandToInclude(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> None: ...
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	def translate(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> None: ...
	@overload
	@staticmethod
	def reference(arg0: javawrappers.org.geotools.geometry.jts.ReferencedEnvelope, ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	@overload
	@staticmethod
	def reference(arg0: javawrappers.org.opengis.geometry.Envelope, ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	@overload
	@staticmethod
	def reference(arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	def getUpperCorner(self, ) -> javawrappers.org.opengis.geometry.DirectPosition: ...
	@overload
	def intersection(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	@overload
	def intersection(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...
	@overload
	def overlaps(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def overlaps(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	@overload
	def overlaps(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> Union[int, JBoolean]: ...
	def getMinimum(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	def getDimension(self, ) -> Union[int, JInt]: ...
	@overload
	@staticmethod
	def create(arg0: javawrappers.java.awt.geom.Rectangle2D, arg1: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	@overload
	@staticmethod
	def create(arg0: javawrappers.org.opengis.geometry.Envelope, arg1: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	@overload
	@staticmethod
	def create(arg0: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	@overload
	@staticmethod
	def create(arg0: javawrappers.org.geotools.geometry.jts.ReferencedEnvelope, arg1: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	@overload
	@staticmethod
	def create(arg0: javawrappers.org.locationtech.jts.geom.Envelope, arg1: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	@overload
	@staticmethod
	def create(arg0: javawrappers.org.geotools.geometry.jts.ReferencedEnvelope, ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	@overload
	def init(self, arg0: javawrappers.org.opengis.geometry.BoundingBox, ) -> None: ...
	@overload
	def init(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], ) -> None: ...
	@overload
	def init(self, ) -> None: ...
	@overload
	def init(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> None: ...
	@overload
	def init(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> None: ...
	@overload
	def init(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> None: ...
	@overload
	def contains(self, arg0: javawrappers.org.opengis.geometry.BoundingBox, ) -> Union[int, JBoolean]: ...
	@overload
	def contains(self, arg0: javawrappers.org.opengis.geometry.DirectPosition, ) -> Union[int, JBoolean]: ...
	@overload
	def contains(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def contains(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	@overload
	def contains(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> Union[int, JBoolean]: ...
	def boundsEquals2D(self, arg0: javawrappers.org.opengis.geometry.Envelope, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getMinX(self, ) -> Union[float, JDouble]: ...
	def getMinY(self, ) -> Union[float, JDouble]: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def distance(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> Union[float, JDouble]: ...
	def getCoordinateReferenceSystem(self, ) -> javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem: ...
	@overload
	def intersects(self, arg0: javawrappers.org.opengis.geometry.BoundingBox, ) -> Union[int, JBoolean]: ...
	@overload
	@staticmethod
	def intersects(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, arg2: javawrappers.org.locationtech.jts.geom.Coordinate, arg3: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	@overload
	@staticmethod
	def intersects(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, arg2: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	@overload
	def intersects(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	@overload
	def intersects(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	@overload
	def intersects(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> Union[int, JBoolean]: ...
	@overload
	def intersects(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getSpan(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	def maxY(self, ) -> Union[float, JDouble]: ...
	def notifyAll(self, ) -> None: ...
	def maxX(self, ) -> Union[float, JDouble]: ...
	def getWidth(self, ) -> Union[float, JDouble]: ...
	def getMaximum(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	def notify(self, ) -> None: ...
	def getHeight(self, ) -> Union[float, JDouble]: ...
	@overload
	def transform(self, arg0: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, arg1: Union[int, JBoolean], ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	@overload
	def transform(self, arg0: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, arg1: Union[int, JBoolean], arg2: Union[int, JInt], ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	def getMedian(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def setToNull(self, ) -> None: ...
	def maxExtent(self, ) -> Union[float, JDouble]: ...
	def toBounds(self, arg0: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ) -> javawrappers.org.opengis.geometry.BoundingBox: ...
	@overload
	def covers(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def covers(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	@overload
	def covers(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> Union[int, JBoolean]: ...
	@overload
	def include(self, arg0: javawrappers.org.opengis.geometry.BoundingBox, ) -> None: ...
	@overload
	def include(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> None: ...
	def crs(self, ) -> javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem: ...
	def minExtent(self, ) -> Union[float, JDouble]: ...
	def getMaxX(self, ) -> Union[float, JDouble]: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def centre(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def getMaxY(self, ) -> Union[float, JDouble]: ...
	def setBounds(self, arg0: javawrappers.org.opengis.geometry.BoundingBox, ) -> None: ...
	def minY(self, ) -> Union[float, JDouble]: ...
	def minX(self, ) -> Union[float, JDouble]: ...
	def isNull(self, ) -> Union[int, JBoolean]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def getLength(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	@overload
	def expandBy(self, arg0: Union[float, JDouble], ) -> None: ...
	@overload
	def expandBy(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> None: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def getLowerCorner(self, ) -> javawrappers.org.opengis.geometry.DirectPosition: ...
	def getArea(self, ) -> Union[float, JDouble]: ...


class SingleCurvedGeometry:
	def getNumArcs(self, ) -> Union[int, JInt]: ...
	def toCurvedText(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def linearize(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def linearize(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getLinearizedCoordinateSequence(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	def getControlPoints(self, ) -> JArray(Union[float, JDouble], 1): ...
	def getTolerance(self, ) -> Union[float, JDouble]: ...
	def getCoordinatesDimension(self, ) -> Union[int, JInt]: ...
	def getArcN(self, arg0: Union[int, JInt], ) -> javawrappers.org.geotools.geometry.jts.CircularArc: ...


class ReferencedEnvelope3D:
	@overload
	def __init__(self, arg0: javawrappers.org.opengis.geometry.BoundingBox3D, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ): ...
	@overload
	def __init__(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], arg4: Union[float, JDouble], arg5: Union[float, JDouble], arg6: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ): ...
	@overload
	def __init__(self, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.geotools.geometry.jts.ReferencedEnvelope3D, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.geotools.geometry.jts.ReferencedEnvelope3D, arg1: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.opengis.geometry.Envelope, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, arg1: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def getCenter(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	@overload
	def expandToInclude(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> None: ...
	@overload
	def expandToInclude(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> None: ...
	@overload
	def expandToInclude(self, arg0: javawrappers.org.opengis.geometry.DirectPosition, ) -> None: ...
	@overload
	def expandToInclude(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> None: ...
	@overload
	def expandToInclude(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], ) -> None: ...
	@overload
	def expandToInclude(self, arg0: javawrappers.org.geotools.geometry.jts.ReferencedEnvelope3D, ) -> None: ...
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def translate(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> None: ...
	@overload
	def translate(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], ) -> None: ...
	@overload
	@staticmethod
	def reference(arg0: javawrappers.org.geotools.geometry.jts.ReferencedEnvelope, ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	@overload
	@staticmethod
	def reference(arg0: javawrappers.org.opengis.geometry.Envelope, ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	@overload
	@staticmethod
	def reference(arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	def getUpperCorner(self, ) -> javawrappers.org.opengis.geometry.DirectPosition: ...
	@overload
	def intersection(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	@overload
	def intersection(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...
	@overload
	def intersection(self, arg0: javawrappers.org.geotools.geometry.jts.ReferencedEnvelope3D, ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope3D: ...
	def getMinimum(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	def getDimension(self, ) -> Union[int, JInt]: ...
	@overload
	def overlaps(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	@overload
	def overlaps(self, arg0: javawrappers.org.geotools.geometry.jts.ReferencedEnvelope3D, ) -> Union[int, JBoolean]: ...
	@overload
	def overlaps(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def overlaps(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def overlaps(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> Union[int, JBoolean]: ...
	@overload
	@staticmethod
	def create(arg0: javawrappers.java.awt.geom.Rectangle2D, arg1: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	@overload
	@staticmethod
	def create(arg0: javawrappers.org.opengis.geometry.Envelope, arg1: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	@overload
	@staticmethod
	def create(arg0: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	@overload
	@staticmethod
	def create(arg0: javawrappers.org.geotools.geometry.jts.ReferencedEnvelope, arg1: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	@overload
	@staticmethod
	def create(arg0: javawrappers.org.locationtech.jts.geom.Envelope, arg1: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	@overload
	@staticmethod
	def create(arg0: javawrappers.org.geotools.geometry.jts.ReferencedEnvelope, ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	@overload
	def init(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> None: ...
	@overload
	def init(self, ) -> None: ...
	@overload
	def init(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], arg4: Union[float, JDouble], arg5: Union[float, JDouble], ) -> None: ...
	@overload
	def init(self, arg0: javawrappers.org.opengis.geometry.BoundingBox, ) -> None: ...
	@overload
	def init(self, arg0: javawrappers.org.geotools.geometry.jts.ReferencedEnvelope3D, ) -> None: ...
	@overload
	def init(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> None: ...
	@overload
	def init(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> None: ...
	@overload
	def init(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], ) -> None: ...
	@overload
	def contains(self, arg0: javawrappers.org.opengis.geometry.BoundingBox, ) -> Union[int, JBoolean]: ...
	@overload
	def contains(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	@overload
	def contains(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def contains(self, arg0: javawrappers.org.opengis.geometry.BoundingBox3D, ) -> Union[int, JBoolean]: ...
	@overload
	def contains(self, arg0: javawrappers.org.opengis.geometry.DirectPosition, ) -> Union[int, JBoolean]: ...
	@overload
	def contains(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def contains(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> Union[int, JBoolean]: ...
	def boundsEquals2D(self, arg0: javawrappers.org.opengis.geometry.Envelope, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getMinZ(self, ) -> Union[float, JDouble]: ...
	def getMinX(self, ) -> Union[float, JDouble]: ...
	def getMinY(self, ) -> Union[float, JDouble]: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def getDepth(self, ) -> Union[float, JDouble]: ...
	def getCoordinateReferenceSystem(self, ) -> javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem: ...
	@overload
	def distance(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> Union[float, JDouble]: ...
	@overload
	def distance(self, arg0: javawrappers.org.geotools.geometry.jts.ReferencedEnvelope3D, ) -> Union[float, JDouble]: ...
	@overload
	def intersects(self, arg0: javawrappers.org.opengis.geometry.BoundingBox, ) -> Union[int, JBoolean]: ...
	@overload
	def intersects(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	@overload
	def intersects(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> Union[int, JBoolean]: ...
	@overload
	def intersects(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	@staticmethod
	def intersects(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, arg2: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	@overload
	def intersects(self, arg0: javawrappers.org.opengis.geometry.BoundingBox3D, ) -> Union[int, JBoolean]: ...
	@overload
	def intersects(self, arg0: javawrappers.org.geotools.geometry.jts.ReferencedEnvelope3D, ) -> Union[int, JBoolean]: ...
	@overload
	def intersects(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	@overload
	def intersects(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	@staticmethod
	def intersects(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, arg2: javawrappers.org.locationtech.jts.geom.Coordinate, arg3: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	def getSpan(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	def maxY(self, ) -> Union[float, JDouble]: ...
	def notifyAll(self, ) -> None: ...
	def maxX(self, ) -> Union[float, JDouble]: ...
	def getWidth(self, ) -> Union[float, JDouble]: ...
	def getMaximum(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	def notify(self, ) -> None: ...
	def getHeight(self, ) -> Union[float, JDouble]: ...
	@overload
	def transform(self, arg0: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, arg1: Union[int, JBoolean], arg2: Union[int, JInt], ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	@overload
	def transform(self, arg0: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, arg1: Union[int, JBoolean], ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	def getVolume(self, ) -> Union[float, JDouble]: ...
	def getMedian(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def boundsEquals3D(self, arg0: javawrappers.org.opengis.geometry.Envelope, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def setToNull(self, ) -> None: ...
	def toBounds(self, arg0: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ) -> javawrappers.org.opengis.geometry.BoundingBox: ...
	def maxExtent(self, ) -> Union[float, JDouble]: ...
	@overload
	def covers(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def covers(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> Union[int, JBoolean]: ...
	@overload
	def covers(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def covers(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	@overload
	def covers(self, arg0: javawrappers.org.geotools.geometry.jts.ReferencedEnvelope3D, ) -> Union[int, JBoolean]: ...
	@overload
	def include(self, arg0: javawrappers.org.opengis.geometry.BoundingBox, ) -> None: ...
	@overload
	def include(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> None: ...
	@overload
	def include(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], ) -> None: ...
	@overload
	def include(self, arg0: javawrappers.org.opengis.geometry.BoundingBox3D, ) -> None: ...
	def crs(self, ) -> javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem: ...
	def minExtent(self, ) -> Union[float, JDouble]: ...
	def getMaxX(self, ) -> Union[float, JDouble]: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def getMaxY(self, ) -> Union[float, JDouble]: ...
	def centre(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	@overload
	def setBounds(self, arg0: javawrappers.org.opengis.geometry.BoundingBox3D, ) -> None: ...
	@overload
	def setBounds(self, arg0: javawrappers.org.opengis.geometry.BoundingBox, ) -> None: ...
	def getMaxZ(self, ) -> Union[float, JDouble]: ...
	def minY(self, ) -> Union[float, JDouble]: ...
	def minX(self, ) -> Union[float, JDouble]: ...
	def isNull(self, ) -> Union[int, JBoolean]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def getLength(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def expandBy(self, arg0: Union[float, JDouble], ) -> None: ...
	@overload
	def expandBy(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], ) -> None: ...
	@overload
	def expandBy(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> None: ...
	def getLowerCorner(self, ) -> javawrappers.org.opengis.geometry.DirectPosition: ...
	def getArea(self, ) -> Union[float, JDouble]: ...


class CompoundRing:
	@overload
	def __init__(self, arg0: javawrappers.java.util.List, arg1: javawrappers.org.locationtech.jts.geom.GeometryFactory, arg2: Union[float, JDouble], ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.geotools.geometry.jts.CompoundCurve, ): ...
	def getGeometryN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def equalsNorm(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def linearize(self, ) -> javawrappers.org.locationtech.jts.geom.LinearRing: ...
	@overload
	def linearize(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def linearize(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def linearize(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.LinearRing: ...
	def isCoordinate(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	def equalsTopo(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def coveredBy(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def geometryChanged(self, ) -> None: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.org.locationtech.jts.geom.CoordinateSequenceComparator, ) -> Union[int, JInt]: ...
	def getEnvelopeInternal(self, ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...
	def crosses(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def norm(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.java.lang.String, ) -> Union[int, JBoolean]: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.IntersectionMatrix: ...
	def getSRID(self, ) -> Union[int, JInt]: ...
	def disjoint(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def normalize(self, ) -> None: ...
	def intersection(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getDimension(self, ) -> Union[int, JInt]: ...
	def overlaps(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getComponents(self, ) -> javawrappers.java.util.List: ...
	def isSimple(self, ) -> Union[int, JBoolean]: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getCoordinateSequence(self, ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getCentroid(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def getCoordinates(self, ) -> JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1): ...
	def contains(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getEndPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def isWithinDistance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getNumGeometries(self, ) -> Union[int, JInt]: ...
	def getPointN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def difference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def setUserData(self, arg0: javawrappers.java.lang.Object, ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def distance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[float, JDouble]: ...
	def getNumPoints(self, ) -> Union[int, JInt]: ...
	def intersects(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def notifyAll(self, ) -> None: ...
	def getCoordinateN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def notify(self, ) -> None: ...
	def isRing(self, ) -> Union[int, JBoolean]: ...
	def setSRID(self, arg0: Union[int, JInt], ) -> None: ...
	def getInteriorPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def getTolerance(self, ) -> Union[float, JDouble]: ...
	def getCoordinatesDimension(self, ) -> Union[int, JInt]: ...
	def copy(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def convexHull(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def covers(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def copyInternal(self, ) -> javawrappers.org.geotools.geometry.jts.CompoundRing: ...
	@overload
	def copyInternal(self, ) -> javawrappers.org.locationtech.jts.geom.LinearRing: ...
	@overload
	def copyInternal(self, ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	@overload
	def copyInternal(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getStartPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryComponentFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequenceFilter, ) -> None: ...
	def within(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getBoundary(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def isValid(self, ) -> Union[int, JBoolean]: ...
	def getGeometryType(self, ) -> javawrappers.java.lang.String: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	@overload
	def union(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def union(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def reverse(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getFactory(self, ) -> javawrappers.org.locationtech.jts.geom.GeometryFactory: ...
	def symDifference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getBoundaryDimension(self, ) -> Union[int, JInt]: ...
	def touches(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def toCurvedText(self, ) -> javawrappers.java.lang.String: ...
	def getCoordinate(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def getPrecisionModel(self, ) -> javawrappers.org.locationtech.jts.geom.PrecisionModel: ...
	def isClosed(self, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def isRectangle(self, ) -> Union[int, JBoolean]: ...
	def clone(self, ) -> javawrappers.java.lang.Object: ...
	def getLength(self, ) -> Union[float, JDouble]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def getEnvelope(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getUserData(self, ) -> javawrappers.java.lang.Object: ...
	def toText(self, ) -> javawrappers.java.lang.String: ...
	def getArea(self, ) -> Union[float, JDouble]: ...


class LineIterator2:
	def __init__(self, ): ...
	def next(self, ) -> None: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def init(self, arg0: javawrappers.org.locationtech.jts.geom.LineString, arg1: javawrappers.java.awt.geom.AffineTransform, ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def getWindingRule(self, ) -> Union[int, JInt]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def currentSegment(self, arg0: JArray(Union[float, JDouble], 1), ) -> Union[int, JInt]: ...
	@overload
	def currentSegment(self, arg0: JArray(Union[float, JFloat], 1), ) -> Union[int, JInt]: ...
	def isDone(self, ) -> Union[int, JBoolean]: ...
	def notify(self, ) -> None: ...


class GeomCollectionIterator:
	@overload
	def __init__(self, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryCollection, arg1: javawrappers.java.awt.geom.AffineTransform, arg2: Union[int, JBoolean], arg3: Union[float, JDouble], ): ...
	def next(self, ) -> None: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def init(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryCollection, arg1: javawrappers.java.awt.geom.AffineTransform, arg2: Union[int, JBoolean], arg3: Union[float, JDouble], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def notifyAll(self, ) -> None: ...
	def getMaxDistance(self, ) -> Union[float, JDouble]: ...
	def isDone(self, ) -> Union[int, JBoolean]: ...
	def notify(self, ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def getWindingRule(self, ) -> Union[int, JInt]: ...
	def setMaxDistance(self, arg0: Union[float, JDouble], ) -> None: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def currentSegment(self, arg0: JArray(Union[float, JDouble], 1), ) -> Union[int, JInt]: ...
	@overload
	def currentSegment(self, arg0: JArray(Union[float, JFloat], 1), ) -> Union[int, JInt]: ...


class CircularString:
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, arg1: javawrappers.org.locationtech.jts.geom.GeometryFactory, arg2: Union[float, JDouble], ): ...
	@overload
	def __init__(self, arg0: JArray(Union[float, JDouble], 1), arg1: javawrappers.org.locationtech.jts.geom.GeometryFactory, arg2: Union[float, JDouble], ): ...
	class ArcScan:
		def __init__(self, arg0: javawrappers.org.geotools.geometry.jts.CircularString, ): ...
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def notify(self, ) -> None: ...


	def getGeometryN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def equalsNorm(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def linearize(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	@overload
	def linearize(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def linearize(self, ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	@overload
	def linearize(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def isCoordinate(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	def equalsTopo(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def coveredBy(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def geometryChanged(self, ) -> None: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.org.locationtech.jts.geom.CoordinateSequenceComparator, ) -> Union[int, JInt]: ...
	def getEnvelopeInternal(self, ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...
	def crosses(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def norm(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.java.lang.String, ) -> Union[int, JBoolean]: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.IntersectionMatrix: ...
	def getSRID(self, ) -> Union[int, JInt]: ...
	def disjoint(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def normalize(self, ) -> None: ...
	def intersection(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getDimension(self, ) -> Union[int, JInt]: ...
	def overlaps(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def isSimple(self, ) -> Union[int, JBoolean]: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getCoordinateSequence(self, ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getLinearizedCoordinateSequence(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	def getCentroid(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def getCoordinates(self, ) -> JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1): ...
	def contains(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getEndPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def isWithinDistance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getNumGeometries(self, ) -> Union[int, JInt]: ...
	def getPointN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def difference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def setUserData(self, arg0: javawrappers.java.lang.Object, ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def distance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[float, JDouble]: ...
	def getNumPoints(self, ) -> Union[int, JInt]: ...
	def intersects(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getControlPoints(self, ) -> JArray(Union[float, JDouble], 1): ...
	def notifyAll(self, ) -> None: ...
	def getCoordinateN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def notify(self, ) -> None: ...
	def getArcN(self, arg0: Union[int, JInt], ) -> javawrappers.org.geotools.geometry.jts.CircularArc: ...
	def getNumArcs(self, ) -> Union[int, JInt]: ...
	def isRing(self, ) -> Union[int, JBoolean]: ...
	def setSRID(self, arg0: Union[int, JInt], ) -> None: ...
	def getInteriorPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	@overload
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def hashCode(self, ) -> Union[int, JInt]: ...
	def getTolerance(self, ) -> Union[float, JDouble]: ...
	def getCoordinatesDimension(self, ) -> Union[int, JInt]: ...
	def copy(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def convexHull(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def covers(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getStartPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryComponentFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequenceFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryFilter, ) -> None: ...
	def within(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getBoundary(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def isValid(self, ) -> Union[int, JBoolean]: ...
	def getGeometryType(self, ) -> javawrappers.java.lang.String: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	@overload
	def union(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def union(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def reverse(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getFactory(self, ) -> javawrappers.org.locationtech.jts.geom.GeometryFactory: ...
	def symDifference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getBoundaryDimension(self, ) -> Union[int, JInt]: ...
	def touches(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def toCurvedText(self, ) -> javawrappers.java.lang.String: ...
	def getCoordinate(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def getPrecisionModel(self, ) -> javawrappers.org.locationtech.jts.geom.PrecisionModel: ...
	def isClosed(self, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def isRectangle(self, ) -> Union[int, JBoolean]: ...
	def clone(self, ) -> javawrappers.java.lang.Object: ...
	def getLength(self, ) -> Union[float, JDouble]: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def getEnvelope(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getUserData(self, ) -> javawrappers.java.lang.Object: ...
	def toText(self, ) -> javawrappers.java.lang.String: ...
	def getArea(self, ) -> Union[float, JDouble]: ...


class CurvedRing:
	def toCurvedText(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def linearize(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def linearize(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getTolerance(self, ) -> Union[float, JDouble]: ...
	def getCoordinatesDimension(self, ) -> Union[int, JInt]: ...


class TransformedShape:
	@overload
	def __init__(self, arg0: javawrappers.java.awt.Shape, arg1: javawrappers.java.awt.geom.AffineTransform, ): ...
	@overload
	def __init__(self, ): ...
	def setToIdentity(self, ) -> None: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def rotate(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> None: ...
	@overload
	def rotate(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], ) -> None: ...
	@overload
	def rotate(self, arg0: Union[float, JDouble], ) -> None: ...
	@overload
	def rotate(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def concatenate(self, arg0: javawrappers.java.awt.geom.AffineTransform, ) -> None: ...
	def preConcatenate(self, arg0: javawrappers.java.awt.geom.AffineTransform, ) -> None: ...
	@overload
	def intersects(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def intersects(self, arg0: javawrappers.java.awt.geom.Rectangle2D, ) -> Union[int, JBoolean]: ...
	def notifyAll(self, ) -> None: ...
	@overload
	def scale(self, arg0: Union[float, JDouble], ) -> None: ...
	@overload
	def scale(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> None: ...
	@staticmethod
	def getScaleInstance(arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> javawrappers.java.awt.geom.AffineTransform: ...
	@overload
	@staticmethod
	def getRotateInstance(arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> javawrappers.java.awt.geom.AffineTransform: ...
	@overload
	@staticmethod
	def getRotateInstance(arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], ) -> javawrappers.java.awt.geom.AffineTransform: ...
	@overload
	@staticmethod
	def getRotateInstance(arg0: Union[float, JDouble], ) -> javawrappers.java.awt.geom.AffineTransform: ...
	@overload
	@staticmethod
	def getRotateInstance(arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], ) -> javawrappers.java.awt.geom.AffineTransform: ...
	def notify(self, ) -> None: ...
	def translate(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> None: ...
	def getBounds(self, ) -> javawrappers.java.awt.Rectangle: ...
	@overload
	def setToQuadrantRotation(self, arg0: Union[int, JInt], arg1: Union[float, JDouble], arg2: Union[float, JDouble], ) -> None: ...
	@overload
	def setToQuadrantRotation(self, arg0: Union[int, JInt], ) -> None: ...
	@overload
	def setToRotation(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> None: ...
	@overload
	def setToRotation(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], ) -> None: ...
	@overload
	def setToRotation(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], ) -> None: ...
	@overload
	def setToRotation(self, arg0: Union[float, JDouble], ) -> None: ...
	@overload
	def transform(self, arg0: javawrappers.java.awt.geom.Point2D, arg1: javawrappers.java.awt.geom.Point2D, ) -> javawrappers.java.awt.geom.Point2D: ...
	@overload
	def transform(self, arg0: JArray(javawrappers.java.awt.geom.Point2D, 1), arg1: Union[int, JInt], arg2: JArray(javawrappers.java.awt.geom.Point2D, 1), arg3: Union[int, JInt], arg4: Union[int, JInt], ) -> None: ...
	@overload
	def transform(self, arg0: JArray(Union[float, JFloat], 1), arg1: Union[int, JInt], arg2: JArray(Union[float, JFloat], 1), arg3: Union[int, JInt], arg4: Union[int, JInt], ) -> None: ...
	@overload
	def transform(self, arg0: JArray(Union[float, JDouble], 1), arg1: Union[int, JInt], arg2: JArray(Union[float, JDouble], 1), arg3: Union[int, JInt], arg4: Union[int, JInt], ) -> None: ...
	@overload
	def transform(self, arg0: JArray(Union[float, JFloat], 1), arg1: Union[int, JInt], arg2: JArray(Union[float, JDouble], 1), arg3: Union[int, JInt], arg4: Union[int, JInt], ) -> None: ...
	@overload
	def transform(self, arg0: JArray(Union[float, JDouble], 1), arg1: Union[int, JInt], arg2: JArray(Union[float, JFloat], 1), arg3: Union[int, JInt], arg4: Union[int, JInt], ) -> None: ...
	@overload
	def getMatrix(self, arg0: JArray(Union[float, JFloat], 1), arg1: Union[int, JInt], ) -> None: ...
	@overload
	def getMatrix(self, arg0: JArray(Union[float, JDouble], 1), ) -> None: ...
	@overload
	def quadrantRotate(self, arg0: Union[int, JInt], arg1: Union[float, JDouble], arg2: Union[float, JDouble], ) -> None: ...
	@overload
	def quadrantRotate(self, arg0: Union[int, JInt], ) -> None: ...
	@overload
	def getPathIterator(self, arg0: javawrappers.java.awt.geom.AffineTransform, arg1: Union[float, JDouble], ) -> javawrappers.java.awt.geom.PathIterator: ...
	@overload
	def getPathIterator(self, arg0: javawrappers.java.awt.geom.AffineTransform, ) -> javawrappers.java.awt.geom.PathIterator: ...
	@overload
	def setTransform(self, arg0: javawrappers.java.awt.geom.AffineTransform, ) -> None: ...
	@overload
	def setTransform(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], arg4: Union[float, JDouble], arg5: Union[float, JDouble], ) -> None: ...
	@overload
	def setTransform(self, arg0: JArray(Union[float, JDouble], 1), ) -> None: ...
	@overload
	def setTransform(self, arg0: JArray(Union[float, JFloat], 1), arg1: Union[int, JInt], ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def inverseTransform(self, arg0: javawrappers.java.awt.geom.Point2D, arg1: javawrappers.java.awt.geom.Point2D, ) -> javawrappers.java.awt.geom.Point2D: ...
	@overload
	def inverseTransform(self, arg0: JArray(Union[float, JDouble], 1), arg1: Union[int, JInt], arg2: JArray(Union[float, JDouble], 1), arg3: Union[int, JInt], arg4: Union[int, JInt], ) -> None: ...
	def setToShear(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> None: ...
	def getTranslateY(self, ) -> Union[float, JDouble]: ...
	def getTranslateX(self, ) -> Union[float, JDouble]: ...
	def getDeterminant(self, ) -> Union[float, JDouble]: ...
	def invert(self, ) -> None: ...
	def shear(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> None: ...
	@overload
	@staticmethod
	def getQuadrantRotateInstance(arg0: Union[int, JInt], ) -> javawrappers.java.awt.geom.AffineTransform: ...
	@overload
	@staticmethod
	def getQuadrantRotateInstance(arg0: Union[int, JInt], arg1: Union[float, JDouble], arg2: Union[float, JDouble], ) -> javawrappers.java.awt.geom.AffineTransform: ...
	def isIdentity(self, ) -> Union[int, JBoolean]: ...
	def createTransformedShape(self, arg0: javawrappers.java.awt.Shape, ) -> javawrappers.java.awt.Shape: ...
	def createInverse(self, ) -> javawrappers.java.awt.geom.AffineTransform: ...
	def getScaleY(self, ) -> Union[float, JDouble]: ...
	def getShearX(self, ) -> Union[float, JDouble]: ...
	def getScaleX(self, ) -> Union[float, JDouble]: ...
	@staticmethod
	def getTranslateInstance(arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> javawrappers.java.awt.geom.AffineTransform: ...
	@overload
	def contains(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def contains(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def contains(self, arg0: javawrappers.java.awt.geom.Point2D, ) -> Union[int, JBoolean]: ...
	@overload
	def contains(self, arg0: javawrappers.java.awt.geom.Rectangle2D, ) -> Union[int, JBoolean]: ...
	def getShearY(self, ) -> Union[float, JDouble]: ...
	def getType(self, ) -> Union[int, JInt]: ...
	def setToScale(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def clone(self, ) -> javawrappers.java.lang.Object: ...
	def getBounds2D(self, ) -> javawrappers.java.awt.geom.Rectangle2D: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def setToTranslation(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> None: ...
	@overload
	def deltaTransform(self, arg0: JArray(Union[float, JDouble], 1), arg1: Union[int, JInt], arg2: JArray(Union[float, JDouble], 1), arg3: Union[int, JInt], arg4: Union[int, JInt], ) -> None: ...
	@overload
	def deltaTransform(self, arg0: javawrappers.java.awt.geom.Point2D, arg1: javawrappers.java.awt.geom.Point2D, ) -> javawrappers.java.awt.geom.Point2D: ...
	@staticmethod
	def getShearInstance(arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> javawrappers.java.awt.geom.AffineTransform: ...


class MultiCurve:
	def __init__(self, arg0: javawrappers.java.util.List, arg1: javawrappers.org.locationtech.jts.geom.GeometryFactory, arg2: Union[float, JDouble], ): ...
	def getGeometryN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def equalsNorm(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def linearize(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def linearize(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.MultiLineString: ...
	@overload
	def linearize(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def linearize(self, ) -> javawrappers.org.locationtech.jts.geom.MultiLineString: ...
	def equalsTopo(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def coveredBy(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def geometryChanged(self, ) -> None: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.org.locationtech.jts.geom.CoordinateSequenceComparator, ) -> Union[int, JInt]: ...
	def getEnvelopeInternal(self, ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...
	def crosses(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def norm(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.IntersectionMatrix: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.java.lang.String, ) -> Union[int, JBoolean]: ...
	def getSRID(self, ) -> Union[int, JInt]: ...
	def disjoint(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def intersection(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def normalize(self, ) -> None: ...
	def overlaps(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getDimension(self, ) -> Union[int, JInt]: ...
	def isSimple(self, ) -> Union[int, JBoolean]: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getCentroid(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def getCoordinates(self, ) -> JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1): ...
	def contains(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def isWithinDistance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getNumGeometries(self, ) -> Union[int, JInt]: ...
	def difference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def setUserData(self, arg0: javawrappers.java.lang.Object, ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def distance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[float, JDouble]: ...
	def getNumPoints(self, ) -> Union[int, JInt]: ...
	def intersects(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def notifyAll(self, ) -> None: ...
	def notify(self, ) -> None: ...
	def setSRID(self, arg0: Union[int, JInt], ) -> None: ...
	def getInteriorPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def getTolerance(self, ) -> Union[float, JDouble]: ...
	def getCoordinatesDimension(self, ) -> Union[int, JInt]: ...
	def copy(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def convexHull(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def covers(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def within(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryComponentFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequenceFilter, ) -> None: ...
	def getBoundary(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def isValid(self, ) -> Union[int, JBoolean]: ...
	def getGeometryType(self, ) -> javawrappers.java.lang.String: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	@overload
	def union(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def union(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getFactory(self, ) -> javawrappers.org.locationtech.jts.geom.GeometryFactory: ...
	def reverse(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def symDifference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getBoundaryDimension(self, ) -> Union[int, JInt]: ...
	def touches(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getCoordinate(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def toCurvedText(self, ) -> javawrappers.java.lang.String: ...
	def getPrecisionModel(self, ) -> javawrappers.org.locationtech.jts.geom.PrecisionModel: ...
	def isClosed(self, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def isRectangle(self, ) -> Union[int, JBoolean]: ...
	def clone(self, ) -> javawrappers.java.lang.Object: ...
	def getLength(self, ) -> Union[float, JDouble]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def getEnvelope(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getUserData(self, ) -> javawrappers.java.lang.Object: ...
	def toText(self, ) -> javawrappers.java.lang.String: ...
	def getArea(self, ) -> Union[float, JDouble]: ...


class PackedLineIterator:
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.LineString, arg1: javawrappers.java.awt.geom.AffineTransform, arg2: Union[int, JBoolean], arg3: Union[float, JFloat], ): ...
	def next(self, ) -> None: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def getWindingRule(self, ) -> Union[int, JInt]: ...
	def setMaxDistance(self, arg0: Union[float, JFloat], ) -> None: ...
	def getMaxDistance(self, ) -> Union[float, JDouble]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def currentSegment(self, arg0: JArray(Union[float, JFloat], 1), ) -> Union[int, JInt]: ...
	@overload
	def currentSegment(self, arg0: JArray(Union[float, JDouble], 1), ) -> Union[int, JInt]: ...
	def isDone(self, ) -> Union[int, JBoolean]: ...
	def notify(self, ) -> None: ...


class JTSFactoryFinder:
	class Registry:
		def __init__(self, ): ...
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def deregisterAll(self, ) -> None: ...
		@overload
		def deregisterAll(self, arg0: javawrappers.java.lang.Class, ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def unsetOrdering(self, arg0: javawrappers.java.lang.Class, arg1: javawrappers.java.lang.Object, arg2: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def notifyAll(self, ) -> None: ...
		def deregisterServiceProviders(self, arg0: javawrappers.java.util.Iterator, ) -> None: ...
		@overload
		def deregisterFactories(self, arg0: javawrappers.java.lang.Iterable, ) -> None: ...
		@overload
		def deregisterFactories(self, arg0: javawrappers.java.util.Iterator, ) -> None: ...
		@overload
		@staticmethod
		def lookupProviders(arg0: javawrappers.java.lang.Class, arg1: javawrappers.java.lang.ClassLoader, ) -> javawrappers.java.util.Iterator: ...
		@overload
		@staticmethod
		def lookupProviders(arg0: javawrappers.java.lang.Class, ) -> javawrappers.java.util.Iterator: ...
		@overload
		def registerFactories(self, arg0: javawrappers.java.util.Iterator, ) -> None: ...
		@overload
		def registerFactories(self, arg0: javawrappers.java.lang.Iterable, ) -> None: ...
		def getFactoryByClass(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.java.lang.Object: ...
		@overload
		def getServiceProviders(self, arg0: javawrappers.java.lang.Class, arg1: javawrappers.javax.imageio.spi.ServiceRegistry.Filter, arg2: javawrappers.org.geotools.factory.Hints, ) -> javawrappers.java.util.Iterator: ...
		@overload
		def getServiceProviders(self, arg0: javawrappers.java.lang.Class, arg1: javawrappers.javax.imageio.spi.ServiceRegistry.Filter, arg2: Union[int, JBoolean], ) -> javawrappers.java.util.Iterator: ...
		@overload
		def getServiceProviders(self, arg0: javawrappers.java.lang.Class, arg1: Union[int, JBoolean], ) -> javawrappers.java.util.Iterator: ...
		def streamCategories(self, ) -> javawrappers.java.util.stream.Stream: ...
		def notify(self, ) -> None: ...
		@overload
		def registerServiceProvider(self, arg0: javawrappers.java.lang.Object, ) -> None: ...
		@overload
		def registerServiceProvider(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Class, ) -> Union[int, JBoolean]: ...
		@overload
		def registerFactory(self, arg0: javawrappers.java.lang.Object, ) -> None: ...
		@overload
		def registerFactory(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Class, ) -> Union[int, JBoolean]: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		@overload
		def deregisterFactory(self, arg0: javawrappers.java.lang.Object, ) -> None: ...
		@overload
		def deregisterFactory(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Class, ) -> Union[int, JBoolean]: ...
		def getServiceProviderByClass(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.java.lang.Object: ...
		@overload
		def getFactories(self, arg0: javawrappers.java.lang.Class, arg1: javawrappers.java.util.function.Predicate, arg2: javawrappers.org.geotools.factory.Hints, ) -> javawrappers.java.util.stream.Stream: ...
		@overload
		def getFactories(self, arg0: javawrappers.java.lang.Class, arg1: Union[int, JBoolean], ) -> javawrappers.java.util.stream.Stream: ...
		@overload
		def getFactories(self, arg0: javawrappers.java.lang.Class, arg1: javawrappers.java.util.function.Predicate, arg2: Union[int, JBoolean], ) -> javawrappers.java.util.stream.Stream: ...
		def getFactory(self, arg0: javawrappers.java.lang.Class, arg1: javawrappers.java.util.function.Predicate, arg2: javawrappers.org.geotools.factory.Hints, arg3: javawrappers.org.geotools.factory.Hints.Key, ) -> javawrappers.java.lang.Object: ...
		@overload
		def deregisterServiceProvider(self, arg0: javawrappers.java.lang.Object, ) -> None: ...
		@overload
		def deregisterServiceProvider(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Class, ) -> None: ...
		def getServiceProvider(self, arg0: javawrappers.java.lang.Class, arg1: javawrappers.javax.imageio.spi.ServiceRegistry.Filter, arg2: javawrappers.org.geotools.factory.Hints, arg3: javawrappers.org.geotools.factory.Hints.Key, ) -> javawrappers.java.lang.Object: ...
		@overload
		def setOrdering(self, arg0: javawrappers.java.lang.Class, arg1: javawrappers.java.util.Comparator, ) -> Union[int, JBoolean]: ...
		@overload
		def setOrdering(self, arg0: javawrappers.java.lang.Class, arg1: javawrappers.java.lang.Object, arg2: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		@overload
		def setOrdering(self, arg0: javawrappers.java.lang.Class, arg1: Union[int, JBoolean], arg2: javawrappers.java.util.function.Predicate, arg3: javawrappers.java.util.function.Predicate, ) -> Union[int, JBoolean]: ...
		@overload
		def setOrdering(self, arg0: javawrappers.java.lang.Class, arg1: Union[int, JBoolean], arg2: javawrappers.javax.imageio.spi.ServiceRegistry.Filter, arg3: javawrappers.javax.imageio.spi.ServiceRegistry.Filter, ) -> Union[int, JBoolean]: ...
		def registerServiceProviders(self, arg0: javawrappers.java.util.Iterator, ) -> None: ...
		def scanForPlugins(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def getClassLoaders(self, ) -> javawrappers.java.util.Set: ...


	@overload
	def deregisterAll(self, ) -> None: ...
	@overload
	def deregisterAll(self, arg0: javawrappers.java.lang.Class, ) -> None: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def unsetOrdering(self, arg0: javawrappers.java.lang.Class, arg1: javawrappers.java.lang.Object, arg2: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def deregisterServiceProviders(self, arg0: javawrappers.java.util.Iterator, ) -> None: ...
	def notifyAll(self, ) -> None: ...
	@overload
	def deregisterFactories(self, arg0: javawrappers.java.lang.Iterable, ) -> None: ...
	@overload
	def deregisterFactories(self, arg0: javawrappers.java.util.Iterator, ) -> None: ...
	@overload
	@staticmethod
	def lookupProviders(arg0: javawrappers.java.lang.Class, arg1: javawrappers.java.lang.ClassLoader, ) -> javawrappers.java.util.Iterator: ...
	@overload
	@staticmethod
	def lookupProviders(arg0: javawrappers.java.lang.Class, ) -> javawrappers.java.util.Iterator: ...
	@overload
	def registerFactories(self, arg0: javawrappers.java.util.Iterator, ) -> None: ...
	@overload
	def registerFactories(self, arg0: javawrappers.java.lang.Iterable, ) -> None: ...
	def getFactoryByClass(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.java.lang.Object: ...
	@overload
	def getServiceProviders(self, arg0: javawrappers.java.lang.Class, arg1: javawrappers.javax.imageio.spi.ServiceRegistry.Filter, arg2: javawrappers.org.geotools.factory.Hints, ) -> javawrappers.java.util.Iterator: ...
	@overload
	def getServiceProviders(self, arg0: javawrappers.java.lang.Class, arg1: javawrappers.javax.imageio.spi.ServiceRegistry.Filter, arg2: Union[int, JBoolean], ) -> javawrappers.java.util.Iterator: ...
	@overload
	def getServiceProviders(self, arg0: javawrappers.java.lang.Class, arg1: Union[int, JBoolean], ) -> javawrappers.java.util.Iterator: ...
	def streamCategories(self, ) -> javawrappers.java.util.stream.Stream: ...
	@staticmethod
	def getCoordinateSequenceFactory(arg0: javawrappers.org.geotools.factory.Hints, ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequenceFactory: ...
	def notify(self, ) -> None: ...
	@overload
	def registerServiceProvider(self, arg0: javawrappers.java.lang.Object, ) -> None: ...
	@overload
	def registerServiceProvider(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Class, ) -> Union[int, JBoolean]: ...
	@overload
	def registerFactory(self, arg0: javawrappers.java.lang.Object, ) -> None: ...
	@overload
	def registerFactory(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Class, ) -> Union[int, JBoolean]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def deregisterFactory(self, arg0: javawrappers.java.lang.Object, ) -> None: ...
	@overload
	def deregisterFactory(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Class, ) -> Union[int, JBoolean]: ...
	def getServiceProviderByClass(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.java.lang.Object: ...
	@staticmethod
	def mergeSystemHints(arg0: javawrappers.org.geotools.factory.Hints, ) -> javawrappers.org.geotools.factory.Hints: ...
	@staticmethod
	def getGeometryFactories() -> javawrappers.java.util.Set: ...
	@overload
	def getFactories(self, arg0: javawrappers.java.lang.Class, arg1: javawrappers.java.util.function.Predicate, arg2: javawrappers.org.geotools.factory.Hints, ) -> javawrappers.java.util.stream.Stream: ...
	@overload
	def getFactories(self, arg0: javawrappers.java.lang.Class, arg1: Union[int, JBoolean], ) -> javawrappers.java.util.stream.Stream: ...
	@overload
	def getFactories(self, arg0: javawrappers.java.lang.Class, arg1: javawrappers.java.util.function.Predicate, arg2: Union[int, JBoolean], ) -> javawrappers.java.util.stream.Stream: ...
	@overload
	@staticmethod
	def getGeometryFactory() -> javawrappers.org.locationtech.jts.geom.GeometryFactory: ...
	@overload
	@staticmethod
	def getGeometryFactory(arg0: javawrappers.org.geotools.factory.Hints, ) -> javawrappers.org.locationtech.jts.geom.GeometryFactory: ...
	def getFactory(self, arg0: javawrappers.java.lang.Class, arg1: javawrappers.java.util.function.Predicate, arg2: javawrappers.org.geotools.factory.Hints, arg3: javawrappers.org.geotools.factory.Hints.Key, ) -> javawrappers.java.lang.Object: ...
	@overload
	def deregisterServiceProvider(self, arg0: javawrappers.java.lang.Object, ) -> None: ...
	@overload
	def deregisterServiceProvider(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Class, ) -> None: ...
	def getServiceProvider(self, arg0: javawrappers.java.lang.Class, arg1: javawrappers.javax.imageio.spi.ServiceRegistry.Filter, arg2: javawrappers.org.geotools.factory.Hints, arg3: javawrappers.org.geotools.factory.Hints.Key, ) -> javawrappers.java.lang.Object: ...
	@overload
	def setOrdering(self, arg0: javawrappers.java.lang.Class, arg1: javawrappers.java.util.Comparator, ) -> Union[int, JBoolean]: ...
	@overload
	def setOrdering(self, arg0: javawrappers.java.lang.Class, arg1: javawrappers.java.lang.Object, arg2: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def setOrdering(self, arg0: javawrappers.java.lang.Class, arg1: Union[int, JBoolean], arg2: javawrappers.java.util.function.Predicate, arg3: javawrappers.java.util.function.Predicate, ) -> Union[int, JBoolean]: ...
	@overload
	def setOrdering(self, arg0: javawrappers.java.lang.Class, arg1: Union[int, JBoolean], arg2: javawrappers.javax.imageio.spi.ServiceRegistry.Filter, arg3: javawrappers.javax.imageio.spi.ServiceRegistry.Filter, ) -> Union[int, JBoolean]: ...
	def registerServiceProviders(self, arg0: javawrappers.java.util.Iterator, ) -> None: ...
	@overload
	def scanForPlugins(self, ) -> None: ...
	@overload
	@staticmethod
	def scanForPlugins() -> None: ...
	@staticmethod
	def getPrecisionModel(arg0: javawrappers.org.geotools.factory.Hints, ) -> javawrappers.org.locationtech.jts.geom.PrecisionModel: ...
	@staticmethod
	def getCoordinateSequenceFactories() -> javawrappers.java.util.Set: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@staticmethod
	def getPrecisionModels() -> javawrappers.java.util.Set: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def getClassLoaders(self, ) -> javawrappers.java.util.Set: ...


class DefaultCoordinateSequenceTransformer:
	@overload
	def __init__(self, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequenceFactory, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def transform(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, arg1: javawrappers.org.opengis.referencing.operation.MathTransform, ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def notify(self, ) -> None: ...


class LiteCoordinateSequence:
	@overload
	def __init__(self, arg0: JArray(Union[float, JFloat], 1), ): ...
	@overload
	def __init__(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ): ...
	@overload
	def __init__(self, arg0: Union[int, JInt], arg1: Union[int, JInt], ): ...
	@overload
	def __init__(self, arg0: Union[int, JInt], arg1: Union[int, JInt], arg2: Union[int, JInt], ): ...
	@overload
	def __init__(self, arg0: JArray(Union[float, JFloat], 1), arg1: Union[int, JInt], ): ...
	@overload
	def __init__(self, *arg0: Union[float, JDouble], ): ...
	@overload
	def __init__(self, arg0: JArray(Union[float, JDouble], 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ): ...
	@overload
	def __init__(self, arg0: JArray(Union[float, JDouble], 1), arg1: Union[int, JInt], ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, arg1: Union[int, JInt], ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.geotools.geometry.jts.LiteCoordinateSequence, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def setY(self, arg0: Union[int, JInt], arg1: Union[float, JDouble], ) -> None: ...
	def hasM(self, ) -> Union[int, JBoolean]: ...
	def setX(self, arg0: Union[int, JInt], arg1: Union[float, JDouble], ) -> None: ...
	def getM(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	def notifyAll(self, ) -> None: ...
	def getArray(self, ) -> JArray(Union[float, JDouble], 1): ...
	def notify(self, ) -> None: ...
	def setOrdinate(self, arg0: Union[int, JInt], arg1: Union[int, JInt], arg2: Union[float, JDouble], ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def getDimension(self, ) -> Union[int, JInt]: ...
	@overload
	@staticmethod
	def cloneGeometry(arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	@staticmethod
	def cloneGeometry(arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getOrdinateArray(self, arg0: Union[int, JInt], ) -> JArray(Union[float, JDouble], 1): ...
	def expandEnvelope(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...
	def toCoordinateArray(self, ) -> JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1): ...
	@overload
	def copy(self, ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	@overload
	def copy(self, ) -> javawrappers.org.locationtech.jts.geom.impl.PackedCoordinateSequence: ...
	def getOrdinate(self, arg0: Union[int, JInt], arg1: Union[int, JInt], ) -> Union[float, JDouble]: ...
	def getXYArray(self, ) -> JArray(Union[float, JDouble], 1): ...
	def getCoordinateCopy(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def getMeasures(self, ) -> Union[int, JInt]: ...
	def getCoordinateInternal(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	@overload
	def setArray(self, arg0: JArray(Union[float, JDouble], 1), ) -> None: ...
	@overload
	def setArray(self, arg0: JArray(Union[float, JDouble], 1), arg1: Union[int, JInt], ) -> None: ...
	def hasZ(self, ) -> Union[int, JBoolean]: ...
	@overload
	def getCoordinate(self, arg0: Union[int, JInt], arg1: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> None: ...
	@overload
	def getCoordinate(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def getX(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	def getY(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	def getZ(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	def size(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def clone(self, ) -> javawrappers.java.lang.Object: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def createCoordinate(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...


class GeometryCollector:
	def __init__(self, ): ...
	def add(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> None: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def setFactory(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryFactory, ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def getMaxCoordinates(self, ) -> Union[long, JLong]: ...
	def notifyAll(self, ) -> None: ...
	def getFactory(self, ) -> javawrappers.org.locationtech.jts.geom.GeometryFactory: ...
	def notify(self, ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def collect(self, ) -> javawrappers.org.locationtech.jts.geom.GeometryCollection: ...
	def collectInternal(self, ) -> javawrappers.org.locationtech.jts.geom.GeometryCollection: ...
	def setMaxCoordinates(self, arg0: Union[long, JLong], ) -> None: ...


class CoordinateSequenceTransformer:
	def transform(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, arg1: javawrappers.org.opengis.referencing.operation.MathTransform, ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...


class WKTReader2:
	@overload
	def __init__(self, arg0: Union[float, JDouble], ): ...
	@overload
	def __init__(self, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryFactory, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@overload
	def read(self, arg0: javawrappers.java.lang.String, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def read(self, arg0: javawrappers.java.io.Reader, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def setIsOldJtsCoordinateSyntaxAllowed(self, arg0: Union[int, JBoolean], ) -> None: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def setIsOldJtsMultiPointSyntaxAllowed(self, arg0: Union[int, JBoolean], ) -> None: ...
	def notify(self, ) -> None: ...


class Decimator:
	@overload
	def __init__(self, arg0: javawrappers.org.opengis.referencing.operation.MathTransform, arg1: javawrappers.java.awt.Rectangle, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.opengis.referencing.operation.MathTransform, ): ...
	@overload
	def __init__(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.opengis.referencing.operation.MathTransform, arg1: javawrappers.java.awt.Rectangle, arg2: Union[float, JDouble], ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def decimate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> None: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def decimateTransformGeneralize(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.org.opengis.referencing.operation.MathTransform, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@staticmethod
	def computeGeneralizationDistances(arg0: javawrappers.org.opengis.referencing.operation.MathTransform, arg1: javawrappers.java.awt.Rectangle, arg2: Union[float, JDouble], ) -> JArray(Union[float, JDouble], 1): ...
	def notify(self, ) -> None: ...
	def getSpanX(self, ) -> Union[float, JDouble]: ...
	def getSpanY(self, ) -> Union[float, JDouble]: ...


class EmptyIterator:
	def __init__(self, ): ...
	def next(self, ) -> None: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def getWindingRule(self, ) -> Union[int, JInt]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def currentSegment(self, arg0: JArray(Union[float, JDouble], 1), ) -> Union[int, JInt]: ...
	@overload
	def currentSegment(self, arg0: JArray(Union[float, JFloat], 1), ) -> Union[int, JInt]: ...
	def isDone(self, ) -> Union[int, JBoolean]: ...
	def notify(self, ) -> None: ...


class GeometryCoordinateSequenceTransformer:
	@overload
	def __init__(self, arg0: javawrappers.org.geotools.geometry.jts.CoordinateSequenceTransformer, ): ...
	@overload
	def __init__(self, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def transformLineString(self, arg0: javawrappers.org.locationtech.jts.geom.LineString, arg1: javawrappers.org.locationtech.jts.geom.GeometryFactory, ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def transform(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def setMathTransform(self, arg0: javawrappers.org.opengis.referencing.operation.MathTransform, ) -> None: ...
	def setCoordinateReferenceSystem(self, arg0: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def transformPolygon(self, arg0: javawrappers.org.locationtech.jts.geom.Polygon, arg1: javawrappers.org.locationtech.jts.geom.GeometryFactory, ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	def transformPoint(self, arg0: javawrappers.org.locationtech.jts.geom.Point, arg1: javawrappers.org.locationtech.jts.geom.GeometryFactory, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def notify(self, ) -> None: ...


class MultiSurface:
	@overload
	def __init__(self, arg0: javawrappers.java.util.List, arg1: javawrappers.org.locationtech.jts.geom.GeometryFactory, arg2: Union[float, JDouble], ): ...
	@overload
	def __init__(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Polygon, 1), arg1: javawrappers.org.locationtech.jts.geom.GeometryFactory, arg2: Union[float, JDouble], ): ...
	def getGeometryN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def equalsNorm(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def linearize(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def linearize(self, ) -> javawrappers.org.locationtech.jts.geom.MultiPolygon: ...
	@overload
	def linearize(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.MultiPolygon: ...
	@overload
	def linearize(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def equalsTopo(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def coveredBy(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def geometryChanged(self, ) -> None: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.org.locationtech.jts.geom.CoordinateSequenceComparator, ) -> Union[int, JInt]: ...
	def getEnvelopeInternal(self, ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...
	def crosses(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def norm(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.IntersectionMatrix: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.java.lang.String, ) -> Union[int, JBoolean]: ...
	def getSRID(self, ) -> Union[int, JInt]: ...
	def disjoint(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def intersection(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def normalize(self, ) -> None: ...
	def overlaps(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getDimension(self, ) -> Union[int, JInt]: ...
	def isSimple(self, ) -> Union[int, JBoolean]: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getCentroid(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def getCoordinates(self, ) -> JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1): ...
	def contains(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def isWithinDistance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getNumGeometries(self, ) -> Union[int, JInt]: ...
	def difference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def setUserData(self, arg0: javawrappers.java.lang.Object, ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def distance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[float, JDouble]: ...
	def getNumPoints(self, ) -> Union[int, JInt]: ...
	def intersects(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def notifyAll(self, ) -> None: ...
	def notify(self, ) -> None: ...
	def setSRID(self, arg0: Union[int, JInt], ) -> None: ...
	def getInteriorPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def getTolerance(self, ) -> Union[float, JDouble]: ...
	def getCoordinatesDimension(self, ) -> Union[int, JInt]: ...
	def copy(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def convexHull(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def covers(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def copyInternal(self, ) -> javawrappers.org.locationtech.jts.geom.GeometryCollection: ...
	@overload
	def copyInternal(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def copyInternal(self, ) -> javawrappers.org.locationtech.jts.geom.MultiPolygon: ...
	@overload
	def copyInternal(self, ) -> javawrappers.org.geotools.geometry.jts.MultiSurface: ...
	def within(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryComponentFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequenceFilter, ) -> None: ...
	def getBoundary(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def isValid(self, ) -> Union[int, JBoolean]: ...
	def getGeometryType(self, ) -> javawrappers.java.lang.String: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	@overload
	def union(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def union(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getFactory(self, ) -> javawrappers.org.locationtech.jts.geom.GeometryFactory: ...
	def reverse(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def symDifference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getBoundaryDimension(self, ) -> Union[int, JInt]: ...
	def touches(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getCoordinate(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def toCurvedText(self, ) -> javawrappers.java.lang.String: ...
	def getPrecisionModel(self, ) -> javawrappers.org.locationtech.jts.geom.PrecisionModel: ...
	@overload
	def equals(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def isRectangle(self, ) -> Union[int, JBoolean]: ...
	def clone(self, ) -> javawrappers.java.lang.Object: ...
	def getLength(self, ) -> Union[float, JDouble]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def getEnvelope(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getUserData(self, ) -> javawrappers.java.lang.Object: ...
	def toText(self, ) -> javawrappers.java.lang.String: ...
	def getArea(self, ) -> Union[float, JDouble]: ...


class LiteCoordinateSequenceFactory:
	def __init__(self, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def create(self, arg0: JArray(Union[float, JDouble], 1), ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	@overload
	def create(self, arg0: Union[int, JInt], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	@overload
	def create(self, arg0: JArray(Union[float, JDouble], 1), arg1: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	@overload
	def create(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	@overload
	def create(self, arg0: Union[int, JInt], arg1: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	@overload
	def create(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@staticmethod
	def lite(arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, ) -> javawrappers.org.geotools.geometry.jts.LiteCoordinateSequence: ...
	def notify(self, ) -> None: ...


class JTS:
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@staticmethod
	def toDirectPosition(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ) -> javawrappers.org.opengis.geometry.DirectPosition: ...
	@overload
	@staticmethod
	def toEnvelope(arg0: javawrappers.java.awt.geom.Rectangle2D, ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...
	@overload
	@staticmethod
	def toEnvelope(arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	@staticmethod
	def getEnvelope2D(arg0: javawrappers.org.locationtech.jts.geom.Envelope, arg1: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ) -> javawrappers.org.geotools.geometry.Envelope2D: ...
	def notifyAll(self, ) -> None: ...
	@overload
	@staticmethod
	def toGeographic(arg0: javawrappers.org.locationtech.jts.geom.Envelope, arg1: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...
	@overload
	@staticmethod
	def toGeographic(arg0: javawrappers.org.geotools.geometry.jts.ReferencedEnvelope, ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	@overload
	@staticmethod
	def toGeographic(arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def notify(self, ) -> None: ...
	@overload
	@staticmethod
	def transform(arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.org.opengis.referencing.operation.MathTransform, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	@staticmethod
	def transform(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, arg2: javawrappers.org.opengis.referencing.operation.MathTransform, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	@overload
	@staticmethod
	def transform(arg0: javawrappers.org.locationtech.jts.geom.Envelope, arg1: javawrappers.org.locationtech.jts.geom.Envelope, arg2: javawrappers.org.opengis.referencing.operation.MathTransform, arg3: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...
	@overload
	@staticmethod
	def transform(arg0: javawrappers.org.locationtech.jts.geom.Envelope, arg1: javawrappers.org.opengis.referencing.operation.MathTransform, ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...
	@staticmethod
	def transformTo3D(arg0: javawrappers.org.geotools.geometry.jts.ReferencedEnvelope, arg1: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, arg2: Union[int, JBoolean], arg3: Union[int, JInt], ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope3D: ...
	@overload
	@staticmethod
	def toPolygon(arg0: javawrappers.java.awt.Polygon, ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	@overload
	@staticmethod
	def toPolygon(arg0: javawrappers.java.awt.geom.Rectangle2D, ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	@overload
	@staticmethod
	def toPolygon(arg0: javawrappers.java.awt.Rectangle, ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	@staticmethod
	def toGeometry(arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	@overload
	@staticmethod
	def toGeometry(arg0: javawrappers.org.opengis.geometry.DirectPosition, arg1: javawrappers.org.locationtech.jts.geom.GeometryFactory, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	@overload
	@staticmethod
	def toGeometry(arg0: javawrappers.org.opengis.geometry.DirectPosition, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	@overload
	@staticmethod
	def toGeometry(arg0: javawrappers.java.awt.Shape, arg1: javawrappers.org.locationtech.jts.geom.GeometryFactory, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	@staticmethod
	def toGeometry(arg0: javawrappers.java.awt.Shape, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	@staticmethod
	def toGeometry(arg0: javawrappers.org.opengis.geometry.BoundingBox, arg1: javawrappers.org.locationtech.jts.geom.GeometryFactory, ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	@overload
	@staticmethod
	def toGeometry(arg0: javawrappers.org.opengis.geometry.BoundingBox, ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	@overload
	@staticmethod
	def toGeometry(arg0: javawrappers.org.geotools.geometry.jts.ReferencedEnvelope, ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	@overload
	@staticmethod
	def toGeometry(arg0: javawrappers.org.locationtech.jts.geom.Envelope, arg1: javawrappers.org.locationtech.jts.geom.GeometryFactory, ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	@overload
	@staticmethod
	def toGeometry(arg0: javawrappers.org.opengis.geometry.BoundingBox, arg1: javawrappers.org.locationtech.jts.geom.GeometryFactory, arg2: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	@staticmethod
	def copy(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: JArray(Union[float, JDouble], 1), ) -> None: ...
	@staticmethod
	def makeValid(arg0: javawrappers.org.locationtech.jts.geom.Polygon, arg1: Union[int, JBoolean], ) -> javawrappers.java.util.List: ...
	@overload
	@staticmethod
	def removeCollinearVertices(arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	@staticmethod
	def removeCollinearVertices(arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	@staticmethod
	def smooth(arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	@staticmethod
	def smooth(arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], arg2: javawrappers.org.locationtech.jts.geom.GeometryFactory, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@staticmethod
	def shapeToGeometry(arg0: javawrappers.java.awt.Shape, arg1: javawrappers.org.locationtech.jts.geom.GeometryFactory, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@staticmethod
	def toRectangle2D(arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> javawrappers.java.awt.geom.Rectangle2D: ...
	@staticmethod
	def orthodromicDistance(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, arg2: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ) -> Union[float, JDouble]: ...
	@overload
	@staticmethod
	def createCS(arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequenceFactory, arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	@overload
	@staticmethod
	def createCS(arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequenceFactory, arg1: Union[int, JInt], arg2: Union[int, JInt], arg3: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	@staticmethod
	def transformTo2D(arg0: javawrappers.org.geotools.geometry.jts.ReferencedEnvelope, arg1: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, arg2: Union[int, JBoolean], arg3: Union[int, JInt], ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@staticmethod
	def xform(arg0: javawrappers.org.opengis.referencing.operation.MathTransform, arg1: JArray(Union[float, JDouble], 1), arg2: JArray(Union[float, JDouble], 1), ) -> None: ...
	@staticmethod
	def bounds(arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ) -> javawrappers.org.geotools.geometry.jts.ReferencedEnvelope: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@staticmethod
	def checkCoordinatesRange(arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.org.opengis.referencing.crs.CoordinateReferenceSystem, ) -> None: ...


class GeometryClipper:
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def notify(self, ) -> None: ...
	def getBounds(self, ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...
	def clip(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[int, JBoolean], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def clipSafe(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[int, JBoolean], arg2: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...


class AbstractLiteIterator:
	def __init__(self, ): ...
	def next(self, ) -> None: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def getWindingRule(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def currentSegment(self, arg0: JArray(Union[float, JDouble], 1), ) -> Union[int, JInt]: ...
	@overload
	def currentSegment(self, arg0: JArray(Union[float, JFloat], 1), ) -> Union[int, JInt]: ...
	def isDone(self, ) -> Union[int, JBoolean]: ...
	def notify(self, ) -> None: ...


class GeometryBuilder:
	@overload
	def __init__(self, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryFactory, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def boxZ(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], arg4: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@overload
	def linearRing(self, ) -> javawrappers.org.locationtech.jts.geom.LinearRing: ...
	@overload
	def linearRing(self, *arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.LinearRing: ...
	@overload
	def pointZ(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	@overload
	def pointZ(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def notifyAll(self, ) -> None: ...
	def multiPolygon(self, *arg0: javawrappers.org.locationtech.jts.geom.Polygon, ) -> javawrappers.org.locationtech.jts.geom.MultiPolygon: ...
	def box(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	def geometryCollection(self, *arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.GeometryCollection: ...
	def notify(self, ) -> None: ...
	@overload
	def point(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	@overload
	def point(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	@overload
	def point(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def multiPoint(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.MultiPoint: ...
	def multiLineString(self, *arg0: javawrappers.org.locationtech.jts.geom.LineString, ) -> javawrappers.org.locationtech.jts.geom.MultiLineString: ...
	def multiPointZ(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], arg4: Union[float, JDouble], arg5: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.MultiPoint: ...
	@overload
	def polygon(self, arg0: javawrappers.org.locationtech.jts.geom.LinearRing, arg1: javawrappers.org.locationtech.jts.geom.LinearRing, ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	@overload
	def polygon(self, arg0: javawrappers.org.locationtech.jts.geom.Polygon, arg1: javawrappers.org.locationtech.jts.geom.Polygon, ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	@overload
	def polygon(self, arg0: javawrappers.org.locationtech.jts.geom.LinearRing, ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	@overload
	def polygon(self, *arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	@overload
	def polygon(self, ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def linearRingZ(self, *arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.LinearRing: ...
	@overload
	def linearRingZ(self, ) -> javawrappers.org.locationtech.jts.geom.LinearRing: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def ellipse(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], arg4: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	@overload
	def lineString(self, ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	@overload
	def lineString(self, *arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	@overload
	def polygonZ(self, ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	@overload
	def polygonZ(self, *arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	def circle(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	@overload
	def lineStringZ(self, *arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	@overload
	def lineStringZ(self, ) -> javawrappers.org.locationtech.jts.geom.LineString: ...


class CompoundCurve:
	def __init__(self, arg0: javawrappers.java.util.List, arg1: javawrappers.org.locationtech.jts.geom.GeometryFactory, arg2: Union[float, JDouble], ): ...
	def getGeometryN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def equalsNorm(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def linearize(self, ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	@overload
	def linearize(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def linearize(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def linearize(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	def isCoordinate(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	def equalsTopo(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def coveredBy(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def geometryChanged(self, ) -> None: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.org.locationtech.jts.geom.CoordinateSequenceComparator, ) -> Union[int, JInt]: ...
	def getEnvelopeInternal(self, ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...
	def crosses(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def norm(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.java.lang.String, ) -> Union[int, JBoolean]: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.IntersectionMatrix: ...
	def getSRID(self, ) -> Union[int, JInt]: ...
	def disjoint(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def normalize(self, ) -> None: ...
	def intersection(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getDimension(self, ) -> Union[int, JInt]: ...
	def overlaps(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getComponents(self, ) -> javawrappers.java.util.List: ...
	def isSimple(self, ) -> Union[int, JBoolean]: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getCoordinateSequence(self, ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getCentroid(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def getCoordinates(self, ) -> JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1): ...
	def contains(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getEndPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def isWithinDistance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getNumGeometries(self, ) -> Union[int, JInt]: ...
	def getPointN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def difference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def setUserData(self, arg0: javawrappers.java.lang.Object, ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def distance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[float, JDouble]: ...
	def getNumPoints(self, ) -> Union[int, JInt]: ...
	def intersects(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def notifyAll(self, ) -> None: ...
	def getCoordinateN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def notify(self, ) -> None: ...
	def isRing(self, ) -> Union[int, JBoolean]: ...
	def setSRID(self, arg0: Union[int, JInt], ) -> None: ...
	def getInteriorPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def getTolerance(self, ) -> Union[float, JDouble]: ...
	def getCoordinatesDimension(self, ) -> Union[int, JInt]: ...
	def copy(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def convexHull(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def covers(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def copyInternal(self, ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	@overload
	def copyInternal(self, ) -> javawrappers.org.geotools.geometry.jts.CompoundCurve: ...
	@overload
	def copyInternal(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getStartPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryComponentFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequenceFilter, ) -> None: ...
	def within(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getBoundary(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def isValid(self, ) -> Union[int, JBoolean]: ...
	def getGeometryType(self, ) -> javawrappers.java.lang.String: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	@overload
	def union(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def union(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def reverse(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getFactory(self, ) -> javawrappers.org.locationtech.jts.geom.GeometryFactory: ...
	def symDifference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getBoundaryDimension(self, ) -> Union[int, JInt]: ...
	def touches(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def toCurvedText(self, ) -> javawrappers.java.lang.String: ...
	def getCoordinate(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def getPrecisionModel(self, ) -> javawrappers.org.locationtech.jts.geom.PrecisionModel: ...
	def isClosed(self, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def isRectangle(self, ) -> Union[int, JBoolean]: ...
	def clone(self, ) -> javawrappers.java.lang.Object: ...
	def getLength(self, ) -> Union[float, JDouble]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def getEnvelope(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getUserData(self, ) -> javawrappers.java.lang.Object: ...
	def toText(self, ) -> javawrappers.java.lang.String: ...
	def getArea(self, ) -> Union[float, JDouble]: ...


class Geometries:
	POINT: Geometries = ...
	LINESTRING: Geometries = ...
	POLYGON: Geometries = ...
	MULTIPOINT: Geometries = ...
	MULTILINESTRING: Geometries = ...
	MULTIPOLYGON: Geometries = ...
	GEOMETRY: Geometries = ...
	GEOMETRYCOLLECTION: Geometries = ...
	@staticmethod
	def getForName(arg0: javawrappers.java.lang.String, ) -> javawrappers.org.geotools.geometry.jts.Geometries: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def getName(self, ) -> javawrappers.java.lang.String: ...
	@overload
	@staticmethod
	def valueOf(arg0: javawrappers.java.lang.Class, arg1: javawrappers.java.lang.String, ) -> javawrappers.java.lang.Enum: ...
	@overload
	@staticmethod
	def valueOf(arg0: javawrappers.java.lang.String, ) -> javawrappers.org.geotools.geometry.jts.Geometries: ...
	def notifyAll(self, ) -> None: ...
	@staticmethod
	def values() -> JArray(javawrappers.org.geotools.geometry.jts.Geometries, 1): ...
	@staticmethod
	def getForBinding(arg0: javawrappers.java.lang.Class, ) -> javawrappers.org.geotools.geometry.jts.Geometries: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Enum, ) -> Union[int, JInt]: ...
	def notify(self, ) -> None: ...
	def getDeclaringClass(self, ) -> javawrappers.java.lang.Class: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def getBinding(self, ) -> javawrappers.java.lang.Class: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@staticmethod
	def get(arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.geotools.geometry.jts.Geometries: ...
	def name(self, ) -> javawrappers.java.lang.String: ...
	def getSimpleName(self, ) -> javawrappers.java.lang.String: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def getSQLType(self, ) -> javawrappers.java.lang.Integer: ...
	def ordinal(self, ) -> Union[int, JInt]: ...
	@staticmethod
	def getForSQLType(arg0: Union[int, JInt], ) -> javawrappers.org.geotools.geometry.jts.Geometries: ...


class CurvedGeometryFactory:
	@overload
	def __init__(self, arg0: Union[float, JDouble], ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryFactory, arg1: Union[float, JDouble], ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@overload
	def createMultiPoint(self, ) -> javawrappers.org.locationtech.jts.geom.MultiPoint: ...
	@overload
	def createMultiPoint(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, ) -> javawrappers.org.locationtech.jts.geom.MultiPoint: ...
	@overload
	def createMultiPoint(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Point, 1), ) -> javawrappers.org.locationtech.jts.geom.MultiPoint: ...
	@overload
	def createMultiPoint(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> javawrappers.org.locationtech.jts.geom.MultiPoint: ...
	def notifyAll(self, ) -> None: ...
	@staticmethod
	def toGeometryArray(arg0: javawrappers.java.util.Collection, ) -> JArray(javawrappers.org.locationtech.jts.geom.Geometry, 1): ...
	@staticmethod
	def toPointArray(arg0: javawrappers.java.util.Collection, ) -> JArray(javawrappers.org.locationtech.jts.geom.Point, 1): ...
	@staticmethod
	def toLineStringArray(arg0: javawrappers.java.util.Collection, ) -> JArray(javawrappers.org.locationtech.jts.geom.LineString, 1): ...
	def createGeometry(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def createPoint(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	@overload
	def createPoint(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	@overload
	def createPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	@staticmethod
	def toMultiPointArray(arg0: javawrappers.java.util.Collection, ) -> JArray(javawrappers.org.locationtech.jts.geom.MultiPoint, 1): ...
	def getCoordinateSequenceFactory(self, ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequenceFactory: ...
	def notify(self, ) -> None: ...
	@overload
	def createCircularString(self, arg0: Union[int, JInt], *arg1: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	@overload
	def createCircularString(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	def createMultiSurface(self, arg0: javawrappers.java.util.List, ) -> javawrappers.org.locationtech.jts.geom.MultiPolygon: ...
	def createMultiCurve(self, arg0: javawrappers.java.util.List, ) -> javawrappers.org.geotools.geometry.jts.MultiCurve: ...
	def getSRID(self, ) -> Union[int, JInt]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def createCurvedGeometry(self, *arg0: javawrappers.org.locationtech.jts.geom.LineString, ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	@overload
	def createCurvedGeometry(self, arg0: Union[int, JInt], *arg1: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	@overload
	def createCurvedGeometry(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	@overload
	def createCurvedGeometry(self, arg0: javawrappers.java.util.List, ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	def getTolerance(self, ) -> Union[float, JDouble]: ...
	def hasCurves(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def toGeometry(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def createMultiPolygon(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Polygon, 1), ) -> javawrappers.org.locationtech.jts.geom.MultiPolygon: ...
	@overload
	def createMultiPolygon(self, ) -> javawrappers.org.locationtech.jts.geom.MultiPolygon: ...
	@staticmethod
	def toMultiLineStringArray(arg0: javawrappers.java.util.Collection, ) -> JArray(javawrappers.org.locationtech.jts.geom.MultiLineString, 1): ...
	@staticmethod
	def createPointFromInternalCoord(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	@staticmethod
	def toPolygonArray(arg0: javawrappers.java.util.Collection, ) -> JArray(javawrappers.org.locationtech.jts.geom.Polygon, 1): ...
	@overload
	def createPolygon(self, arg0: javawrappers.org.locationtech.jts.geom.LinearRing, ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	@overload
	def createPolygon(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	@overload
	def createPolygon(self, arg0: javawrappers.org.locationtech.jts.geom.LinearRing, arg1: JArray(javawrappers.org.locationtech.jts.geom.LinearRing, 1), ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	@overload
	def createPolygon(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	@overload
	def createPolygon(self, ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	def createMultiPointFromCoords(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> javawrappers.org.locationtech.jts.geom.MultiPoint: ...
	@overload
	def createLineString(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	@overload
	def createLineString(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	@overload
	def createLineString(self, ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	@staticmethod
	def toMultiPolygonArray(arg0: javawrappers.java.util.Collection, ) -> JArray(javawrappers.org.locationtech.jts.geom.MultiPolygon, 1): ...
	def getPrecisionModel(self, ) -> javawrappers.org.locationtech.jts.geom.PrecisionModel: ...
	def createCurvePolygon(self, arg0: javawrappers.org.locationtech.jts.geom.LinearRing, arg1: JArray(javawrappers.org.locationtech.jts.geom.LinearRing, 1), ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def createLinearRing(self, ) -> javawrappers.org.locationtech.jts.geom.LinearRing: ...
	@overload
	def createLinearRing(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> javawrappers.org.locationtech.jts.geom.LinearRing: ...
	@overload
	def createLinearRing(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, ) -> javawrappers.org.locationtech.jts.geom.LinearRing: ...
	@overload
	def createMultiLineString(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.LineString, 1), ) -> javawrappers.org.locationtech.jts.geom.MultiLineString: ...
	@overload
	def createMultiLineString(self, ) -> javawrappers.org.locationtech.jts.geom.MultiLineString: ...
	@staticmethod
	def toLinearRingArray(arg0: javawrappers.java.util.Collection, ) -> JArray(javawrappers.org.locationtech.jts.geom.LinearRing, 1): ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def createGeometryCollection(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Geometry, 1), ) -> javawrappers.org.locationtech.jts.geom.GeometryCollection: ...
	@overload
	def createGeometryCollection(self, ) -> javawrappers.org.locationtech.jts.geom.GeometryCollection: ...
	def buildGeometry(self, arg0: javawrappers.java.util.Collection, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...


class LineIterator:
	@overload
	def __init__(self, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.LineString, arg1: javawrappers.java.awt.geom.AffineTransform, arg2: Union[int, JBoolean], arg3: Union[float, JFloat], ): ...
	def next(self, ) -> None: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def init(self, arg0: javawrappers.org.locationtech.jts.geom.LineString, arg1: javawrappers.java.awt.geom.AffineTransform, arg2: Union[int, JBoolean], arg3: Union[float, JFloat], arg4: Union[float, JFloat], arg5: Union[float, JFloat], ) -> None: ...
	@overload
	def init(self, arg0: javawrappers.org.locationtech.jts.geom.LineString, arg1: javawrappers.java.awt.geom.AffineTransform, arg2: Union[int, JBoolean], arg3: Union[float, JFloat], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def notifyAll(self, ) -> None: ...
	def getMaxDistance(self, ) -> Union[float, JDouble]: ...
	def isDone(self, ) -> Union[int, JBoolean]: ...
	def notify(self, ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def getWindingRule(self, ) -> Union[int, JInt]: ...
	def setMaxDistance(self, arg0: Union[float, JFloat], ) -> None: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def currentSegment(self, arg0: JArray(Union[float, JDouble], 1), ) -> Union[int, JInt]: ...
	@overload
	def currentSegment(self, arg0: JArray(Union[float, JFloat], 1), ) -> Union[int, JInt]: ...


class OffsetCurveBuilder:
	@overload
	def __init__(self, arg0: Union[float, JDouble], ): ...
	@overload
	def __init__(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def offset(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def notify(self, ) -> None: ...


class WKTWriter2:
	@overload
	def __init__(self, arg0: Union[int, JInt], ): ...
	@overload
	def __init__(self, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def setFormatted(self, arg0: Union[int, JBoolean], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def setMaxCoordinatesPerLine(self, arg0: Union[int, JInt], ) -> None: ...
	def setPrecisionModel(self, arg0: javawrappers.org.locationtech.jts.geom.PrecisionModel, ) -> None: ...
	def notifyAll(self, ) -> None: ...
	@overload
	def writeFormatted(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.java.lang.String: ...
	@overload
	def writeFormatted(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.java.io.Writer, ) -> None: ...
	@staticmethod
	def toPoint(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> javawrappers.java.lang.String: ...
	def notify(self, ) -> None: ...
	def setTab(self, arg0: Union[int, JInt], ) -> None: ...
	def getOutputOrdinates(self, ) -> javawrappers.java.util.EnumSet: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	@staticmethod
	def toLineString(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> javawrappers.java.lang.String: ...
	@overload
	@staticmethod
	def toLineString(arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, ) -> javawrappers.java.lang.String: ...
	@overload
	@staticmethod
	def toLineString(arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> javawrappers.java.lang.String: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def setOutputOrdinates(self, arg0: javawrappers.java.util.EnumSet, ) -> None: ...
	@overload
	def write(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.java.io.Writer, ) -> None: ...
	@overload
	def write(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.java.lang.String: ...
	@staticmethod
	def stringOfChar(arg0: Union[string, JString], arg1: Union[int, JInt], ) -> javawrappers.java.lang.String: ...


class CurvePolygon:
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.LinearRing, arg1: javawrappers.java.util.List, arg2: javawrappers.org.locationtech.jts.geom.GeometryFactory, arg3: Union[float, JDouble], ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.LinearRing, arg1: JArray(javawrappers.org.locationtech.jts.geom.LinearRing, 1), arg2: javawrappers.org.locationtech.jts.geom.GeometryFactory, arg3: Union[float, JDouble], ): ...
	def getGeometryN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def equalsNorm(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def linearize(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def linearize(self, ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	@overload
	def linearize(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def linearize(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	def equalsTopo(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def coveredBy(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def geometryChanged(self, ) -> None: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.org.locationtech.jts.geom.CoordinateSequenceComparator, ) -> Union[int, JInt]: ...
	def getExteriorRing(self, ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	def getEnvelopeInternal(self, ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...
	def crosses(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def norm(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.IntersectionMatrix: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.java.lang.String, ) -> Union[int, JBoolean]: ...
	def getSRID(self, ) -> Union[int, JInt]: ...
	def disjoint(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def intersection(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def normalize(self, ) -> None: ...
	def overlaps(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getDimension(self, ) -> Union[int, JInt]: ...
	def isSimple(self, ) -> Union[int, JBoolean]: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getCentroid(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def getCoordinates(self, ) -> JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1): ...
	def contains(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def isWithinDistance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getNumGeometries(self, ) -> Union[int, JInt]: ...
	def difference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def setUserData(self, arg0: javawrappers.java.lang.Object, ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def distance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[float, JDouble]: ...
	def getNumPoints(self, ) -> Union[int, JInt]: ...
	def intersects(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def notifyAll(self, ) -> None: ...
	def notify(self, ) -> None: ...
	def setSRID(self, arg0: Union[int, JInt], ) -> None: ...
	def getInteriorPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def getTolerance(self, ) -> Union[float, JDouble]: ...
	def getCoordinatesDimension(self, ) -> Union[int, JInt]: ...
	def copy(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def convexHull(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def covers(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def copyInternal(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def copyInternal(self, ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	@overload
	def copyInternal(self, ) -> javawrappers.org.geotools.geometry.jts.CurvePolygon: ...
	def within(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequenceFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryComponentFilter, ) -> None: ...
	def getBoundary(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def isValid(self, ) -> Union[int, JBoolean]: ...
	def getGeometryType(self, ) -> javawrappers.java.lang.String: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	@overload
	def union(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def union(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getInteriorRingN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	def getFactory(self, ) -> javawrappers.org.locationtech.jts.geom.GeometryFactory: ...
	def reverse(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def symDifference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getBoundaryDimension(self, ) -> Union[int, JInt]: ...
	def touches(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getCoordinate(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def toCurvedText(self, ) -> javawrappers.java.lang.String: ...
	def getPrecisionModel(self, ) -> javawrappers.org.locationtech.jts.geom.PrecisionModel: ...
	@overload
	def equals(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def isRectangle(self, ) -> Union[int, JBoolean]: ...
	def clone(self, ) -> javawrappers.java.lang.Object: ...
	def getLength(self, ) -> Union[float, JDouble]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def getEnvelope(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getUserData(self, ) -> javawrappers.java.lang.Object: ...
	def toText(self, ) -> javawrappers.java.lang.String: ...
	def getArea(self, ) -> Union[float, JDouble]: ...
	def getNumInteriorRing(self, ) -> Union[int, JInt]: ...


class CurvedGeometry:
	def toCurvedText(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def linearize(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def linearize(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getTolerance(self, ) -> Union[float, JDouble]: ...
	def getCoordinatesDimension(self, ) -> Union[int, JInt]: ...


class CurvedGeometries:
	def __init__(self, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@staticmethod
	def isCircle(arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@staticmethod
	def getArc(arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, arg1: Union[int, JInt], ) -> javawrappers.org.geotools.geometry.jts.CircularArc: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@staticmethod
	def toCircle(arg0: javawrappers.org.geotools.geometry.jts.CircularArc, arg1: javawrappers.org.locationtech.jts.geom.GeometryFactory, arg2: Union[float, JDouble], ) -> javawrappers.org.geotools.geometry.jts.CircularRing: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@staticmethod
	def getFactory(arg0: javawrappers.org.geotools.geometry.jts.CurvedGeometry, ) -> javawrappers.org.geotools.geometry.jts.CurvedGeometryFactory: ...
	@staticmethod
	def isCurved(arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def notify(self, ) -> None: ...


class LiteShape:
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.java.awt.geom.AffineTransform, arg2: Union[int, JBoolean], arg3: Union[float, JDouble], ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.java.awt.geom.AffineTransform, arg2: Union[int, JBoolean], ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@overload
	def intersects(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def intersects(self, arg0: javawrappers.java.awt.geom.Rectangle2D, ) -> Union[int, JBoolean]: ...
	def notifyAll(self, ) -> None: ...
	def getGeometry(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def notify(self, ) -> None: ...
	def getBounds(self, ) -> javawrappers.java.awt.Rectangle: ...
	def setGeometry(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> None: ...
	@overload
	def contains(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def contains(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def contains(self, arg0: javawrappers.java.awt.geom.Rectangle2D, ) -> Union[int, JBoolean]: ...
	@overload
	def contains(self, arg0: javawrappers.java.awt.geom.Point2D, ) -> Union[int, JBoolean]: ...
	def getAffineTransform(self, ) -> javawrappers.java.awt.geom.AffineTransform: ...
	@overload
	def getPathIterator(self, arg0: javawrappers.java.awt.geom.AffineTransform, arg1: Union[float, JDouble], ) -> javawrappers.java.awt.geom.PathIterator: ...
	@overload
	def getPathIterator(self, arg0: javawrappers.java.awt.geom.AffineTransform, ) -> javawrappers.java.awt.geom.PathIterator: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def getBounds2D(self, ) -> javawrappers.java.awt.geom.Rectangle2D: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...


class CircularRing:
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, arg1: javawrappers.org.locationtech.jts.geom.GeometryFactory, arg2: Union[float, JDouble], ): ...
	@overload
	def __init__(self, arg0: JArray(Union[float, JDouble], 1), arg1: javawrappers.org.locationtech.jts.geom.GeometryFactory, arg2: Union[float, JDouble], ): ...
	def getGeometryN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def equalsNorm(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def linearize(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def linearize(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.LinearRing: ...
	@overload
	def linearize(self, ) -> javawrappers.org.locationtech.jts.geom.LinearRing: ...
	@overload
	def linearize(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def isCoordinate(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	def equalsTopo(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def coveredBy(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def geometryChanged(self, ) -> None: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.org.locationtech.jts.geom.CoordinateSequenceComparator, ) -> Union[int, JInt]: ...
	def getEnvelopeInternal(self, ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...
	def crosses(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def norm(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.IntersectionMatrix: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.java.lang.String, ) -> Union[int, JBoolean]: ...
	def getSRID(self, ) -> Union[int, JInt]: ...
	def disjoint(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def normalize(self, ) -> None: ...
	def intersection(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getDimension(self, ) -> Union[int, JInt]: ...
	def overlaps(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def isSimple(self, ) -> Union[int, JBoolean]: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getCoordinateSequence(self, ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getLinearizedCoordinateSequence(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	def getCentroid(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def getCoordinates(self, ) -> JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1): ...
	def contains(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getEndPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def isWithinDistance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getNumGeometries(self, ) -> Union[int, JInt]: ...
	def getPointN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def difference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def setUserData(self, arg0: javawrappers.java.lang.Object, ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def distance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[float, JDouble]: ...
	def getNumPoints(self, ) -> Union[int, JInt]: ...
	def intersects(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getControlPoints(self, ) -> JArray(Union[float, JDouble], 1): ...
	def notifyAll(self, ) -> None: ...
	def getCoordinateN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def notify(self, ) -> None: ...
	def getArcN(self, arg0: Union[int, JInt], ) -> javawrappers.org.geotools.geometry.jts.CircularArc: ...
	def getNumArcs(self, ) -> Union[int, JInt]: ...
	def isRing(self, ) -> Union[int, JBoolean]: ...
	def setSRID(self, arg0: Union[int, JInt], ) -> None: ...
	def getInteriorPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def getTolerance(self, ) -> Union[float, JDouble]: ...
	def getCoordinatesDimension(self, ) -> Union[int, JInt]: ...
	def copy(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def convexHull(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def covers(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def copyInternal(self, ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	@overload
	def copyInternal(self, ) -> javawrappers.org.geotools.geometry.jts.CircularRing: ...
	@overload
	def copyInternal(self, ) -> javawrappers.org.locationtech.jts.geom.LinearRing: ...
	@overload
	def copyInternal(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getStartPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryComponentFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequenceFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateFilter, ) -> None: ...
	def within(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getBoundary(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def isValid(self, ) -> Union[int, JBoolean]: ...
	def getGeometryType(self, ) -> javawrappers.java.lang.String: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	@overload
	def union(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def union(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def reverse(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getFactory(self, ) -> javawrappers.org.locationtech.jts.geom.GeometryFactory: ...
	def normalizeRing(self, ) -> javawrappers.org.geotools.geometry.jts.CircularRing: ...
	def symDifference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getBoundaryDimension(self, ) -> Union[int, JInt]: ...
	def touches(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def toCurvedText(self, ) -> javawrappers.java.lang.String: ...
	def getCoordinate(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def getPrecisionModel(self, ) -> javawrappers.org.locationtech.jts.geom.PrecisionModel: ...
	def isClosed(self, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def isRectangle(self, ) -> Union[int, JBoolean]: ...
	def clone(self, ) -> javawrappers.java.lang.Object: ...
	def getLength(self, ) -> Union[float, JDouble]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def getEnvelope(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getUserData(self, ) -> javawrappers.java.lang.Object: ...
	def toText(self, ) -> javawrappers.java.lang.String: ...
	def getArea(self, ) -> Union[float, JDouble]: ...


class FactoryFinder:
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def notifyAll(self, ) -> None: ...
	@staticmethod
	def getGeometryFactory(arg0: javawrappers.org.geotools.factory.Hints, ) -> javawrappers.org.locationtech.jts.geom.GeometryFactory: ...
	@staticmethod
	def getCoordinateSequenceFactory(arg0: javawrappers.org.geotools.factory.Hints, ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequenceFactory: ...
	def notify(self, ) -> None: ...
	@staticmethod
	def scanForPlugins() -> None: ...
	@staticmethod
	def getPrecisionModel(arg0: javawrappers.org.geotools.factory.Hints, ) -> javawrappers.org.locationtech.jts.geom.PrecisionModel: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@staticmethod
	def getCoordinateSequenceFactories() -> javawrappers.java.util.Set: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@staticmethod
	def getPrecisionModels() -> javawrappers.java.util.Set: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@staticmethod
	def getGeometryFactories() -> javawrappers.java.util.Set: ...


class CircularArc:
	@overload
	def __init__(self, arg0: JArray(Union[float, JDouble], 1), ): ...
	@overload
	def __init__(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], arg4: Union[float, JDouble], arg5: Union[float, JDouble], ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def linearize(self, arg0: Union[float, JDouble], ) -> JArray(Union[float, JDouble], 1): ...
	def getCenter(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	@staticmethod
	def setMaxSegmentsQuadrant(arg0: Union[int, JInt], ) -> None: ...
	def getControlPoints(self, ) -> JArray(Union[float, JDouble], 1): ...
	def notifyAll(self, ) -> None: ...
	@staticmethod
	def setBaseSegmentsQuadrant(arg0: Union[int, JInt], ) -> None: ...
	def getRadius(self, ) -> Union[float, JDouble]: ...
	def notify(self, ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def getDimension(self, ) -> Union[int, JInt]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def getEnvelope(self, ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...


class CompoundCurvedGeometry:
	def toCurvedText(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def linearize(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def linearize(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getTolerance(self, ) -> Union[float, JDouble]: ...
	def getCoordinatesDimension(self, ) -> Union[int, JInt]: ...
	def getComponents(self, ) -> javawrappers.java.util.List: ...


class PointIterator:
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.Point, arg1: javawrappers.java.awt.geom.AffineTransform, ): ...
	def next(self, ) -> None: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def getWindingRule(self, ) -> Union[int, JInt]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def currentSegment(self, arg0: JArray(Union[float, JDouble], 1), ) -> Union[int, JInt]: ...
	@overload
	def currentSegment(self, arg0: JArray(Union[float, JFloat], 1), ) -> Union[int, JInt]: ...
	def isDone(self, ) -> Union[int, JBoolean]: ...
	def notify(self, ) -> None: ...


class PolygonIterator:
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.Polygon, arg1: javawrappers.java.awt.geom.AffineTransform, arg2: Union[int, JBoolean], ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.Polygon, arg1: javawrappers.java.awt.geom.AffineTransform, arg2: Union[int, JBoolean], arg3: Union[float, JDouble], ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.Polygon, arg1: javawrappers.java.awt.geom.AffineTransform, ): ...
	def next(self, ) -> None: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def getWindingRule(self, ) -> Union[int, JInt]: ...
	def setMaxDistance(self, arg0: Union[float, JDouble], ) -> None: ...
	def getMaxDistance(self, ) -> Union[float, JDouble]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def currentSegment(self, arg0: JArray(Union[float, JDouble], 1), ) -> Union[int, JInt]: ...
	@overload
	def currentSegment(self, arg0: JArray(Union[float, JFloat], 1), ) -> Union[int, JInt]: ...
	def isDone(self, ) -> Union[int, JBoolean]: ...
	def notify(self, ) -> None: ...


class LiteShape2:
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.org.opengis.referencing.operation.MathTransform, arg2: javawrappers.org.geotools.geometry.jts.Decimator, arg3: Union[int, JBoolean], arg4: Union[float, JDouble], ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.org.opengis.referencing.operation.MathTransform, arg2: javawrappers.org.geotools.geometry.jts.Decimator, arg3: Union[int, JBoolean], arg4: Union[int, JBoolean], ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.org.opengis.referencing.operation.MathTransform, arg2: javawrappers.org.geotools.geometry.jts.Decimator, arg3: Union[int, JBoolean], ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@overload
	def intersects(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def intersects(self, arg0: javawrappers.java.awt.geom.Rectangle2D, ) -> Union[int, JBoolean]: ...
	def notifyAll(self, ) -> None: ...
	def getGeometry(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def notify(self, ) -> None: ...
	def getBounds(self, ) -> javawrappers.java.awt.Rectangle: ...
	def getMathTransform(self, ) -> javawrappers.org.opengis.referencing.operation.MathTransform: ...
	def setGeometry(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> None: ...
	@overload
	def contains(self, arg0: javawrappers.java.awt.geom.Rectangle2D, ) -> Union[int, JBoolean]: ...
	@overload
	def contains(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def contains(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def contains(self, arg0: javawrappers.java.awt.geom.Point2D, ) -> Union[int, JBoolean]: ...
	@overload
	def getPathIterator(self, arg0: javawrappers.java.awt.geom.AffineTransform, arg1: Union[float, JDouble], ) -> javawrappers.java.awt.geom.PathIterator: ...
	@overload
	def getPathIterator(self, arg0: javawrappers.java.awt.geom.AffineTransform, ) -> javawrappers.java.awt.geom.PathIterator: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def getBounds2D(self, ) -> javawrappers.java.awt.geom.Rectangle2D: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...


