################################################################################
#          This file was automatically generated. Please do not edit.          #
################################################################################

import javawrappers.java.lang
import javawrappers.java.util
import javawrappers.java.util.stream
import javawrappers.java.util.function
import javawrappers.org.matsim.core.utils.collections
import javawrappers.org.matsim.api.core.v01

from jpype.types import *
from typing import Union

from typing import overload

class QuadTree:
	def __init__(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], ): ...
	class Executor:
		def execute(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: javawrappers.java.lang.Object, ) -> None: ...


	class Node:
		def __init__(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], ): ...
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def nextLeaf(self, arg0: javawrappers.org.matsim.core.utils.collections.QuadTree.Leaf, ) -> javawrappers.org.matsim.core.utils.collections.QuadTree.Leaf: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def clear(self, ) -> None: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def notify(self, ) -> None: ...
		@overload
		def put(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		@overload
		def put(self, arg0: javawrappers.org.matsim.core.utils.collections.QuadTree.Leaf, ) -> Union[int, JBoolean]: ...
		def remove(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def getBounds(self, ) -> javawrappers.org.matsim.core.utils.collections.QuadTree.Rect: ...


	class Leaf:
		def __init__(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: javawrappers.java.lang.Object, ): ...
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def notify(self, ) -> None: ...


	class Rect:
		def __init__(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], ): ...
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def intersects(self, arg0: javawrappers.org.matsim.core.utils.collections.QuadTree.Rect, ) -> Union[int, JBoolean]: ...
		def notifyAll(self, ) -> None: ...
		def scale(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> javawrappers.org.matsim.core.utils.collections.QuadTree.Rect: ...
		def union(self, arg0: javawrappers.org.matsim.core.utils.collections.QuadTree.Rect, ) -> javawrappers.org.matsim.core.utils.collections.QuadTree.Rect: ...
		def notify(self, ) -> None: ...
		@overload
		def containsOrEquals(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
		@overload
		def containsOrEquals(self, arg0: javawrappers.org.matsim.core.utils.collections.QuadTree.Rect, ) -> Union[int, JBoolean]: ...
		def contains(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
		def calcDistance(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[float, JDouble]: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def intersection(self, arg0: javawrappers.org.matsim.core.utils.collections.QuadTree.Rect, ) -> javawrappers.org.matsim.core.utils.collections.QuadTree.Rect: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def calcMaxDistance(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[float, JDouble]: ...


	class MutableLeaf:
		def __init__(self, arg0: javawrappers.org.matsim.core.utils.collections.QuadTree.Leaf, ): ...
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def notify(self, ) -> None: ...


	class MutableDouble:
		def __init__(self, arg0: Union[float, JDouble], ): ...
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def notify(self, ) -> None: ...


	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def intersects(self, arg0: javawrappers.org.matsim.core.utils.collections.QuadTree.Rect, ) -> Union[int, JBoolean]: ...
	def notifyAll(self, ) -> None: ...
	def values(self, ) -> javawrappers.java.util.Collection: ...
	def scale(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> javawrappers.org.matsim.core.utils.collections.QuadTree.Rect: ...
	def getBounds(self, ) -> javawrappers.org.matsim.core.utils.collections.QuadTree.Rect: ...
	def notify(self, ) -> None: ...
	@overload
	def put(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def put(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def put(self, arg0: javawrappers.org.matsim.core.utils.collections.QuadTree.Leaf, ) -> Union[int, JBoolean]: ...
	@overload
	def remove(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def remove(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def containsOrEquals(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def containsOrEquals(self, arg0: javawrappers.org.matsim.core.utils.collections.QuadTree.Rect, ) -> Union[int, JBoolean]: ...
	def getClosest(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> javawrappers.java.lang.Object: ...
	def nextLeaf(self, arg0: javawrappers.org.matsim.core.utils.collections.QuadTree.Leaf, ) -> javawrappers.org.matsim.core.utils.collections.QuadTree.Leaf: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def intersection(self, arg0: javawrappers.org.matsim.core.utils.collections.QuadTree.Rect, ) -> javawrappers.org.matsim.core.utils.collections.QuadTree.Rect: ...
	def getElliptical(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], arg4: Union[float, JDouble], ) -> javawrappers.java.util.Collection: ...
	def getRing(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], ) -> javawrappers.java.util.Collection: ...
	def getMaxNorthing(self, ) -> Union[float, JDouble]: ...
	@overload
	def clear(self, ) -> None: ...
	@overload
	def clear(self, ) -> None: ...
	def getMaxEasting(self, ) -> Union[float, JDouble]: ...
	def union(self, arg0: javawrappers.org.matsim.core.utils.collections.QuadTree.Rect, ) -> javawrappers.org.matsim.core.utils.collections.QuadTree.Rect: ...
	@overload
	def execute(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: javawrappers.java.lang.Object, ) -> None: ...
	@overload
	def execute(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], arg4: javawrappers.org.matsim.core.utils.collections.QuadTree.Executor, ) -> Union[int, JInt]: ...
	@overload
	def execute(self, arg0: javawrappers.org.matsim.core.utils.collections.QuadTree.Rect, arg1: javawrappers.org.matsim.core.utils.collections.QuadTree.Executor, ) -> Union[int, JInt]: ...
	def getDisk(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], ) -> javawrappers.java.util.Collection: ...
	def getMinNorthing(self, ) -> Union[float, JDouble]: ...
	def contains(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def calcDistance(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def size(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def getRectangle(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], arg4: javawrappers.java.util.Collection, ) -> javawrappers.java.util.Collection: ...
	@overload
	def getRectangle(self, arg0: javawrappers.org.matsim.core.utils.collections.QuadTree.Rect, arg1: javawrappers.java.util.Collection, ) -> javawrappers.java.util.Collection: ...
	def calcMaxDistance(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def getMinEasting(self, ) -> Union[float, JDouble]: ...


class PseudoRemovePriorityQueue:
	def __init__(self, arg0: Union[int, JInt], ): ...
	class PseudoComparator:
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		@overload
		def compare(self, arg0: javawrappers.org.matsim.core.utils.collections.PseudoRemovePriorityQueue.PseudoEntry, arg1: javawrappers.org.matsim.core.utils.collections.PseudoRemovePriorityQueue.PseudoEntry, ) -> Union[int, JInt]: ...
		@overload
		def compare(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
		def thenComparingLong(self, arg0: javawrappers.java.util.function.ToLongFunction, ) -> javawrappers.java.util.Comparator: ...
		def thenComparingInt(self, arg0: javawrappers.java.util.function.ToIntFunction, ) -> javawrappers.java.util.Comparator: ...
		@overload
		def thenComparing(self, arg0: javawrappers.java.util.function.Function, ) -> javawrappers.java.util.Comparator: ...
		@overload
		def thenComparing(self, arg0: javawrappers.java.util.function.Function, arg1: javawrappers.java.util.Comparator, ) -> javawrappers.java.util.Comparator: ...
		@overload
		def thenComparing(self, arg0: javawrappers.java.util.Comparator, ) -> javawrappers.java.util.Comparator: ...
		def thenComparingDouble(self, arg0: javawrappers.java.util.function.ToDoubleFunction, ) -> javawrappers.java.util.Comparator: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def reversed(self, ) -> javawrappers.java.util.Comparator: ...
		def notify(self, ) -> None: ...


	class PseudoEntry:
		def __init__(self, arg0: javawrappers.java.lang.Object, arg1: Union[float, JDouble], ): ...
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def notify(self, ) -> None: ...


	def add(self, arg0: javawrappers.java.lang.Object, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def compare(self, arg0: javawrappers.org.matsim.core.utils.collections.PseudoRemovePriorityQueue.PseudoEntry, arg1: javawrappers.org.matsim.core.utils.collections.PseudoRemovePriorityQueue.PseudoEntry, ) -> Union[int, JInt]: ...
	@overload
	def compare(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def thenComparingInt(self, arg0: javawrappers.java.util.function.ToIntFunction, ) -> javawrappers.java.util.Comparator: ...
	def spliterator(self, ) -> javawrappers.java.util.Spliterator: ...
	def thenComparingDouble(self, arg0: javawrappers.java.util.function.ToDoubleFunction, ) -> javawrappers.java.util.Comparator: ...
	def forEach(self, arg0: javawrappers.java.util.function.Consumer, ) -> None: ...
	def notifyAll(self, ) -> None: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def decreaseKey(self, arg0: javawrappers.java.lang.Object, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def poll(self, ) -> javawrappers.java.lang.Object: ...
	def notify(self, ) -> None: ...
	def remove(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def peek(self, ) -> javawrappers.java.lang.Object: ...
	def iterator(self, ) -> javawrappers.java.util.Iterator: ...
	def thenComparingLong(self, arg0: javawrappers.java.util.function.ToLongFunction, ) -> javawrappers.java.util.Comparator: ...
	@overload
	def thenComparing(self, arg0: javawrappers.java.util.function.Function, ) -> javawrappers.java.util.Comparator: ...
	@overload
	def thenComparing(self, arg0: javawrappers.java.util.function.Function, arg1: javawrappers.java.util.Comparator, ) -> javawrappers.java.util.Comparator: ...
	@overload
	def thenComparing(self, arg0: javawrappers.java.util.Comparator, ) -> javawrappers.java.util.Comparator: ...
	def size(self, ) -> Union[int, JInt]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def reset(self, ) -> None: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def reversed(self, ) -> javawrappers.java.util.Comparator: ...


class IdentifiableArrayMap:
	def __init__(self, ): ...
	class ArrayIterator:
		def __init__(self, arg0: JArray(javawrappers.java.lang.Object, 1), ): ...
		def next(self, ) -> javawrappers.java.lang.Object: ...
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def hasNext(self, ) -> Union[int, JBoolean]: ...
		def forEachRemaining(self, arg0: javawrappers.java.util.function.Consumer, ) -> None: ...
		def notify(self, ) -> None: ...
		def remove(self, ) -> None: ...


	class ArrayCollection:
		def __init__(self, arg0: JArray(javawrappers.java.lang.Object, 1), ): ...
		def add(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def spliterator(self, ) -> javawrappers.java.util.Spliterator: ...
		def forEach(self, arg0: javawrappers.java.util.function.Consumer, ) -> None: ...
		def notifyAll(self, ) -> None: ...
		def containsAll(self, arg0: javawrappers.java.util.Collection, ) -> Union[int, JBoolean]: ...
		def isEmpty(self, ) -> Union[int, JBoolean]: ...
		def clear(self, ) -> None: ...
		def notify(self, ) -> None: ...
		def remove(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def removeIf(self, arg0: javawrappers.java.util.function.Predicate, ) -> Union[int, JBoolean]: ...
		def removeAll(self, arg0: javawrappers.java.util.Collection, ) -> Union[int, JBoolean]: ...
		def iterator(self, ) -> javawrappers.java.util.Iterator: ...
		def contains(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def size(self, ) -> Union[int, JInt]: ...
		def stream(self, ) -> javawrappers.java.util.stream.Stream: ...
		def addAll(self, arg0: javawrappers.java.util.Collection, ) -> Union[int, JBoolean]: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		@overload
		def toArray(self, arg0: JArray(javawrappers.java.lang.Object, 1), ) -> JArray(javawrappers.java.lang.Object, 1): ...
		@overload
		def toArray(self, ) -> JArray(javawrappers.java.lang.Object, 1): ...
		@overload
		def toArray(self, arg0: javawrappers.java.util.function.IntFunction, ) -> JArray(javawrappers.java.lang.Object, 1): ...
		def parallelStream(self, ) -> javawrappers.java.util.stream.Stream: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def retainAll(self, arg0: javawrappers.java.util.Collection, ) -> Union[int, JBoolean]: ...


	class Entry:
		def __init__(self, arg0: javawrappers.org.matsim.api.core.v01.Identifiable, ): ...
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def getKey(self, ) -> javawrappers.java.lang.Object: ...
		@overload
		def getKey(self, ) -> javawrappers.org.matsim.api.core.v01.Id: ...
		@overload
		def getValue(self, ) -> javawrappers.org.matsim.api.core.v01.Identifiable: ...
		@overload
		def getValue(self, ) -> javawrappers.java.lang.Object: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		@overload
		def setValue(self, arg0: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...
		@overload
		def setValue(self, arg0: javawrappers.org.matsim.api.core.v01.Identifiable, ) -> javawrappers.org.matsim.api.core.v01.Identifiable: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def notify(self, ) -> None: ...


	def next(self, ) -> javawrappers.java.lang.Object: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def getOrDefault(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...
	def computeIfAbsent(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.util.function.Function, ) -> javawrappers.java.lang.Object: ...
	def notifyAll(self, ) -> None: ...
	def values(self, ) -> javawrappers.java.util.Collection: ...
	@overload
	def replace(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...
	@overload
	def replace(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Object, arg2: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def replaceAll(self, arg0: javawrappers.java.util.function.BiFunction, ) -> None: ...
	def notify(self, ) -> None: ...
	def containsValue(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def put(self, arg0: javawrappers.org.matsim.api.core.v01.Id, arg1: javawrappers.org.matsim.api.core.v01.Identifiable, ) -> javawrappers.org.matsim.api.core.v01.Identifiable: ...
	@overload
	def put(self, arg0: javawrappers.org.matsim.api.core.v01.Identifiable, ) -> javawrappers.org.matsim.api.core.v01.Identifiable: ...
	@overload
	def put(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...
	@overload
	def remove(self, arg0: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...
	@overload
	def remove(self, arg0: javawrappers.java.lang.Object, ) -> javawrappers.org.matsim.api.core.v01.Identifiable: ...
	@overload
	def remove(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def remove(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def remove(self, ) -> None: ...
	def compute(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.util.function.BiFunction, ) -> javawrappers.java.lang.Object: ...
	def removeAll(self, arg0: javawrappers.java.util.Collection, ) -> Union[int, JBoolean]: ...
	def iterator(self, ) -> javawrappers.java.util.Iterator: ...
	def stream(self, ) -> javawrappers.java.util.stream.Stream: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def merge(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Object, arg2: javawrappers.java.util.function.BiFunction, ) -> javawrappers.java.lang.Object: ...
	def putAll(self, arg0: javawrappers.java.util.Map, ) -> None: ...
	@overload
	def get(self, arg0: javawrappers.java.lang.Object, ) -> javawrappers.org.matsim.api.core.v01.Identifiable: ...
	@overload
	def get(self, arg0: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...
	@overload
	def toArray(self, arg0: JArray(javawrappers.java.lang.Object, 1), ) -> JArray(javawrappers.java.lang.Object, 1): ...
	@overload
	def toArray(self, ) -> JArray(javawrappers.java.lang.Object, 1): ...
	@overload
	def toArray(self, arg0: javawrappers.java.util.function.IntFunction, ) -> JArray(javawrappers.java.lang.Object, 1): ...
	def parallelStream(self, ) -> javawrappers.java.util.stream.Stream: ...
	def forEachRemaining(self, arg0: javawrappers.java.util.function.Consumer, ) -> None: ...
	def keySet(self, ) -> javawrappers.java.util.Set: ...
	def add(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def getKey(self, ) -> javawrappers.java.lang.Object: ...
	@overload
	def getKey(self, ) -> javawrappers.org.matsim.api.core.v01.Id: ...
	def spliterator(self, ) -> javawrappers.java.util.Spliterator: ...
	def entrySet(self, ) -> javawrappers.java.util.Set: ...
	@overload
	def forEach(self, arg0: javawrappers.java.util.function.BiConsumer, ) -> None: ...
	@overload
	def forEach(self, arg0: javawrappers.java.util.function.Consumer, ) -> None: ...
	def containsKey(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def containsAll(self, arg0: javawrappers.java.util.Collection, ) -> Union[int, JBoolean]: ...
	@overload
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	@overload
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	@overload
	def clear(self, ) -> None: ...
	@overload
	def clear(self, ) -> None: ...
	def hasNext(self, ) -> Union[int, JBoolean]: ...
	def removeIf(self, arg0: javawrappers.java.util.function.Predicate, ) -> Union[int, JBoolean]: ...
	@overload
	def getValue(self, ) -> javawrappers.org.matsim.api.core.v01.Identifiable: ...
	@overload
	def getValue(self, ) -> javawrappers.java.lang.Object: ...
	def contains(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def computeIfPresent(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.util.function.BiFunction, ) -> javawrappers.java.lang.Object: ...
	@overload
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def size(self, ) -> Union[int, JInt]: ...
	def addAll(self, arg0: javawrappers.java.util.Collection, ) -> Union[int, JBoolean]: ...
	@overload
	def setValue(self, arg0: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...
	@overload
	def setValue(self, arg0: javawrappers.org.matsim.api.core.v01.Identifiable, ) -> javawrappers.org.matsim.api.core.v01.Identifiable: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def putIfAbsent(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...
	def retainAll(self, arg0: javawrappers.java.util.Collection, ) -> Union[int, JBoolean]: ...


class RouterPriorityQueue:
	def add(self, arg0: javawrappers.java.lang.Object, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def iterator(self, ) -> javawrappers.java.util.Iterator: ...
	def size(self, ) -> Union[int, JInt]: ...
	def spliterator(self, ) -> javawrappers.java.util.Spliterator: ...
	def forEach(self, arg0: javawrappers.java.util.function.Consumer, ) -> None: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def reset(self, ) -> None: ...
	def decreaseKey(self, arg0: javawrappers.java.lang.Object, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def poll(self, ) -> javawrappers.java.lang.Object: ...
	def remove(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def peek(self, ) -> javawrappers.java.lang.Object: ...


class MapUtils:
	class DefaultFactory:
		def __init__(self, arg0: javawrappers.java.lang.Class, ): ...
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def create(self, ) -> javawrappers.java.lang.Object: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def notify(self, ) -> None: ...


	class Factory:
		def create(self, ) -> javawrappers.java.lang.Object: ...


	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@staticmethod
	def getCollection(arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.util.Map, ) -> javawrappers.java.util.Collection: ...
	@staticmethod
	def getSet(arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.util.Map, ) -> javawrappers.java.util.Set: ...
	def notifyAll(self, ) -> None: ...
	@staticmethod
	def getDouble(arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.util.Map, arg2: Union[float, JDouble], ) -> javawrappers.java.lang.Double: ...
	@staticmethod
	def getInteger(arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.util.Map, arg2: Union[int, JInt], ) -> javawrappers.java.lang.Integer: ...
	@staticmethod
	def addToDouble(arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.util.Map, arg2: Union[float, JDouble], arg3: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	def notify(self, ) -> None: ...
	@staticmethod
	def getMap(arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.util.Map, ) -> javawrappers.java.util.Map: ...
	@staticmethod
	def getArbitraryObject(arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.util.Map, arg2: javawrappers.org.matsim.core.utils.collections.MapUtils.Factory, ) -> javawrappers.java.lang.Object: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@staticmethod
	def getList(arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.util.Map, ) -> javawrappers.java.util.List: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@staticmethod
	def get(arg0: javawrappers.java.lang.Iterable, arg1: javawrappers.java.util.Map, ) -> javawrappers.java.util.Collection: ...
	@staticmethod
	def addToInteger(arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.util.Map, arg2: Union[int, JInt], arg3: Union[int, JInt], ) -> Union[float, JDouble]: ...
	@overload
	def create(self, ) -> javawrappers.java.lang.Object: ...
	@overload
	def create(self, ) -> javawrappers.java.lang.Object: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...


class CollectionUtils:
	@staticmethod
	def arrayToString(arg0: JArray(javawrappers.java.lang.String, 1), ) -> javawrappers.java.lang.String: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@staticmethod
	def stringArrayToSet(arg0: JArray(javawrappers.java.lang.String, 1), ) -> javawrappers.java.util.Set: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@staticmethod
	def setToString(arg0: javawrappers.java.util.Set, ) -> javawrappers.java.lang.String: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@staticmethod
	def idSetToString(arg0: javawrappers.java.util.Set, ) -> javawrappers.java.lang.String: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@staticmethod
	def stringToSet(arg0: javawrappers.java.lang.String, ) -> javawrappers.java.util.Set: ...
	@staticmethod
	def stringToArray(arg0: javawrappers.java.lang.String, ) -> JArray(javawrappers.java.lang.String, 1): ...
	def notify(self, ) -> None: ...


class Tuple:
	def __init__(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Object, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def getFirst(self, ) -> javawrappers.java.lang.Object: ...
	def notifyAll(self, ) -> None: ...
	@staticmethod
	def of(arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Object, ) -> javawrappers.org.matsim.core.utils.collections.Tuple: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def getSecond(self, ) -> javawrappers.java.lang.Object: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def notify(self, ) -> None: ...


