################################################################################
#          This file was automatically generated. Please do not edit.          #
################################################################################

import javawrappers.java.lang
import javawrappers.java.util
import javawrappers.java.io
import javawrappers.java.util.stream
import javawrappers.java.util.function
import javawrappers.org.locationtech.jts.geom
import javawrappers.org.locationtech.jts.algorithm

from jpype.types import *
from typing import Union

from typing import overload

class CoordinateXYM:
	@overload
	def __init__(self, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateXYM, ): ...
	@overload
	def __init__(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def setY(self, arg0: Union[float, JDouble], ) -> None: ...
	def setX(self, arg0: Union[float, JDouble], ) -> None: ...
	def distance(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[float, JDouble]: ...
	def notifyAll(self, ) -> None: ...
	def getM(self, ) -> Union[float, JDouble]: ...
	@overload
	def compareTo(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	def setZ(self, arg0: Union[float, JDouble], ) -> None: ...
	def notify(self, ) -> None: ...
	def setOrdinate(self, arg0: Union[int, JInt], arg1: Union[float, JDouble], ) -> None: ...
	@overload
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	@staticmethod
	def hashCode(arg0: Union[float, JDouble], ) -> Union[int, JInt]: ...
	def equals3D(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	def distance3D(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[float, JDouble]: ...
	@overload
	def copy(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	@overload
	def copy(self, ) -> javawrappers.org.locationtech.jts.geom.CoordinateXYM: ...
	def setM(self, arg0: Union[float, JDouble], ) -> None: ...
	def getOrdinate(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	def equalInZ(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getX(self, ) -> Union[float, JDouble]: ...
	def getY(self, ) -> Union[float, JDouble]: ...
	def getZ(self, ) -> Union[float, JDouble]: ...
	@overload
	def equals2D(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def equals2D(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def clone(self, ) -> javawrappers.java.lang.Object: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def setCoordinate(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> None: ...


class MultiLineString:
	@overload
	def __init__(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.LineString, 1), arg1: javawrappers.org.locationtech.jts.geom.GeometryFactory, ): ...
	@overload
	def __init__(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.LineString, 1), arg1: javawrappers.org.locationtech.jts.geom.PrecisionModel, arg2: Union[int, JInt], ): ...
	def getGeometryN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def equalsNorm(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def equalsTopo(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def coveredBy(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def geometryChanged(self, ) -> None: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.org.locationtech.jts.geom.CoordinateSequenceComparator, ) -> Union[int, JInt]: ...
	def getEnvelopeInternal(self, ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...
	def crosses(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def norm(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.IntersectionMatrix: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.java.lang.String, ) -> Union[int, JBoolean]: ...
	def getSRID(self, ) -> Union[int, JInt]: ...
	def disjoint(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def intersection(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def normalize(self, ) -> None: ...
	def overlaps(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getDimension(self, ) -> Union[int, JInt]: ...
	def isSimple(self, ) -> Union[int, JBoolean]: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getCentroid(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def getCoordinates(self, ) -> JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1): ...
	def contains(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def isWithinDistance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getNumGeometries(self, ) -> Union[int, JInt]: ...
	def difference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def setUserData(self, arg0: javawrappers.java.lang.Object, ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def distance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[float, JDouble]: ...
	def getNumPoints(self, ) -> Union[int, JInt]: ...
	def intersects(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def notifyAll(self, ) -> None: ...
	def notify(self, ) -> None: ...
	def setSRID(self, arg0: Union[int, JInt], ) -> None: ...
	def getInteriorPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def copy(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def convexHull(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def covers(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def within(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryComponentFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequenceFilter, ) -> None: ...
	def getBoundary(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def isValid(self, ) -> Union[int, JBoolean]: ...
	def getGeometryType(self, ) -> javawrappers.java.lang.String: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	@overload
	def union(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def union(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getFactory(self, ) -> javawrappers.org.locationtech.jts.geom.GeometryFactory: ...
	def reverse(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def symDifference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getBoundaryDimension(self, ) -> Union[int, JInt]: ...
	def touches(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getCoordinate(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def getPrecisionModel(self, ) -> javawrappers.org.locationtech.jts.geom.PrecisionModel: ...
	def isClosed(self, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def isRectangle(self, ) -> Union[int, JBoolean]: ...
	def clone(self, ) -> javawrappers.java.lang.Object: ...
	def getLength(self, ) -> Union[float, JDouble]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def getEnvelope(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getUserData(self, ) -> javawrappers.java.lang.Object: ...
	def toText(self, ) -> javawrappers.java.lang.String: ...
	def getArea(self, ) -> Union[float, JDouble]: ...


class Triangle:
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, arg2: javawrappers.org.locationtech.jts.geom.Coordinate, ): ...
	@overload
	def inCentre(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	@overload
	@staticmethod
	def inCentre(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, arg2: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	@overload
	def area(self, ) -> Union[float, JDouble]: ...
	@overload
	@staticmethod
	def area(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, arg2: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[float, JDouble]: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@overload
	@staticmethod
	def area3D(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, arg2: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[float, JDouble]: ...
	@overload
	def area3D(self, ) -> Union[float, JDouble]: ...
	@staticmethod
	def perpendicularBisector(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> javawrappers.org.locationtech.jts.algorithm.HCoordinate: ...
	@overload
	def circumcentre(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	@overload
	@staticmethod
	def circumcentre(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, arg2: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	@overload
	@staticmethod
	def signedArea(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, arg2: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[float, JDouble]: ...
	@overload
	def signedArea(self, ) -> Union[float, JDouble]: ...
	def notifyAll(self, ) -> None: ...
	@overload
	def interpolateZ(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[float, JDouble]: ...
	@overload
	@staticmethod
	def interpolateZ(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, arg2: javawrappers.org.locationtech.jts.geom.Coordinate, arg3: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[float, JDouble]: ...
	@overload
	@staticmethod
	def longestSideLength(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, arg2: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[float, JDouble]: ...
	@overload
	def longestSideLength(self, ) -> Union[float, JDouble]: ...
	def notify(self, ) -> None: ...
	@staticmethod
	def angleBisector(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, arg2: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	@overload
	@staticmethod
	def isAcute(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, arg2: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	@overload
	def isAcute(self, ) -> Union[int, JBoolean]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	@staticmethod
	def centroid(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, arg2: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	@overload
	def centroid(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...


class Geometry:
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryFactory, ): ...
	def getGeometryN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def equalsNorm(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def equalsTopo(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def coveredBy(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def geometryChanged(self, ) -> None: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.org.locationtech.jts.geom.CoordinateSequenceComparator, ) -> Union[int, JInt]: ...
	def getEnvelopeInternal(self, ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...
	def crosses(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def norm(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.IntersectionMatrix: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.java.lang.String, ) -> Union[int, JBoolean]: ...
	def getSRID(self, ) -> Union[int, JInt]: ...
	def disjoint(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def normalize(self, ) -> None: ...
	def intersection(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getDimension(self, ) -> Union[int, JInt]: ...
	def overlaps(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def isSimple(self, ) -> Union[int, JBoolean]: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getCentroid(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def getCoordinates(self, ) -> JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1): ...
	def contains(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def isWithinDistance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getNumGeometries(self, ) -> Union[int, JInt]: ...
	def difference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def setUserData(self, arg0: javawrappers.java.lang.Object, ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def distance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[float, JDouble]: ...
	def getNumPoints(self, ) -> Union[int, JInt]: ...
	def intersects(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def notifyAll(self, ) -> None: ...
	def notify(self, ) -> None: ...
	def setSRID(self, arg0: Union[int, JInt], ) -> None: ...
	def getInteriorPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def copy(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def convexHull(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def covers(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequenceFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryComponentFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryFilter, ) -> None: ...
	def within(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getBoundary(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def isValid(self, ) -> Union[int, JBoolean]: ...
	def getGeometryType(self, ) -> javawrappers.java.lang.String: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	@overload
	def union(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def union(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def reverse(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getFactory(self, ) -> javawrappers.org.locationtech.jts.geom.GeometryFactory: ...
	def symDifference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getBoundaryDimension(self, ) -> Union[int, JInt]: ...
	def touches(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getCoordinate(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def getPrecisionModel(self, ) -> javawrappers.org.locationtech.jts.geom.PrecisionModel: ...
	@overload
	def equals(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def isRectangle(self, ) -> Union[int, JBoolean]: ...
	def clone(self, ) -> javawrappers.java.lang.Object: ...
	def getLength(self, ) -> Union[float, JDouble]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def getEnvelope(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getUserData(self, ) -> javawrappers.java.lang.Object: ...
	def toText(self, ) -> javawrappers.java.lang.String: ...
	def getArea(self, ) -> Union[float, JDouble]: ...


class Puntal:


class GeometryCollectionIterator:
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ): ...
	def next(self, ) -> javawrappers.java.lang.Object: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def hasNext(self, ) -> Union[int, JBoolean]: ...
	def forEachRemaining(self, arg0: javawrappers.java.util.function.Consumer, ) -> None: ...
	def notify(self, ) -> None: ...
	def remove(self, ) -> None: ...


class Location:
	def __init__(self, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@staticmethod
	def toLocationSymbol(arg0: Union[int, JInt], ) -> Union[string, JString]: ...
	def notify(self, ) -> None: ...


class MultiPolygon:
	@overload
	def __init__(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Polygon, 1), arg1: javawrappers.org.locationtech.jts.geom.GeometryFactory, ): ...
	@overload
	def __init__(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Polygon, 1), arg1: javawrappers.org.locationtech.jts.geom.PrecisionModel, arg2: Union[int, JInt], ): ...
	def getGeometryN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def equalsNorm(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def equalsTopo(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def coveredBy(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def geometryChanged(self, ) -> None: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.org.locationtech.jts.geom.CoordinateSequenceComparator, ) -> Union[int, JInt]: ...
	def getEnvelopeInternal(self, ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...
	def crosses(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def norm(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.IntersectionMatrix: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.java.lang.String, ) -> Union[int, JBoolean]: ...
	def getSRID(self, ) -> Union[int, JInt]: ...
	def disjoint(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def intersection(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def normalize(self, ) -> None: ...
	def overlaps(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getDimension(self, ) -> Union[int, JInt]: ...
	def isSimple(self, ) -> Union[int, JBoolean]: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getCentroid(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def getCoordinates(self, ) -> JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1): ...
	def contains(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def isWithinDistance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getNumGeometries(self, ) -> Union[int, JInt]: ...
	def difference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def setUserData(self, arg0: javawrappers.java.lang.Object, ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def distance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[float, JDouble]: ...
	def getNumPoints(self, ) -> Union[int, JInt]: ...
	def intersects(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def notifyAll(self, ) -> None: ...
	def notify(self, ) -> None: ...
	def setSRID(self, arg0: Union[int, JInt], ) -> None: ...
	def getInteriorPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def copy(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def convexHull(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def covers(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def within(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryComponentFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequenceFilter, ) -> None: ...
	def getBoundary(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def isValid(self, ) -> Union[int, JBoolean]: ...
	def getGeometryType(self, ) -> javawrappers.java.lang.String: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	@overload
	def union(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def union(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getFactory(self, ) -> javawrappers.org.locationtech.jts.geom.GeometryFactory: ...
	def reverse(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def symDifference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getBoundaryDimension(self, ) -> Union[int, JInt]: ...
	def touches(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getCoordinate(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def getPrecisionModel(self, ) -> javawrappers.org.locationtech.jts.geom.PrecisionModel: ...
	@overload
	def equals(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def isRectangle(self, ) -> Union[int, JBoolean]: ...
	def clone(self, ) -> javawrappers.java.lang.Object: ...
	def getLength(self, ) -> Union[float, JDouble]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def getEnvelope(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getUserData(self, ) -> javawrappers.java.lang.Object: ...
	def toText(self, ) -> javawrappers.java.lang.String: ...
	def getArea(self, ) -> Union[float, JDouble]: ...


class CoordinateSequence:
	def getOrdinate(self, arg0: Union[int, JInt], arg1: Union[int, JInt], ) -> Union[float, JDouble]: ...
	def hasM(self, ) -> Union[int, JBoolean]: ...
	def getM(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	def getCoordinateCopy(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def getMeasures(self, ) -> Union[int, JInt]: ...
	def hasZ(self, ) -> Union[int, JBoolean]: ...
	@overload
	def getCoordinate(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	@overload
	def getCoordinate(self, arg0: Union[int, JInt], arg1: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> None: ...
	def getX(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	def getY(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	def size(self, ) -> Union[int, JInt]: ...
	def getZ(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	def setOrdinate(self, arg0: Union[int, JInt], arg1: Union[int, JInt], arg2: Union[float, JDouble], ) -> None: ...
	def clone(self, ) -> javawrappers.java.lang.Object: ...
	def expandEnvelope(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...
	def getDimension(self, ) -> Union[int, JInt]: ...
	def toCoordinateArray(self, ) -> JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1): ...
	def copy(self, ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	def createCoordinate(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...


class MultiPoint:
	@overload
	def __init__(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Point, 1), arg1: javawrappers.org.locationtech.jts.geom.GeometryFactory, ): ...
	@overload
	def __init__(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Point, 1), arg1: javawrappers.org.locationtech.jts.geom.PrecisionModel, arg2: Union[int, JInt], ): ...
	def getGeometryN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def equalsNorm(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def equalsTopo(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def coveredBy(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def geometryChanged(self, ) -> None: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.org.locationtech.jts.geom.CoordinateSequenceComparator, ) -> Union[int, JInt]: ...
	def getEnvelopeInternal(self, ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...
	def crosses(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def norm(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.IntersectionMatrix: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.java.lang.String, ) -> Union[int, JBoolean]: ...
	def getSRID(self, ) -> Union[int, JInt]: ...
	def disjoint(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def intersection(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def normalize(self, ) -> None: ...
	def overlaps(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getDimension(self, ) -> Union[int, JInt]: ...
	def isSimple(self, ) -> Union[int, JBoolean]: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getCentroid(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def getCoordinates(self, ) -> JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1): ...
	def contains(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def isWithinDistance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getNumGeometries(self, ) -> Union[int, JInt]: ...
	def difference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def setUserData(self, arg0: javawrappers.java.lang.Object, ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def distance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[float, JDouble]: ...
	def getNumPoints(self, ) -> Union[int, JInt]: ...
	def intersects(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def notifyAll(self, ) -> None: ...
	def notify(self, ) -> None: ...
	def setSRID(self, arg0: Union[int, JInt], ) -> None: ...
	def getInteriorPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def copy(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def convexHull(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def covers(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def within(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryComponentFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequenceFilter, ) -> None: ...
	def getBoundary(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def isValid(self, ) -> Union[int, JBoolean]: ...
	def getGeometryType(self, ) -> javawrappers.java.lang.String: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	@overload
	def union(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def union(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getFactory(self, ) -> javawrappers.org.locationtech.jts.geom.GeometryFactory: ...
	def reverse(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def symDifference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getBoundaryDimension(self, ) -> Union[int, JInt]: ...
	def touches(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getCoordinate(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def getPrecisionModel(self, ) -> javawrappers.org.locationtech.jts.geom.PrecisionModel: ...
	@overload
	def equals(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def isRectangle(self, ) -> Union[int, JBoolean]: ...
	def clone(self, ) -> javawrappers.java.lang.Object: ...
	def getLength(self, ) -> Union[float, JDouble]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def getEnvelope(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getUserData(self, ) -> javawrappers.java.lang.Object: ...
	def toText(self, ) -> javawrappers.java.lang.String: ...
	def getArea(self, ) -> Union[float, JDouble]: ...


class CoordinateSequenceComparator:
	@overload
	def __init__(self, arg0: Union[int, JInt], ): ...
	@overload
	def __init__(self, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@overload
	def compare(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	@staticmethod
	def compare(arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[int, JInt]: ...
	def thenComparingLong(self, arg0: javawrappers.java.util.function.ToLongFunction, ) -> javawrappers.java.util.Comparator: ...
	def thenComparingInt(self, arg0: javawrappers.java.util.function.ToIntFunction, ) -> javawrappers.java.util.Comparator: ...
	@overload
	def thenComparing(self, arg0: javawrappers.java.util.function.Function, ) -> javawrappers.java.util.Comparator: ...
	@overload
	def thenComparing(self, arg0: javawrappers.java.util.function.Function, arg1: javawrappers.java.util.Comparator, ) -> javawrappers.java.util.Comparator: ...
	@overload
	def thenComparing(self, arg0: javawrappers.java.util.Comparator, ) -> javawrappers.java.util.Comparator: ...
	def thenComparingDouble(self, arg0: javawrappers.java.util.function.ToDoubleFunction, ) -> javawrappers.java.util.Comparator: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def reversed(self, ) -> javawrappers.java.util.Comparator: ...
	def notify(self, ) -> None: ...


class CoordinateXY:
	@overload
	def __init__(self, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateXY, ): ...
	@overload
	def __init__(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def setY(self, arg0: Union[float, JDouble], ) -> None: ...
	def setX(self, arg0: Union[float, JDouble], ) -> None: ...
	def distance(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[float, JDouble]: ...
	def notifyAll(self, ) -> None: ...
	def getM(self, ) -> Union[float, JDouble]: ...
	@overload
	def compareTo(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	def setZ(self, arg0: Union[float, JDouble], ) -> None: ...
	def notify(self, ) -> None: ...
	def setOrdinate(self, arg0: Union[int, JInt], arg1: Union[float, JDouble], ) -> None: ...
	@overload
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	@staticmethod
	def hashCode(arg0: Union[float, JDouble], ) -> Union[int, JInt]: ...
	def equals3D(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	def distance3D(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[float, JDouble]: ...
	@overload
	def copy(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	@overload
	def copy(self, ) -> javawrappers.org.locationtech.jts.geom.CoordinateXY: ...
	def setM(self, arg0: Union[float, JDouble], ) -> None: ...
	def getOrdinate(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	def equalInZ(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getX(self, ) -> Union[float, JDouble]: ...
	def getY(self, ) -> Union[float, JDouble]: ...
	def getZ(self, ) -> Union[float, JDouble]: ...
	@overload
	def equals2D(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def equals2D(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def clone(self, ) -> javawrappers.java.lang.Object: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def setCoordinate(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> None: ...


class CoordinateSequences:
	def __init__(self, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@overload
	@staticmethod
	def minCoordinateIndex(arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> Union[int, JInt]: ...
	@overload
	@staticmethod
	def minCoordinateIndex(arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, ) -> Union[int, JInt]: ...
	@staticmethod
	def swap(arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> None: ...
	def notifyAll(self, ) -> None: ...
	@staticmethod
	def isEqual(arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, arg1: javawrappers.org.locationtech.jts.geom.CoordinateSequence, ) -> Union[int, JBoolean]: ...
	@overload
	@staticmethod
	def scroll(arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> None: ...
	@overload
	@staticmethod
	def scroll(arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, arg1: Union[int, JInt], arg2: Union[int, JBoolean], ) -> None: ...
	@overload
	@staticmethod
	def scroll(arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, arg1: Union[int, JInt], ) -> None: ...
	@staticmethod
	def reverse(arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, ) -> None: ...
	def notify(self, ) -> None: ...
	@staticmethod
	def ensureValidRing(arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequenceFactory, arg1: javawrappers.org.locationtech.jts.geom.CoordinateSequence, ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	@staticmethod
	def extend(arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequenceFactory, arg1: javawrappers.org.locationtech.jts.geom.CoordinateSequence, arg2: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	@staticmethod
	def copyCoord(arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, arg1: Union[int, JInt], arg2: javawrappers.org.locationtech.jts.geom.CoordinateSequence, arg3: Union[int, JInt], ) -> None: ...
	@staticmethod
	def minCoordinate(arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	@staticmethod
	def isRing(arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, ) -> Union[int, JBoolean]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	@staticmethod
	def toString(arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, ) -> javawrappers.java.lang.String: ...
	@staticmethod
	def copy(arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, arg1: Union[int, JInt], arg2: javawrappers.org.locationtech.jts.geom.CoordinateSequence, arg3: Union[int, JInt], arg4: Union[int, JInt], ) -> None: ...
	@staticmethod
	def indexOf(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.CoordinateSequence, ) -> Union[int, JInt]: ...


class OctagonalEnvelope:
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ): ...
	@overload
	def __init__(self, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.OctagonalEnvelope, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, ): ...
	class BoundingOctagonComponentFilter:
		def filter(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> None: ...
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def notify(self, ) -> None: ...


	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def getMinB(self, ) -> Union[float, JDouble]: ...
	@overload
	def expandToInclude(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> javawrappers.org.locationtech.jts.geom.OctagonalEnvelope: ...
	@overload
	def expandToInclude(self, arg0: javawrappers.org.locationtech.jts.geom.OctagonalEnvelope, ) -> javawrappers.org.locationtech.jts.geom.OctagonalEnvelope: ...
	@overload
	def expandToInclude(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.OctagonalEnvelope: ...
	@overload
	def expandToInclude(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> javawrappers.org.locationtech.jts.geom.OctagonalEnvelope: ...
	@overload
	def expandToInclude(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> None: ...
	@overload
	def expandToInclude(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, ) -> javawrappers.org.locationtech.jts.geom.OctagonalEnvelope: ...
	@overload
	def intersects(self, arg0: javawrappers.org.locationtech.jts.geom.OctagonalEnvelope, ) -> Union[int, JBoolean]: ...
	@overload
	def intersects(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	def notifyAll(self, ) -> None: ...
	def getMinA(self, ) -> Union[float, JDouble]: ...
	def getMaxX(self, ) -> Union[float, JDouble]: ...
	def getMaxY(self, ) -> Union[float, JDouble]: ...
	def notify(self, ) -> None: ...
	def filter(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> None: ...
	def getMaxA(self, ) -> Union[float, JDouble]: ...
	def contains(self, arg0: javawrappers.org.locationtech.jts.geom.OctagonalEnvelope, ) -> Union[int, JBoolean]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def getMaxB(self, ) -> Union[float, JDouble]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def isNull(self, ) -> Union[int, JBoolean]: ...
	@staticmethod
	def octagonalEnvelope(arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def toGeometry(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryFactory, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def expandBy(self, arg0: Union[float, JDouble], ) -> None: ...
	def setToNull(self, ) -> None: ...
	def getMinX(self, ) -> Union[float, JDouble]: ...
	def getMinY(self, ) -> Union[float, JDouble]: ...


class TopologyException:
	@overload
	def __init__(self, arg0: javawrappers.java.lang.String, ): ...
	@overload
	def __init__(self, arg0: javawrappers.java.lang.String, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@overload
	def printStackTrace(self, arg0: javawrappers.java.io.PrintStream, ) -> None: ...
	@overload
	def printStackTrace(self, ) -> None: ...
	@overload
	def printStackTrace(self, arg0: javawrappers.java.io.PrintWriter, ) -> None: ...
	def getLocalizedMessage(self, ) -> javawrappers.java.lang.String: ...
	def notifyAll(self, ) -> None: ...
	def initCause(self, arg0: javawrappers.java.lang.Throwable, ) -> javawrappers.java.lang.Throwable: ...
	def getMessage(self, ) -> javawrappers.java.lang.String: ...
	def getCause(self, ) -> javawrappers.java.lang.Throwable: ...
	def notify(self, ) -> None: ...
	def getCoordinate(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def addSuppressed(self, arg0: javawrappers.java.lang.Throwable, ) -> None: ...
	def setStackTrace(self, arg0: JArray(javawrappers.java.lang.StackTraceElement, 1), ) -> None: ...
	def getStackTrace(self, ) -> JArray(javawrappers.java.lang.StackTraceElement, 1): ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def getSuppressed(self, ) -> JArray(javawrappers.java.lang.Throwable, 1): ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def fillInStackTrace(self, ) -> javawrappers.java.lang.Throwable: ...


class Coordinate:
	@overload
	def __init__(self, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ): ...
	@overload
	def __init__(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], ): ...
	@overload
	def __init__(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ): ...
	class DimensionalComparator:
		@overload
		def __init__(self, arg0: Union[int, JInt], ): ...
		@overload
		def __init__(self, ): ...
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		@overload
		def compare(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JInt]: ...
		@overload
		def compare(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
		@overload
		@staticmethod
		def compare(arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[int, JInt]: ...
		def thenComparingLong(self, arg0: javawrappers.java.util.function.ToLongFunction, ) -> javawrappers.java.util.Comparator: ...
		def thenComparingInt(self, arg0: javawrappers.java.util.function.ToIntFunction, ) -> javawrappers.java.util.Comparator: ...
		@overload
		def thenComparing(self, arg0: javawrappers.java.util.function.Function, ) -> javawrappers.java.util.Comparator: ...
		@overload
		def thenComparing(self, arg0: javawrappers.java.util.function.Function, arg1: javawrappers.java.util.Comparator, ) -> javawrappers.java.util.Comparator: ...
		@overload
		def thenComparing(self, arg0: javawrappers.java.util.Comparator, ) -> javawrappers.java.util.Comparator: ...
		def thenComparingDouble(self, arg0: javawrappers.java.util.function.ToDoubleFunction, ) -> javawrappers.java.util.Comparator: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def reversed(self, ) -> javawrappers.java.util.Comparator: ...
		def notify(self, ) -> None: ...


	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def compare(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JInt]: ...
	@overload
	def compare(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	@staticmethod
	def compare(arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[int, JInt]: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def setY(self, arg0: Union[float, JDouble], ) -> None: ...
	def thenComparingInt(self, arg0: javawrappers.java.util.function.ToIntFunction, ) -> javawrappers.java.util.Comparator: ...
	def setX(self, arg0: Union[float, JDouble], ) -> None: ...
	def distance(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[float, JDouble]: ...
	def thenComparingDouble(self, arg0: javawrappers.java.util.function.ToDoubleFunction, ) -> javawrappers.java.util.Comparator: ...
	def notifyAll(self, ) -> None: ...
	def getM(self, ) -> Union[float, JDouble]: ...
	@overload
	def compareTo(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	def setZ(self, arg0: Union[float, JDouble], ) -> None: ...
	def notify(self, ) -> None: ...
	@overload
	def thenComparing(self, arg0: javawrappers.java.util.function.Function, ) -> javawrappers.java.util.Comparator: ...
	@overload
	def thenComparing(self, arg0: javawrappers.java.util.function.Function, arg1: javawrappers.java.util.Comparator, ) -> javawrappers.java.util.Comparator: ...
	@overload
	def thenComparing(self, arg0: javawrappers.java.util.Comparator, ) -> javawrappers.java.util.Comparator: ...
	def setOrdinate(self, arg0: Union[int, JInt], arg1: Union[float, JDouble], ) -> None: ...
	@overload
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	@staticmethod
	def hashCode(arg0: Union[float, JDouble], ) -> Union[int, JInt]: ...
	def equals3D(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	def distance3D(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[float, JDouble]: ...
	def copy(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def setM(self, arg0: Union[float, JDouble], ) -> None: ...
	def getOrdinate(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	def equalInZ(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getX(self, ) -> Union[float, JDouble]: ...
	def thenComparingLong(self, arg0: javawrappers.java.util.function.ToLongFunction, ) -> javawrappers.java.util.Comparator: ...
	def getY(self, ) -> Union[float, JDouble]: ...
	def getZ(self, ) -> Union[float, JDouble]: ...
	@overload
	def equals2D(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def equals2D(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def clone(self, ) -> javawrappers.java.lang.Object: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def setCoordinate(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> None: ...
	def reversed(self, ) -> javawrappers.java.util.Comparator: ...


class LinearRing:
	@overload
	def __init__(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), arg1: javawrappers.org.locationtech.jts.geom.PrecisionModel, arg2: Union[int, JInt], ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, arg1: javawrappers.org.locationtech.jts.geom.GeometryFactory, ): ...
	def getGeometryN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def equalsNorm(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def isCoordinate(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	def equalsTopo(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def coveredBy(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def geometryChanged(self, ) -> None: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.org.locationtech.jts.geom.CoordinateSequenceComparator, ) -> Union[int, JInt]: ...
	def getEnvelopeInternal(self, ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...
	def crosses(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def norm(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.IntersectionMatrix: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.java.lang.String, ) -> Union[int, JBoolean]: ...
	def getSRID(self, ) -> Union[int, JInt]: ...
	def disjoint(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def intersection(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def normalize(self, ) -> None: ...
	def overlaps(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getDimension(self, ) -> Union[int, JInt]: ...
	def isSimple(self, ) -> Union[int, JBoolean]: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getCoordinateSequence(self, ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getCentroid(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def getCoordinates(self, ) -> JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1): ...
	def contains(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getEndPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def isWithinDistance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getNumGeometries(self, ) -> Union[int, JInt]: ...
	def getPointN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def difference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def setUserData(self, arg0: javawrappers.java.lang.Object, ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def distance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[float, JDouble]: ...
	def getNumPoints(self, ) -> Union[int, JInt]: ...
	def intersects(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def notifyAll(self, ) -> None: ...
	def getCoordinateN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def notify(self, ) -> None: ...
	def isRing(self, ) -> Union[int, JBoolean]: ...
	def setSRID(self, arg0: Union[int, JInt], ) -> None: ...
	def getInteriorPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def copy(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def convexHull(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def covers(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getStartPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def within(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequenceFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryComponentFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryFilter, ) -> None: ...
	def getBoundary(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def isValid(self, ) -> Union[int, JBoolean]: ...
	def getGeometryType(self, ) -> javawrappers.java.lang.String: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	@overload
	def union(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def union(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getFactory(self, ) -> javawrappers.org.locationtech.jts.geom.GeometryFactory: ...
	def reverse(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def symDifference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getBoundaryDimension(self, ) -> Union[int, JInt]: ...
	def touches(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getCoordinate(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def getPrecisionModel(self, ) -> javawrappers.org.locationtech.jts.geom.PrecisionModel: ...
	def isClosed(self, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def isRectangle(self, ) -> Union[int, JBoolean]: ...
	def clone(self, ) -> javawrappers.java.lang.Object: ...
	def getLength(self, ) -> Union[float, JDouble]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def getEnvelope(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getUserData(self, ) -> javawrappers.java.lang.Object: ...
	def toText(self, ) -> javawrappers.java.lang.String: ...
	def getArea(self, ) -> Union[float, JDouble]: ...


class LineString:
	@overload
	def __init__(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), arg1: javawrappers.org.locationtech.jts.geom.PrecisionModel, arg2: Union[int, JInt], ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, arg1: javawrappers.org.locationtech.jts.geom.GeometryFactory, ): ...
	def getGeometryN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def equalsNorm(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def isCoordinate(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	def equalsTopo(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def coveredBy(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def geometryChanged(self, ) -> None: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.org.locationtech.jts.geom.CoordinateSequenceComparator, ) -> Union[int, JInt]: ...
	def getEnvelopeInternal(self, ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...
	def crosses(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def norm(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.IntersectionMatrix: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.java.lang.String, ) -> Union[int, JBoolean]: ...
	def getSRID(self, ) -> Union[int, JInt]: ...
	def disjoint(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def intersection(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def normalize(self, ) -> None: ...
	def overlaps(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getDimension(self, ) -> Union[int, JInt]: ...
	def isSimple(self, ) -> Union[int, JBoolean]: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getCoordinateSequence(self, ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getCentroid(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def getCoordinates(self, ) -> JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1): ...
	def contains(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getEndPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def isWithinDistance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getNumGeometries(self, ) -> Union[int, JInt]: ...
	def getPointN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def difference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def setUserData(self, arg0: javawrappers.java.lang.Object, ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def distance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[float, JDouble]: ...
	def getNumPoints(self, ) -> Union[int, JInt]: ...
	def intersects(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def notifyAll(self, ) -> None: ...
	def getCoordinateN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def notify(self, ) -> None: ...
	def isRing(self, ) -> Union[int, JBoolean]: ...
	def setSRID(self, arg0: Union[int, JInt], ) -> None: ...
	def getInteriorPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def copy(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def convexHull(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def covers(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getStartPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def within(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequenceFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryComponentFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryFilter, ) -> None: ...
	def getBoundary(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def isValid(self, ) -> Union[int, JBoolean]: ...
	def getGeometryType(self, ) -> javawrappers.java.lang.String: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	@overload
	def union(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def union(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getFactory(self, ) -> javawrappers.org.locationtech.jts.geom.GeometryFactory: ...
	def reverse(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def symDifference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getBoundaryDimension(self, ) -> Union[int, JInt]: ...
	def touches(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getCoordinate(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def getPrecisionModel(self, ) -> javawrappers.org.locationtech.jts.geom.PrecisionModel: ...
	def isClosed(self, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def isRectangle(self, ) -> Union[int, JBoolean]: ...
	def clone(self, ) -> javawrappers.java.lang.Object: ...
	def getLength(self, ) -> Union[float, JDouble]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def getEnvelope(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getUserData(self, ) -> javawrappers.java.lang.Object: ...
	def toText(self, ) -> javawrappers.java.lang.String: ...
	def getArea(self, ) -> Union[float, JDouble]: ...


class Coordinates:
	def __init__(self, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@staticmethod
	def measures(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JInt]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	@staticmethod
	def create(arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	@overload
	@staticmethod
	def create(arg0: Union[int, JInt], arg1: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@staticmethod
	def dimension(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JInt]: ...
	def notify(self, ) -> None: ...


class Point:
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.PrecisionModel, arg2: Union[int, JInt], ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, arg1: javawrappers.org.locationtech.jts.geom.GeometryFactory, ): ...
	def getGeometryN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def equalsNorm(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def equalsTopo(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def coveredBy(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def geometryChanged(self, ) -> None: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.org.locationtech.jts.geom.CoordinateSequenceComparator, ) -> Union[int, JInt]: ...
	def getEnvelopeInternal(self, ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...
	def crosses(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def norm(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.IntersectionMatrix: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.java.lang.String, ) -> Union[int, JBoolean]: ...
	def getSRID(self, ) -> Union[int, JInt]: ...
	def disjoint(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def intersection(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def normalize(self, ) -> None: ...
	def overlaps(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getDimension(self, ) -> Union[int, JInt]: ...
	def isSimple(self, ) -> Union[int, JBoolean]: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getCoordinateSequence(self, ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getCentroid(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def getCoordinates(self, ) -> JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1): ...
	def contains(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def isWithinDistance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getNumGeometries(self, ) -> Union[int, JInt]: ...
	def difference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def setUserData(self, arg0: javawrappers.java.lang.Object, ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def distance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[float, JDouble]: ...
	def getNumPoints(self, ) -> Union[int, JInt]: ...
	def intersects(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def notifyAll(self, ) -> None: ...
	def notify(self, ) -> None: ...
	def setSRID(self, arg0: Union[int, JInt], ) -> None: ...
	def getInteriorPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def copy(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def convexHull(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def covers(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def within(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequenceFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryComponentFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryFilter, ) -> None: ...
	def getBoundary(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def isValid(self, ) -> Union[int, JBoolean]: ...
	def getGeometryType(self, ) -> javawrappers.java.lang.String: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	@overload
	def union(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def union(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getFactory(self, ) -> javawrappers.org.locationtech.jts.geom.GeometryFactory: ...
	def reverse(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def symDifference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getBoundaryDimension(self, ) -> Union[int, JInt]: ...
	def touches(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getCoordinate(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def getX(self, ) -> Union[float, JDouble]: ...
	def getPrecisionModel(self, ) -> javawrappers.org.locationtech.jts.geom.PrecisionModel: ...
	def getY(self, ) -> Union[float, JDouble]: ...
	@overload
	def equals(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def isRectangle(self, ) -> Union[int, JBoolean]: ...
	def clone(self, ) -> javawrappers.java.lang.Object: ...
	def getLength(self, ) -> Union[float, JDouble]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def getEnvelope(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getUserData(self, ) -> javawrappers.java.lang.Object: ...
	def toText(self, ) -> javawrappers.java.lang.String: ...
	def getArea(self, ) -> Union[float, JDouble]: ...


class GeometryFactory:
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.PrecisionModel, ): ...
	@overload
	def __init__(self, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.PrecisionModel, arg1: Union[int, JInt], ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.PrecisionModel, arg1: Union[int, JInt], arg2: javawrappers.org.locationtech.jts.geom.CoordinateSequenceFactory, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequenceFactory, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@overload
	def createMultiPoint(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Point, 1), ) -> javawrappers.org.locationtech.jts.geom.MultiPoint: ...
	@overload
	def createMultiPoint(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, ) -> javawrappers.org.locationtech.jts.geom.MultiPoint: ...
	@overload
	def createMultiPoint(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> javawrappers.org.locationtech.jts.geom.MultiPoint: ...
	@overload
	def createMultiPoint(self, ) -> javawrappers.org.locationtech.jts.geom.MultiPoint: ...
	def notifyAll(self, ) -> None: ...
	@staticmethod
	def toGeometryArray(arg0: javawrappers.java.util.Collection, ) -> JArray(javawrappers.org.locationtech.jts.geom.Geometry, 1): ...
	@staticmethod
	def toPointArray(arg0: javawrappers.java.util.Collection, ) -> JArray(javawrappers.org.locationtech.jts.geom.Point, 1): ...
	def createGeometry(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@staticmethod
	def toLineStringArray(arg0: javawrappers.java.util.Collection, ) -> JArray(javawrappers.org.locationtech.jts.geom.LineString, 1): ...
	@overload
	def createPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	@overload
	def createPoint(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	@overload
	def createPoint(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	@staticmethod
	def toMultiPointArray(arg0: javawrappers.java.util.Collection, ) -> JArray(javawrappers.org.locationtech.jts.geom.MultiPoint, 1): ...
	def getCoordinateSequenceFactory(self, ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequenceFactory: ...
	def notify(self, ) -> None: ...
	def getSRID(self, ) -> Union[int, JInt]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def toGeometry(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def createMultiPolygon(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Polygon, 1), ) -> javawrappers.org.locationtech.jts.geom.MultiPolygon: ...
	@overload
	def createMultiPolygon(self, ) -> javawrappers.org.locationtech.jts.geom.MultiPolygon: ...
	@staticmethod
	def toMultiLineStringArray(arg0: javawrappers.java.util.Collection, ) -> JArray(javawrappers.org.locationtech.jts.geom.MultiLineString, 1): ...
	@staticmethod
	def createPointFromInternalCoord(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	@staticmethod
	def toPolygonArray(arg0: javawrappers.java.util.Collection, ) -> JArray(javawrappers.org.locationtech.jts.geom.Polygon, 1): ...
	@overload
	def createPolygon(self, arg0: javawrappers.org.locationtech.jts.geom.LinearRing, arg1: JArray(javawrappers.org.locationtech.jts.geom.LinearRing, 1), ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	@overload
	def createPolygon(self, arg0: javawrappers.org.locationtech.jts.geom.LinearRing, ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	@overload
	def createPolygon(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	@overload
	def createPolygon(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	@overload
	def createPolygon(self, ) -> javawrappers.org.locationtech.jts.geom.Polygon: ...
	def createMultiPointFromCoords(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> javawrappers.org.locationtech.jts.geom.MultiPoint: ...
	@overload
	def createLineString(self, ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	@overload
	def createLineString(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	@overload
	def createLineString(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	@staticmethod
	def toMultiPolygonArray(arg0: javawrappers.java.util.Collection, ) -> JArray(javawrappers.org.locationtech.jts.geom.MultiPolygon, 1): ...
	def getPrecisionModel(self, ) -> javawrappers.org.locationtech.jts.geom.PrecisionModel: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def createLinearRing(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, ) -> javawrappers.org.locationtech.jts.geom.LinearRing: ...
	@overload
	def createLinearRing(self, ) -> javawrappers.org.locationtech.jts.geom.LinearRing: ...
	@overload
	def createLinearRing(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> javawrappers.org.locationtech.jts.geom.LinearRing: ...
	@overload
	def createMultiLineString(self, ) -> javawrappers.org.locationtech.jts.geom.MultiLineString: ...
	@overload
	def createMultiLineString(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.LineString, 1), ) -> javawrappers.org.locationtech.jts.geom.MultiLineString: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@staticmethod
	def toLinearRingArray(arg0: javawrappers.java.util.Collection, ) -> JArray(javawrappers.org.locationtech.jts.geom.LinearRing, 1): ...
	@overload
	def createGeometryCollection(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Geometry, 1), ) -> javawrappers.org.locationtech.jts.geom.GeometryCollection: ...
	@overload
	def createGeometryCollection(self, ) -> javawrappers.org.locationtech.jts.geom.GeometryCollection: ...
	def buildGeometry(self, arg0: javawrappers.java.util.Collection, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...


class CoordinateSequenceFactory:
	@overload
	def create(self, arg0: Union[int, JInt], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	@overload
	def create(self, arg0: Union[int, JInt], arg1: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	@overload
	def create(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	@overload
	def create(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...


class Polygon:
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.LinearRing, arg1: javawrappers.org.locationtech.jts.geom.PrecisionModel, arg2: Union[int, JInt], ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.LinearRing, arg1: JArray(javawrappers.org.locationtech.jts.geom.LinearRing, 1), arg2: javawrappers.org.locationtech.jts.geom.GeometryFactory, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.LinearRing, arg1: JArray(javawrappers.org.locationtech.jts.geom.LinearRing, 1), arg2: javawrappers.org.locationtech.jts.geom.PrecisionModel, arg3: Union[int, JInt], ): ...
	def getGeometryN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def equalsNorm(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def equalsTopo(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def coveredBy(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def geometryChanged(self, ) -> None: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.org.locationtech.jts.geom.CoordinateSequenceComparator, ) -> Union[int, JInt]: ...
	def getExteriorRing(self, ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	def getEnvelopeInternal(self, ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...
	def crosses(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def norm(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.IntersectionMatrix: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.java.lang.String, ) -> Union[int, JBoolean]: ...
	def getSRID(self, ) -> Union[int, JInt]: ...
	def disjoint(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def intersection(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def normalize(self, ) -> None: ...
	def overlaps(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getDimension(self, ) -> Union[int, JInt]: ...
	def isSimple(self, ) -> Union[int, JBoolean]: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getCentroid(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def getCoordinates(self, ) -> JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1): ...
	def contains(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def isWithinDistance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getNumGeometries(self, ) -> Union[int, JInt]: ...
	def difference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def setUserData(self, arg0: javawrappers.java.lang.Object, ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def distance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[float, JDouble]: ...
	def getNumPoints(self, ) -> Union[int, JInt]: ...
	def intersects(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def notifyAll(self, ) -> None: ...
	def notify(self, ) -> None: ...
	def setSRID(self, arg0: Union[int, JInt], ) -> None: ...
	def getInteriorPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def copy(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def convexHull(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def covers(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def within(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequenceFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryComponentFilter, ) -> None: ...
	def getBoundary(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def isValid(self, ) -> Union[int, JBoolean]: ...
	def getGeometryType(self, ) -> javawrappers.java.lang.String: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	@overload
	def union(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def union(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getInteriorRingN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	def getFactory(self, ) -> javawrappers.org.locationtech.jts.geom.GeometryFactory: ...
	def reverse(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def symDifference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getBoundaryDimension(self, ) -> Union[int, JInt]: ...
	def touches(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getCoordinate(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def getPrecisionModel(self, ) -> javawrappers.org.locationtech.jts.geom.PrecisionModel: ...
	@overload
	def equals(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def isRectangle(self, ) -> Union[int, JBoolean]: ...
	def clone(self, ) -> javawrappers.java.lang.Object: ...
	def getLength(self, ) -> Union[float, JDouble]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def getEnvelope(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getUserData(self, ) -> javawrappers.java.lang.Object: ...
	def toText(self, ) -> javawrappers.java.lang.String: ...
	def getArea(self, ) -> Union[float, JDouble]: ...
	def getNumInteriorRing(self, ) -> Union[int, JInt]: ...


class Envelope:
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, ): ...
	@overload
	def __init__(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], ): ...
	@overload
	def __init__(self, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def distance(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> Union[float, JDouble]: ...
	@overload
	def expandToInclude(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> None: ...
	@overload
	def expandToInclude(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> None: ...
	@overload
	def expandToInclude(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> None: ...
	@overload
	@staticmethod
	def intersects(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, arg2: javawrappers.org.locationtech.jts.geom.Coordinate, arg3: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	@overload
	@staticmethod
	def intersects(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, arg2: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	@overload
	def intersects(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	@overload
	def intersects(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	@overload
	def intersects(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> Union[int, JBoolean]: ...
	@overload
	def intersects(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def notifyAll(self, ) -> None: ...
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	def getWidth(self, ) -> Union[float, JDouble]: ...
	def notify(self, ) -> None: ...
	def translate(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> None: ...
	def getHeight(self, ) -> Union[float, JDouble]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def intersection(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...
	@overload
	def overlaps(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def overlaps(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	@overload
	def overlaps(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> Union[int, JBoolean]: ...
	def setToNull(self, ) -> None: ...
	def maxExtent(self, ) -> Union[float, JDouble]: ...
	@overload
	def covers(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def covers(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	@overload
	def covers(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> Union[int, JBoolean]: ...
	@overload
	def init(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], ) -> None: ...
	@overload
	def init(self, ) -> None: ...
	@overload
	def init(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> None: ...
	@overload
	def init(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> None: ...
	@overload
	def init(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> None: ...
	def minExtent(self, ) -> Union[float, JDouble]: ...
	def getMaxX(self, ) -> Union[float, JDouble]: ...
	def centre(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def getMaxY(self, ) -> Union[float, JDouble]: ...
	@overload
	def contains(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def contains(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	@overload
	def contains(self, arg0: javawrappers.org.locationtech.jts.geom.Envelope, ) -> Union[int, JBoolean]: ...
	def isNull(self, ) -> Union[int, JBoolean]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def expandBy(self, arg0: Union[float, JDouble], ) -> None: ...
	@overload
	def expandBy(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> None: ...
	def getArea(self, ) -> Union[float, JDouble]: ...
	def getMinX(self, ) -> Union[float, JDouble]: ...
	def getMinY(self, ) -> Union[float, JDouble]: ...


class PrecisionModel:
	@overload
	def __init__(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.PrecisionModel.Type, ): ...
	@overload
	def __init__(self, ): ...
	@overload
	def __init__(self, arg0: Union[float, JDouble], ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.PrecisionModel, ): ...
	class Type:
		def __init__(self, arg0: javawrappers.java.lang.String, ): ...
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def notify(self, ) -> None: ...


	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def toExternal(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> None: ...
	@overload
	def toExternal(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def getMaximumSignificantDigits(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	def getOffsetX(self, ) -> Union[float, JDouble]: ...
	def notify(self, ) -> None: ...
	@staticmethod
	def mostPrecise(arg0: javawrappers.org.locationtech.jts.geom.PrecisionModel, arg1: javawrappers.org.locationtech.jts.geom.PrecisionModel, ) -> javawrappers.org.locationtech.jts.geom.PrecisionModel: ...
	@overload
	def makePrecise(self, arg0: Union[float, JDouble], ) -> Union[float, JDouble]: ...
	@overload
	def makePrecise(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> None: ...
	def getOffsetY(self, ) -> Union[float, JDouble]: ...
	def getScale(self, ) -> Union[float, JDouble]: ...
	def getType(self, ) -> javawrappers.org.locationtech.jts.geom.PrecisionModel.Type: ...
	@overload
	def toInternal(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	@overload
	def toInternal(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def isFloating(self, ) -> Union[int, JBoolean]: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...


class Polygonal:


class CoordinateArrays:
	class BidirectionalComparator:
		def __init__(self, ): ...
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def compare(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
		def thenComparingInt(self, arg0: javawrappers.java.util.function.ToIntFunction, ) -> javawrappers.java.util.Comparator: ...
		def thenComparingDouble(self, arg0: javawrappers.java.util.function.ToDoubleFunction, ) -> javawrappers.java.util.Comparator: ...
		def notifyAll(self, ) -> None: ...
		def OLDcompare(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
		def notify(self, ) -> None: ...
		def thenComparingLong(self, arg0: javawrappers.java.util.function.ToLongFunction, ) -> javawrappers.java.util.Comparator: ...
		@overload
		def thenComparing(self, arg0: javawrappers.java.util.function.Function, ) -> javawrappers.java.util.Comparator: ...
		@overload
		def thenComparing(self, arg0: javawrappers.java.util.function.Function, arg1: javawrappers.java.util.Comparator, ) -> javawrappers.java.util.Comparator: ...
		@overload
		def thenComparing(self, arg0: javawrappers.java.util.Comparator, ) -> javawrappers.java.util.Comparator: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def reversed(self, ) -> javawrappers.java.util.Comparator: ...


	class ForwardComparator:
		def __init__(self, ): ...
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def compare(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
		def thenComparingLong(self, arg0: javawrappers.java.util.function.ToLongFunction, ) -> javawrappers.java.util.Comparator: ...
		def thenComparingInt(self, arg0: javawrappers.java.util.function.ToIntFunction, ) -> javawrappers.java.util.Comparator: ...
		@overload
		def thenComparing(self, arg0: javawrappers.java.util.function.Function, ) -> javawrappers.java.util.Comparator: ...
		@overload
		def thenComparing(self, arg0: javawrappers.java.util.function.Function, arg1: javawrappers.java.util.Comparator, ) -> javawrappers.java.util.Comparator: ...
		@overload
		def thenComparing(self, arg0: javawrappers.java.util.Comparator, ) -> javawrappers.java.util.Comparator: ...
		def thenComparingDouble(self, arg0: javawrappers.java.util.function.ToDoubleFunction, ) -> javawrappers.java.util.Comparator: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def reversed(self, ) -> javawrappers.java.util.Comparator: ...
		def notify(self, ) -> None: ...


	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@overload
	def compare(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compare(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	@staticmethod
	def compare(arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), arg1: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> Union[int, JInt]: ...
	def thenComparingInt(self, arg0: javawrappers.java.util.function.ToIntFunction, ) -> javawrappers.java.util.Comparator: ...
	@staticmethod
	def hasRepeatedPoints(arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> Union[int, JBoolean]: ...
	def thenComparingDouble(self, arg0: javawrappers.java.util.function.ToDoubleFunction, ) -> javawrappers.java.util.Comparator: ...
	def notifyAll(self, ) -> None: ...
	@staticmethod
	def atLeastNCoordinatesOrNothing(arg0: Union[int, JInt], arg1: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1): ...
	def OLDcompare(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	def notify(self, ) -> None: ...
	@overload
	@staticmethod
	def copyDeep(arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), arg1: Union[int, JInt], arg2: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), arg3: Union[int, JInt], arg4: Union[int, JInt], ) -> None: ...
	@overload
	@staticmethod
	def copyDeep(arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1): ...
	@staticmethod
	def measures(arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> Union[int, JInt]: ...
	@staticmethod
	def isRing(arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> Union[int, JBoolean]: ...
	@staticmethod
	def removeNull(arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1): ...
	@overload
	def thenComparing(self, arg0: javawrappers.java.util.function.Function, ) -> javawrappers.java.util.Comparator: ...
	@overload
	def thenComparing(self, arg0: javawrappers.java.util.function.Function, arg1: javawrappers.java.util.Comparator, ) -> javawrappers.java.util.Comparator: ...
	@overload
	def thenComparing(self, arg0: javawrappers.java.util.Comparator, ) -> javawrappers.java.util.Comparator: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@staticmethod
	def intersection(arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), arg1: javawrappers.org.locationtech.jts.geom.Envelope, ) -> JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1): ...
	@staticmethod
	def removeRepeatedPoints(arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1): ...
	@staticmethod
	def toCoordinateArray(arg0: javawrappers.java.util.Collection, ) -> JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1): ...
	@staticmethod
	def ptNotInList(arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), arg1: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	@staticmethod
	def indexOf(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> Union[int, JInt]: ...
	@staticmethod
	def dimension(arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> Union[int, JInt]: ...
	@staticmethod
	def scroll(arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), arg1: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> None: ...
	@staticmethod
	def reverse(arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> None: ...
	@staticmethod
	def increasingDirection(arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> Union[int, JInt]: ...
	@staticmethod
	def minCoordinate(arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	@staticmethod
	def envelope(arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...
	def thenComparingLong(self, arg0: javawrappers.java.util.function.ToLongFunction, ) -> javawrappers.java.util.Comparator: ...
	@staticmethod
	def extract(arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1): ...
	@overload
	@staticmethod
	def equals(arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), arg1: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), arg2: javawrappers.java.util.Comparator, ) -> Union[int, JBoolean]: ...
	@overload
	@staticmethod
	def equals(arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), arg1: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def reversed(self, ) -> javawrappers.java.util.Comparator: ...


class Lineal:


class Dimension:
	def __init__(self, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@staticmethod
	def toDimensionSymbol(arg0: Union[int, JInt], ) -> Union[string, JString]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@staticmethod
	def toDimensionValue(arg0: Union[string, JString], ) -> Union[int, JInt]: ...
	def notify(self, ) -> None: ...


class CoordinateFilter:
	def filter(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> None: ...


class GeometryFilter:
	def filter(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> None: ...


class CoordinateSequenceFilter:
	def filter(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, arg1: Union[int, JInt], ) -> None: ...
	def isGeometryChanged(self, ) -> Union[int, JBoolean]: ...
	def isDone(self, ) -> Union[int, JBoolean]: ...


class CoordinateList:
	@overload
	def __init__(self, ): ...
	@overload
	def __init__(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), arg1: Union[int, JBoolean], ): ...
	@overload
	def __init__(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def notifyAll(self, ) -> None: ...
	def replaceAll(self, arg0: javawrappers.java.util.function.UnaryOperator, ) -> None: ...
	def notify(self, ) -> None: ...
	@overload
	def remove(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def remove(self, arg0: Union[int, JInt], ) -> javawrappers.java.lang.Object: ...
	def removeAll(self, arg0: javawrappers.java.util.Collection, ) -> Union[int, JBoolean]: ...
	def iterator(self, ) -> javawrappers.java.util.Iterator: ...
	def stream(self, ) -> javawrappers.java.util.stream.Stream: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def get(self, arg0: Union[int, JInt], ) -> javawrappers.java.lang.Object: ...
	@overload
	def toArray(self, arg0: JArray(javawrappers.java.lang.Object, 1), ) -> JArray(javawrappers.java.lang.Object, 1): ...
	@overload
	def toArray(self, ) -> JArray(javawrappers.java.lang.Object, 1): ...
	@overload
	def toArray(self, arg0: javawrappers.java.util.function.IntFunction, ) -> JArray(javawrappers.java.lang.Object, 1): ...
	def toCoordinateArray(self, ) -> JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1): ...
	def parallelStream(self, ) -> javawrappers.java.util.stream.Stream: ...
	def indexOf(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def add(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), arg1: Union[int, JBoolean], arg2: Union[int, JInt], arg3: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	@overload
	def add(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	@overload
	def add(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def add(self, arg0: javawrappers.java.lang.Object, arg1: Union[int, JBoolean], ) -> Union[int, JBoolean]: ...
	@overload
	def add(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), arg1: Union[int, JBoolean], arg2: Union[int, JBoolean], ) -> Union[int, JBoolean]: ...
	@overload
	def add(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: Union[int, JBoolean], ) -> None: ...
	@overload
	def add(self, arg0: Union[int, JInt], arg1: javawrappers.org.locationtech.jts.geom.Coordinate, arg2: Union[int, JBoolean], ) -> None: ...
	@overload
	def add(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), arg1: Union[int, JBoolean], ) -> Union[int, JBoolean]: ...
	@overload
	def add(self, arg0: Union[int, JInt], arg1: javawrappers.java.lang.Object, ) -> None: ...
	def subList(self, arg0: Union[int, JInt], arg1: Union[int, JInt], ) -> javawrappers.java.util.List: ...
	def trimToSize(self, ) -> None: ...
	def set(self, arg0: Union[int, JInt], arg1: javawrappers.java.lang.Object, ) -> javawrappers.java.lang.Object: ...
	def spliterator(self, ) -> javawrappers.java.util.Spliterator: ...
	def forEach(self, arg0: javawrappers.java.util.function.Consumer, ) -> None: ...
	def containsAll(self, arg0: javawrappers.java.util.Collection, ) -> Union[int, JBoolean]: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> None: ...
	def sort(self, arg0: javawrappers.java.util.Comparator, ) -> None: ...
	def removeIf(self, arg0: javawrappers.java.util.function.Predicate, ) -> Union[int, JBoolean]: ...
	def lastIndexOf(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	def contains(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def getCoordinate(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def size(self, ) -> Union[int, JInt]: ...
	@overload
	def addAll(self, arg0: javawrappers.java.util.Collection, ) -> Union[int, JBoolean]: ...
	@overload
	def addAll(self, arg0: Union[int, JInt], arg1: javawrappers.java.util.Collection, ) -> Union[int, JBoolean]: ...
	@overload
	def addAll(self, arg0: javawrappers.java.util.Collection, arg1: Union[int, JBoolean], ) -> Union[int, JBoolean]: ...
	def closeRing(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def clone(self, ) -> javawrappers.java.lang.Object: ...
	@overload
	def listIterator(self, ) -> javawrappers.java.util.ListIterator: ...
	@overload
	def listIterator(self, arg0: Union[int, JInt], ) -> javawrappers.java.util.ListIterator: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def ensureCapacity(self, arg0: Union[int, JInt], ) -> None: ...
	def retainAll(self, arg0: javawrappers.java.util.Collection, ) -> Union[int, JBoolean]: ...


class LineSegment:
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.LineSegment, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, ): ...
	@overload
	def __init__(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], ): ...
	@overload
	def __init__(self, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@overload
	def distance(self, arg0: javawrappers.org.locationtech.jts.geom.LineSegment, ) -> Union[float, JDouble]: ...
	@overload
	def distance(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[float, JDouble]: ...
	def equalsTopo(self, arg0: javawrappers.org.locationtech.jts.geom.LineSegment, ) -> Union[int, JBoolean]: ...
	def maxY(self, ) -> Union[float, JDouble]: ...
	def notifyAll(self, ) -> None: ...
	def distancePerpendicular(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[float, JDouble]: ...
	def maxX(self, ) -> Union[float, JDouble]: ...
	@overload
	def project(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	@overload
	def project(self, arg0: javawrappers.org.locationtech.jts.geom.LineSegment, ) -> javawrappers.org.locationtech.jts.geom.LineSegment: ...
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	def notify(self, ) -> None: ...
	def isHorizontal(self, ) -> Union[int, JBoolean]: ...
	def pointAlongOffset(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def closestPoints(self, arg0: javawrappers.org.locationtech.jts.geom.LineSegment, ) -> JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1): ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def normalize(self, ) -> None: ...
	def intersection(self, arg0: javawrappers.org.locationtech.jts.geom.LineSegment, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def toGeometry(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryFactory, ) -> javawrappers.org.locationtech.jts.geom.LineString: ...
	def angle(self, ) -> Union[float, JDouble]: ...
	def pointAlong(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def closestPoint(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def projectionFactor(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[float, JDouble]: ...
	@overload
	def orientationIndex(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JInt]: ...
	@overload
	def orientationIndex(self, arg0: javawrappers.org.locationtech.jts.geom.LineSegment, ) -> Union[int, JInt]: ...
	@overload
	@staticmethod
	def midPoint(arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	@overload
	def midPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def segmentFraction(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[float, JDouble]: ...
	def reverse(self, ) -> None: ...
	def lineIntersection(self, arg0: javawrappers.org.locationtech.jts.geom.LineSegment, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def getCoordinate(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def isVertical(self, ) -> Union[int, JBoolean]: ...
	def minY(self, ) -> Union[float, JDouble]: ...
	def minX(self, ) -> Union[float, JDouble]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def setCoordinates(self, arg0: javawrappers.org.locationtech.jts.geom.LineSegment, ) -> None: ...
	@overload
	def setCoordinates(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> None: ...
	def getLength(self, ) -> Union[float, JDouble]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...


class GeometryCollection:
	@overload
	def __init__(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Geometry, 1), arg1: javawrappers.org.locationtech.jts.geom.PrecisionModel, arg2: Union[int, JInt], ): ...
	@overload
	def __init__(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Geometry, 1), arg1: javawrappers.org.locationtech.jts.geom.GeometryFactory, ): ...
	def getGeometryN(self, arg0: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def equalsNorm(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def equalsTopo(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def coveredBy(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def geometryChanged(self, ) -> None: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.org.locationtech.jts.geom.CoordinateSequenceComparator, ) -> Union[int, JInt]: ...
	def getEnvelopeInternal(self, ) -> javawrappers.org.locationtech.jts.geom.Envelope: ...
	def crosses(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def norm(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.IntersectionMatrix: ...
	@overload
	def relate(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: javawrappers.java.lang.String, ) -> Union[int, JBoolean]: ...
	def getSRID(self, ) -> Union[int, JInt]: ...
	def disjoint(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def intersection(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def normalize(self, ) -> None: ...
	def overlaps(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getDimension(self, ) -> Union[int, JInt]: ...
	def isSimple(self, ) -> Union[int, JBoolean]: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def buffer(self, arg0: Union[float, JDouble], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def equalsExact(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getCentroid(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def getCoordinates(self, ) -> JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1): ...
	def contains(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def isWithinDistance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getNumGeometries(self, ) -> Union[int, JInt]: ...
	def difference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def setUserData(self, arg0: javawrappers.java.lang.Object, ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def distance(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[float, JDouble]: ...
	def getNumPoints(self, ) -> Union[int, JInt]: ...
	def intersects(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def notifyAll(self, ) -> None: ...
	def notify(self, ) -> None: ...
	def setSRID(self, arg0: Union[int, JInt], ) -> None: ...
	def getInteriorPoint(self, ) -> javawrappers.org.locationtech.jts.geom.Point: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def copy(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def convexHull(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def covers(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def within(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryComponentFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.GeometryFilter, ) -> None: ...
	@overload
	def apply(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequenceFilter, ) -> None: ...
	def getBoundary(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def isValid(self, ) -> Union[int, JBoolean]: ...
	def getGeometryType(self, ) -> javawrappers.java.lang.String: ...
	def isEmpty(self, ) -> Union[int, JBoolean]: ...
	@overload
	def union(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	@overload
	def union(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getFactory(self, ) -> javawrappers.org.locationtech.jts.geom.GeometryFactory: ...
	def reverse(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def symDifference(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getBoundaryDimension(self, ) -> Union[int, JInt]: ...
	def touches(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	def getCoordinate(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	def getPrecisionModel(self, ) -> javawrappers.org.locationtech.jts.geom.PrecisionModel: ...
	@overload
	def equals(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def isRectangle(self, ) -> Union[int, JBoolean]: ...
	def clone(self, ) -> javawrappers.java.lang.Object: ...
	def getLength(self, ) -> Union[float, JDouble]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def getEnvelope(self, ) -> javawrappers.org.locationtech.jts.geom.Geometry: ...
	def getUserData(self, ) -> javawrappers.java.lang.Object: ...
	def toText(self, ) -> javawrappers.java.lang.String: ...
	def getArea(self, ) -> Union[float, JDouble]: ...


class CoordinateXYZM:
	@overload
	def __init__(self, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateXYZM, ): ...
	@overload
	def __init__(self, arg0: Union[float, JDouble], arg1: Union[float, JDouble], arg2: Union[float, JDouble], arg3: Union[float, JDouble], ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def setY(self, arg0: Union[float, JDouble], ) -> None: ...
	def setX(self, arg0: Union[float, JDouble], ) -> None: ...
	def distance(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[float, JDouble]: ...
	def notifyAll(self, ) -> None: ...
	def getM(self, ) -> Union[float, JDouble]: ...
	@overload
	def compareTo(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	def setZ(self, arg0: Union[float, JDouble], ) -> None: ...
	def notify(self, ) -> None: ...
	def setOrdinate(self, arg0: Union[int, JInt], arg1: Union[float, JDouble], ) -> None: ...
	@overload
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	@staticmethod
	def hashCode(arg0: Union[float, JDouble], ) -> Union[int, JInt]: ...
	def equals3D(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	def distance3D(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[float, JDouble]: ...
	@overload
	def copy(self, ) -> javawrappers.org.locationtech.jts.geom.Coordinate: ...
	@overload
	def copy(self, ) -> javawrappers.org.locationtech.jts.geom.CoordinateXYZM: ...
	def setM(self, arg0: Union[float, JDouble], ) -> None: ...
	def getOrdinate(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	def equalInZ(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	def getX(self, ) -> Union[float, JDouble]: ...
	def getY(self, ) -> Union[float, JDouble]: ...
	def getZ(self, ) -> Union[float, JDouble]: ...
	@overload
	def equals2D(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, arg1: Union[float, JDouble], ) -> Union[int, JBoolean]: ...
	@overload
	def equals2D(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> Union[int, JBoolean]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def clone(self, ) -> javawrappers.java.lang.Object: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def setCoordinate(self, arg0: javawrappers.org.locationtech.jts.geom.Coordinate, ) -> None: ...


class IntersectionMatrix:
	@overload
	def __init__(self, arg0: javawrappers.java.lang.String, ): ...
	@overload
	def __init__(self, arg0: javawrappers.org.locationtech.jts.geom.IntersectionMatrix, ): ...
	@overload
	def __init__(self, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def isCoveredBy(self, ) -> Union[int, JBoolean]: ...
	def notifyAll(self, ) -> None: ...
	def isContains(self, ) -> Union[int, JBoolean]: ...
	def notify(self, ) -> None: ...
	def isWithin(self, ) -> Union[int, JBoolean]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def isCovers(self, ) -> Union[int, JBoolean]: ...
	def get(self, arg0: Union[int, JInt], arg1: Union[int, JInt], ) -> Union[int, JInt]: ...
	def setAll(self, arg0: Union[int, JInt], ) -> None: ...
	def isOverlaps(self, arg0: Union[int, JInt], arg1: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	def add(self, arg0: javawrappers.org.locationtech.jts.geom.IntersectionMatrix, ) -> None: ...
	def isIntersects(self, ) -> Union[int, JBoolean]: ...
	@overload
	def set(self, arg0: javawrappers.java.lang.String, ) -> None: ...
	@overload
	def set(self, arg0: Union[int, JInt], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> None: ...
	def isDisjoint(self, ) -> Union[int, JBoolean]: ...
	def setAtLeastIfValid(self, arg0: Union[int, JInt], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> None: ...
	@overload
	@staticmethod
	def matches(arg0: Union[int, JInt], arg1: Union[string, JString], ) -> Union[int, JBoolean]: ...
	@overload
	@staticmethod
	def matches(arg0: javawrappers.java.lang.String, arg1: javawrappers.java.lang.String, ) -> Union[int, JBoolean]: ...
	@overload
	def matches(self, arg0: javawrappers.java.lang.String, ) -> Union[int, JBoolean]: ...
	def isTouches(self, arg0: Union[int, JInt], arg1: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	def isCrosses(self, arg0: Union[int, JInt], arg1: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	@staticmethod
	def isTrue(arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def transpose(self, ) -> javawrappers.org.locationtech.jts.geom.IntersectionMatrix: ...
	def isEquals(self, arg0: Union[int, JInt], arg1: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	@overload
	def setAtLeast(self, arg0: javawrappers.java.lang.String, ) -> None: ...
	@overload
	def setAtLeast(self, arg0: Union[int, JInt], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> None: ...


class DefaultCoordinateSequenceFactory:
	def __init__(self, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@staticmethod
	def instance() -> javawrappers.org.locationtech.jts.geom.DefaultCoordinateSequenceFactory: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def create(self, arg0: Union[int, JInt], arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	@overload
	def create(self, arg0: Union[int, JInt], arg1: Union[int, JInt], ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	@overload
	def create(self, arg0: JArray(javawrappers.org.locationtech.jts.geom.Coordinate, 1), ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	@overload
	def create(self, arg0: javawrappers.org.locationtech.jts.geom.CoordinateSequence, ) -> javawrappers.org.locationtech.jts.geom.CoordinateSequence: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def notify(self, ) -> None: ...


class GeometryComponentFilter:
	def filter(self, arg0: javawrappers.org.locationtech.jts.geom.Geometry, ) -> None: ...


