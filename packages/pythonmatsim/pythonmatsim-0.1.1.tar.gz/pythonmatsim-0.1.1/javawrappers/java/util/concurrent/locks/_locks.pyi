################################################################################
#          This file was automatically generated. Please do not edit.          #
################################################################################

import javawrappers.java.lang
import javawrappers.java.util
import javawrappers.java.util.concurrent
import javawrappers.java.util.function
import javawrappers.java.util.concurrent.locks

from jpype.types import *
from typing import Union

from typing import overload

class ReentrantLock:
	@overload
	def __init__(self, ): ...
	@overload
	def __init__(self, arg0: Union[int, JBoolean], ): ...
	class FairSync:
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def getFirstQueuedThread(self, ) -> javawrappers.java.lang.Thread: ...
		def release(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
		def notifyAll(self, ) -> None: ...
		def acquireShared(self, arg0: Union[int, JInt], ) -> None: ...
		def acquire(self, arg0: Union[int, JInt], ) -> None: ...
		def notify(self, ) -> None: ...
		def releaseShared(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def owns(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> Union[int, JBoolean]: ...
		def hasQueuedThreads(self, ) -> Union[int, JBoolean]: ...
		def isQueued(self, arg0: javawrappers.java.lang.Thread, ) -> Union[int, JBoolean]: ...
		def acquireSharedInterruptibly(self, arg0: Union[int, JInt], ) -> None: ...
		def getQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
		def getExclusiveQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
		def tryAcquireSharedNanos(self, arg0: Union[int, JInt], arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...
		def getWaitQueueLength(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> Union[int, JInt]: ...
		def getQueueLength(self, ) -> Union[int, JInt]: ...
		def tryAcquireNanos(self, arg0: Union[int, JInt], arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...
		def acquireInterruptibly(self, arg0: Union[int, JInt], ) -> None: ...
		def hasContended(self, ) -> Union[int, JBoolean]: ...
		def hasQueuedPredecessors(self, ) -> Union[int, JBoolean]: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def getSharedQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
		def hasWaiters(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> Union[int, JBoolean]: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def getWaitingThreads(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> javawrappers.java.util.Collection: ...


	class NonfairSync:
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def getFirstQueuedThread(self, ) -> javawrappers.java.lang.Thread: ...
		def release(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
		def notifyAll(self, ) -> None: ...
		def acquireShared(self, arg0: Union[int, JInt], ) -> None: ...
		def acquire(self, arg0: Union[int, JInt], ) -> None: ...
		def notify(self, ) -> None: ...
		def releaseShared(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def owns(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> Union[int, JBoolean]: ...
		def hasQueuedThreads(self, ) -> Union[int, JBoolean]: ...
		def isQueued(self, arg0: javawrappers.java.lang.Thread, ) -> Union[int, JBoolean]: ...
		def acquireSharedInterruptibly(self, arg0: Union[int, JInt], ) -> None: ...
		def getQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
		def getExclusiveQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
		def tryAcquireSharedNanos(self, arg0: Union[int, JInt], arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...
		def getWaitQueueLength(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> Union[int, JInt]: ...
		def getQueueLength(self, ) -> Union[int, JInt]: ...
		def tryAcquireNanos(self, arg0: Union[int, JInt], arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...
		def acquireInterruptibly(self, arg0: Union[int, JInt], ) -> None: ...
		def hasContended(self, ) -> Union[int, JBoolean]: ...
		def hasQueuedPredecessors(self, ) -> Union[int, JBoolean]: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def getSharedQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
		def hasWaiters(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> Union[int, JBoolean]: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def getWaitingThreads(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> javawrappers.java.util.Collection: ...


	class Sync:
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def getFirstQueuedThread(self, ) -> javawrappers.java.lang.Thread: ...
		def release(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
		def notifyAll(self, ) -> None: ...
		def acquireShared(self, arg0: Union[int, JInt], ) -> None: ...
		def acquire(self, arg0: Union[int, JInt], ) -> None: ...
		def notify(self, ) -> None: ...
		def releaseShared(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def owns(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> Union[int, JBoolean]: ...
		def hasQueuedThreads(self, ) -> Union[int, JBoolean]: ...
		def isQueued(self, arg0: javawrappers.java.lang.Thread, ) -> Union[int, JBoolean]: ...
		def acquireSharedInterruptibly(self, arg0: Union[int, JInt], ) -> None: ...
		def getQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
		def getExclusiveQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
		def tryAcquireSharedNanos(self, arg0: Union[int, JInt], arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...
		def getWaitQueueLength(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> Union[int, JInt]: ...
		def getQueueLength(self, ) -> Union[int, JInt]: ...
		def tryAcquireNanos(self, arg0: Union[int, JInt], arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...
		def acquireInterruptibly(self, arg0: Union[int, JInt], ) -> None: ...
		def hasContended(self, ) -> Union[int, JBoolean]: ...
		def hasQueuedPredecessors(self, ) -> Union[int, JBoolean]: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def getSharedQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
		def hasWaiters(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> Union[int, JBoolean]: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def getWaitingThreads(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> javawrappers.java.util.Collection: ...


	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def getFirstQueuedThread(self, ) -> javawrappers.java.lang.Thread: ...
	def release(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	def notifyAll(self, ) -> None: ...
	def acquireShared(self, arg0: Union[int, JInt], ) -> None: ...
	def isFair(self, ) -> Union[int, JBoolean]: ...
	def acquire(self, arg0: Union[int, JInt], ) -> None: ...
	def notify(self, ) -> None: ...
	def releaseShared(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	def newCondition(self, ) -> javawrappers.java.util.concurrent.locks.Condition: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def isLocked(self, ) -> Union[int, JBoolean]: ...
	def hasQueuedThread(self, arg0: javawrappers.java.lang.Thread, ) -> Union[int, JBoolean]: ...
	def owns(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> Union[int, JBoolean]: ...
	def isHeldByCurrentThread(self, ) -> Union[int, JBoolean]: ...
	def lock(self, ) -> None: ...
	@overload
	def hasQueuedThreads(self, ) -> Union[int, JBoolean]: ...
	@overload
	def hasQueuedThreads(self, ) -> Union[int, JBoolean]: ...
	def getHoldCount(self, ) -> Union[int, JInt]: ...
	def isQueued(self, arg0: javawrappers.java.lang.Thread, ) -> Union[int, JBoolean]: ...
	def acquireSharedInterruptibly(self, arg0: Union[int, JInt], ) -> None: ...
	def getQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
	def getExclusiveQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
	def unlock(self, ) -> None: ...
	def tryAcquireSharedNanos(self, arg0: Union[int, JInt], arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	@overload
	def getWaitQueueLength(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> Union[int, JInt]: ...
	@overload
	def getWaitQueueLength(self, arg0: javawrappers.java.util.concurrent.locks.Condition, ) -> Union[int, JInt]: ...
	@overload
	def getQueueLength(self, ) -> Union[int, JInt]: ...
	@overload
	def getQueueLength(self, ) -> Union[int, JInt]: ...
	def tryAcquireNanos(self, arg0: Union[int, JInt], arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	def acquireInterruptibly(self, arg0: Union[int, JInt], ) -> None: ...
	@overload
	def tryLock(self, ) -> Union[int, JBoolean]: ...
	@overload
	def tryLock(self, arg0: Union[long, JLong], arg1: javawrappers.java.util.concurrent.TimeUnit, ) -> Union[int, JBoolean]: ...
	def hasContended(self, ) -> Union[int, JBoolean]: ...
	def lockInterruptibly(self, ) -> None: ...
	def hasQueuedPredecessors(self, ) -> Union[int, JBoolean]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def getSharedQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
	@overload
	def hasWaiters(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> Union[int, JBoolean]: ...
	@overload
	def hasWaiters(self, arg0: javawrappers.java.util.concurrent.locks.Condition, ) -> Union[int, JBoolean]: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def getWaitingThreads(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> javawrappers.java.util.Collection: ...


class Lock:
	def unlock(self, ) -> None: ...
	def lockInterruptibly(self, ) -> None: ...
	def newCondition(self, ) -> javawrappers.java.util.concurrent.locks.Condition: ...
	def lock(self, ) -> None: ...
	@overload
	def tryLock(self, arg0: Union[long, JLong], arg1: javawrappers.java.util.concurrent.TimeUnit, ) -> Union[int, JBoolean]: ...
	@overload
	def tryLock(self, ) -> Union[int, JBoolean]: ...


class Condition:
	def signalAll(self, ) -> None: ...
	def awaitNanos(self, arg0: Union[long, JLong], ) -> Union[long, JLong]: ...
	@overload
	def await(self, arg0: Union[long, JLong], arg1: javawrappers.java.util.concurrent.TimeUnit, ) -> Union[int, JBoolean]: ...
	@overload
	def await(self, ) -> None: ...
	def awaitUninterruptibly(self, ) -> None: ...
	def signal(self, ) -> None: ...
	def awaitUntil(self, arg0: javawrappers.java.util.Date, ) -> Union[int, JBoolean]: ...


class AbstractQueuedSynchronizer:
	class ConditionObject:
		def __init__(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer, ): ...
		def signalAll(self, ) -> None: ...
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def awaitNanos(self, arg0: Union[long, JLong], ) -> Union[long, JLong]: ...
		@overload
		def await(self, arg0: Union[long, JLong], arg1: javawrappers.java.util.concurrent.TimeUnit, ) -> Union[int, JBoolean]: ...
		@overload
		def await(self, ) -> None: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def awaitUninterruptibly(self, ) -> None: ...
		def signal(self, ) -> None: ...
		def notify(self, ) -> None: ...
		def awaitUntil(self, arg0: javawrappers.java.util.Date, ) -> Union[int, JBoolean]: ...


	class Node:
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def notify(self, ) -> None: ...


	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def getFirstQueuedThread(self, ) -> javawrappers.java.lang.Thread: ...
	def release(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	def awaitNanos(self, arg0: Union[long, JLong], ) -> Union[long, JLong]: ...
	def notifyAll(self, ) -> None: ...
	def acquireShared(self, arg0: Union[int, JInt], ) -> None: ...
	def awaitUninterruptibly(self, ) -> None: ...
	def acquire(self, arg0: Union[int, JInt], ) -> None: ...
	def notify(self, ) -> None: ...
	def releaseShared(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def await(self, arg0: Union[long, JLong], arg1: javawrappers.java.util.concurrent.TimeUnit, ) -> Union[int, JBoolean]: ...
	@overload
	def await(self, ) -> None: ...
	def owns(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> Union[int, JBoolean]: ...
	def hasQueuedThreads(self, ) -> Union[int, JBoolean]: ...
	def signal(self, ) -> None: ...
	def isQueued(self, arg0: javawrappers.java.lang.Thread, ) -> Union[int, JBoolean]: ...
	def acquireSharedInterruptibly(self, arg0: Union[int, JInt], ) -> None: ...
	def awaitUntil(self, arg0: javawrappers.java.util.Date, ) -> Union[int, JBoolean]: ...
	def signalAll(self, ) -> None: ...
	def getQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
	def getExclusiveQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
	def tryAcquireSharedNanos(self, arg0: Union[int, JInt], arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	def getWaitQueueLength(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> Union[int, JInt]: ...
	def getQueueLength(self, ) -> Union[int, JInt]: ...
	def tryAcquireNanos(self, arg0: Union[int, JInt], arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	def acquireInterruptibly(self, arg0: Union[int, JInt], ) -> None: ...
	def hasContended(self, ) -> Union[int, JBoolean]: ...
	def hasQueuedPredecessors(self, ) -> Union[int, JBoolean]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def getSharedQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
	def hasWaiters(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> Union[int, JBoolean]: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def getWaitingThreads(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> javawrappers.java.util.Collection: ...


class AbstractQueuedLongSynchronizer:
	class ConditionObject:
		def __init__(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedLongSynchronizer, ): ...
		def signalAll(self, ) -> None: ...
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def awaitNanos(self, arg0: Union[long, JLong], ) -> Union[long, JLong]: ...
		@overload
		def await(self, arg0: Union[long, JLong], arg1: javawrappers.java.util.concurrent.TimeUnit, ) -> Union[int, JBoolean]: ...
		@overload
		def await(self, ) -> None: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def awaitUninterruptibly(self, ) -> None: ...
		def signal(self, ) -> None: ...
		def notify(self, ) -> None: ...
		def awaitUntil(self, arg0: javawrappers.java.util.Date, ) -> Union[int, JBoolean]: ...


	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def getFirstQueuedThread(self, ) -> javawrappers.java.lang.Thread: ...
	def release(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	def awaitNanos(self, arg0: Union[long, JLong], ) -> Union[long, JLong]: ...
	def notifyAll(self, ) -> None: ...
	def acquireShared(self, arg0: Union[long, JLong], ) -> None: ...
	def awaitUninterruptibly(self, ) -> None: ...
	def acquire(self, arg0: Union[long, JLong], ) -> None: ...
	def notify(self, ) -> None: ...
	def releaseShared(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def await(self, arg0: Union[long, JLong], arg1: javawrappers.java.util.concurrent.TimeUnit, ) -> Union[int, JBoolean]: ...
	@overload
	def await(self, ) -> None: ...
	def owns(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject, ) -> Union[int, JBoolean]: ...
	def hasQueuedThreads(self, ) -> Union[int, JBoolean]: ...
	def signal(self, ) -> None: ...
	def isQueued(self, arg0: javawrappers.java.lang.Thread, ) -> Union[int, JBoolean]: ...
	def acquireSharedInterruptibly(self, arg0: Union[long, JLong], ) -> None: ...
	def awaitUntil(self, arg0: javawrappers.java.util.Date, ) -> Union[int, JBoolean]: ...
	def signalAll(self, ) -> None: ...
	def getQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
	def getExclusiveQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
	def tryAcquireSharedNanos(self, arg0: Union[long, JLong], arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	def getWaitQueueLength(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject, ) -> Union[int, JInt]: ...
	def getQueueLength(self, ) -> Union[int, JInt]: ...
	def tryAcquireNanos(self, arg0: Union[long, JLong], arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	def acquireInterruptibly(self, arg0: Union[long, JLong], ) -> None: ...
	def hasContended(self, ) -> Union[int, JBoolean]: ...
	def hasQueuedPredecessors(self, ) -> Union[int, JBoolean]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def getSharedQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
	def hasWaiters(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject, ) -> Union[int, JBoolean]: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def getWaitingThreads(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject, ) -> javawrappers.java.util.Collection: ...


class ReentrantReadWriteLock:
	@overload
	def __init__(self, arg0: Union[int, JBoolean], ): ...
	@overload
	def __init__(self, ): ...
	class WriteLock:
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def unlock(self, ) -> None: ...
		def notifyAll(self, ) -> None: ...
		def notify(self, ) -> None: ...
		@overload
		def tryLock(self, arg0: Union[long, JLong], arg1: javawrappers.java.util.concurrent.TimeUnit, ) -> Union[int, JBoolean]: ...
		@overload
		def tryLock(self, ) -> Union[int, JBoolean]: ...
		def lockInterruptibly(self, ) -> None: ...
		def newCondition(self, ) -> javawrappers.java.util.concurrent.locks.Condition: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def isHeldByCurrentThread(self, ) -> Union[int, JBoolean]: ...
		def lock(self, ) -> None: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def getHoldCount(self, ) -> Union[int, JInt]: ...


	class ReadLock:
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def unlock(self, ) -> None: ...
		def lockInterruptibly(self, ) -> None: ...
		def newCondition(self, ) -> javawrappers.java.util.concurrent.locks.Condition: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def lock(self, ) -> None: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def notify(self, ) -> None: ...
		@overload
		def tryLock(self, arg0: Union[long, JLong], arg1: javawrappers.java.util.concurrent.TimeUnit, ) -> Union[int, JBoolean]: ...
		@overload
		def tryLock(self, ) -> Union[int, JBoolean]: ...


	class FairSync:
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def getFirstQueuedThread(self, ) -> javawrappers.java.lang.Thread: ...
		def release(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
		def notifyAll(self, ) -> None: ...
		def acquireShared(self, arg0: Union[int, JInt], ) -> None: ...
		def acquire(self, arg0: Union[int, JInt], ) -> None: ...
		def notify(self, ) -> None: ...
		def releaseShared(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def owns(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> Union[int, JBoolean]: ...
		def hasQueuedThreads(self, ) -> Union[int, JBoolean]: ...
		def isQueued(self, arg0: javawrappers.java.lang.Thread, ) -> Union[int, JBoolean]: ...
		def acquireSharedInterruptibly(self, arg0: Union[int, JInt], ) -> None: ...
		def getQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
		def getExclusiveQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
		def tryAcquireSharedNanos(self, arg0: Union[int, JInt], arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...
		def getWaitQueueLength(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> Union[int, JInt]: ...
		def getQueueLength(self, ) -> Union[int, JInt]: ...
		def tryAcquireNanos(self, arg0: Union[int, JInt], arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...
		def acquireInterruptibly(self, arg0: Union[int, JInt], ) -> None: ...
		def hasContended(self, ) -> Union[int, JBoolean]: ...
		def hasQueuedPredecessors(self, ) -> Union[int, JBoolean]: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def getSharedQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
		def hasWaiters(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> Union[int, JBoolean]: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def getWaitingThreads(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> javawrappers.java.util.Collection: ...


	class NonfairSync:
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def getFirstQueuedThread(self, ) -> javawrappers.java.lang.Thread: ...
		def release(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
		def notifyAll(self, ) -> None: ...
		def acquireShared(self, arg0: Union[int, JInt], ) -> None: ...
		def acquire(self, arg0: Union[int, JInt], ) -> None: ...
		def notify(self, ) -> None: ...
		def releaseShared(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def owns(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> Union[int, JBoolean]: ...
		def hasQueuedThreads(self, ) -> Union[int, JBoolean]: ...
		def isQueued(self, arg0: javawrappers.java.lang.Thread, ) -> Union[int, JBoolean]: ...
		def acquireSharedInterruptibly(self, arg0: Union[int, JInt], ) -> None: ...
		def getQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
		def getExclusiveQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
		def tryAcquireSharedNanos(self, arg0: Union[int, JInt], arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...
		def getWaitQueueLength(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> Union[int, JInt]: ...
		def getQueueLength(self, ) -> Union[int, JInt]: ...
		def tryAcquireNanos(self, arg0: Union[int, JInt], arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...
		def acquireInterruptibly(self, arg0: Union[int, JInt], ) -> None: ...
		def hasContended(self, ) -> Union[int, JBoolean]: ...
		def hasQueuedPredecessors(self, ) -> Union[int, JBoolean]: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def getSharedQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
		def hasWaiters(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> Union[int, JBoolean]: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def getWaitingThreads(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> javawrappers.java.util.Collection: ...


	class Sync:
		class ThreadLocalHoldCounter:
			def getClass(self, ) -> javawrappers.java.lang.Class: ...
			@overload
			def wait(self, arg0: Union[long, JLong], ) -> None: ...
			@overload
			def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
			@overload
			def wait(self, ) -> None: ...
			def set(self, arg0: javawrappers.java.lang.Object, ) -> None: ...
			def hashCode(self, ) -> Union[int, JInt]: ...
			def notifyAll(self, ) -> None: ...
			def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
			def get(self, ) -> javawrappers.java.lang.Object: ...
			def toString(self, ) -> javawrappers.java.lang.String: ...
			@staticmethod
			def withInitial(arg0: javawrappers.java.util.function.Supplier, ) -> javawrappers.java.lang.ThreadLocal: ...
			@overload
			def initialValue(self, ) -> javawrappers.java.util.concurrent.locks.ReentrantReadWriteLock.Sync.HoldCounter: ...
			@overload
			def initialValue(self, ) -> javawrappers.java.lang.Object: ...
			def notify(self, ) -> None: ...
			def remove(self, ) -> None: ...


		class HoldCounter:
			def getClass(self, ) -> javawrappers.java.lang.Class: ...
			@overload
			def wait(self, arg0: Union[long, JLong], ) -> None: ...
			@overload
			def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
			@overload
			def wait(self, ) -> None: ...
			def hashCode(self, ) -> Union[int, JInt]: ...
			def notifyAll(self, ) -> None: ...
			def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
			def toString(self, ) -> javawrappers.java.lang.String: ...
			def notify(self, ) -> None: ...


		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def getFirstQueuedThread(self, ) -> javawrappers.java.lang.Thread: ...
		def release(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
		def notifyAll(self, ) -> None: ...
		def acquireShared(self, arg0: Union[int, JInt], ) -> None: ...
		def acquire(self, arg0: Union[int, JInt], ) -> None: ...
		def remove(self, ) -> None: ...
		def notify(self, ) -> None: ...
		def releaseShared(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def get(self, ) -> javawrappers.java.lang.Object: ...
		def owns(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> Union[int, JBoolean]: ...
		@staticmethod
		def withInitial(arg0: javawrappers.java.util.function.Supplier, ) -> javawrappers.java.lang.ThreadLocal: ...
		def hasQueuedThreads(self, ) -> Union[int, JBoolean]: ...
		@overload
		def initialValue(self, ) -> javawrappers.java.util.concurrent.locks.ReentrantReadWriteLock.Sync.HoldCounter: ...
		@overload
		def initialValue(self, ) -> javawrappers.java.lang.Object: ...
		def isQueued(self, arg0: javawrappers.java.lang.Thread, ) -> Union[int, JBoolean]: ...
		def acquireSharedInterruptibly(self, arg0: Union[int, JInt], ) -> None: ...
		def getQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
		def set(self, arg0: javawrappers.java.lang.Object, ) -> None: ...
		def getExclusiveQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
		def tryAcquireSharedNanos(self, arg0: Union[int, JInt], arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...
		def getWaitQueueLength(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> Union[int, JInt]: ...
		def getQueueLength(self, ) -> Union[int, JInt]: ...
		def tryAcquireNanos(self, arg0: Union[int, JInt], arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...
		def acquireInterruptibly(self, arg0: Union[int, JInt], ) -> None: ...
		def hasContended(self, ) -> Union[int, JBoolean]: ...
		def hasQueuedPredecessors(self, ) -> Union[int, JBoolean]: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def getSharedQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
		def hasWaiters(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> Union[int, JBoolean]: ...
		@overload
		def toString(self, ) -> javawrappers.java.lang.String: ...
		@overload
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def getWaitingThreads(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> javawrappers.java.util.Collection: ...


	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def getFirstQueuedThread(self, ) -> javawrappers.java.lang.Thread: ...
	@overload
	def writeLock(self, ) -> javawrappers.java.util.concurrent.locks.Lock: ...
	@overload
	def writeLock(self, ) -> javawrappers.java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock: ...
	def release(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	def isWriteLockedByCurrentThread(self, ) -> Union[int, JBoolean]: ...
	def releaseShared(self, arg0: Union[int, JInt], ) -> Union[int, JBoolean]: ...
	@overload
	def newCondition(self, ) -> javawrappers.java.util.concurrent.locks.Condition: ...
	@overload
	def newCondition(self, ) -> javawrappers.java.util.concurrent.locks.Condition: ...
	def hasQueuedThread(self, arg0: javawrappers.java.lang.Thread, ) -> Union[int, JBoolean]: ...
	def isHeldByCurrentThread(self, ) -> Union[int, JBoolean]: ...
	@overload
	def lock(self, ) -> None: ...
	@overload
	def lock(self, ) -> None: ...
	def owns(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> Union[int, JBoolean]: ...
	@overload
	def initialValue(self, ) -> javawrappers.java.util.concurrent.locks.ReentrantReadWriteLock.Sync.HoldCounter: ...
	@overload
	def initialValue(self, ) -> javawrappers.java.lang.Object: ...
	def isQueued(self, arg0: javawrappers.java.lang.Thread, ) -> Union[int, JBoolean]: ...
	def acquireSharedInterruptibly(self, arg0: Union[int, JInt], ) -> None: ...
	def getQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
	@overload
	def unlock(self, ) -> None: ...
	@overload
	def unlock(self, ) -> None: ...
	def getExclusiveQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
	@overload
	def readLock(self, ) -> javawrappers.java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock: ...
	@overload
	def readLock(self, ) -> javawrappers.java.util.concurrent.locks.Lock: ...
	@overload
	def getWaitQueueLength(self, arg0: javawrappers.java.util.concurrent.locks.Condition, ) -> Union[int, JInt]: ...
	@overload
	def getWaitQueueLength(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> Union[int, JInt]: ...
	@overload
	def getQueueLength(self, ) -> Union[int, JInt]: ...
	@overload
	def getQueueLength(self, ) -> Union[int, JInt]: ...
	def acquireInterruptibly(self, arg0: Union[int, JInt], ) -> None: ...
	@overload
	def tryLock(self, arg0: Union[long, JLong], arg1: javawrappers.java.util.concurrent.TimeUnit, ) -> Union[int, JBoolean]: ...
	@overload
	def tryLock(self, ) -> Union[int, JBoolean]: ...
	@overload
	def tryLock(self, arg0: Union[long, JLong], arg1: javawrappers.java.util.concurrent.TimeUnit, ) -> Union[int, JBoolean]: ...
	@overload
	def tryLock(self, ) -> Union[int, JBoolean]: ...
	def hasContended(self, ) -> Union[int, JBoolean]: ...
	@overload
	def lockInterruptibly(self, ) -> None: ...
	@overload
	def lockInterruptibly(self, ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def notifyAll(self, ) -> None: ...
	def acquireShared(self, arg0: Union[int, JInt], ) -> None: ...
	def isFair(self, ) -> Union[int, JBoolean]: ...
	def acquire(self, arg0: Union[int, JInt], ) -> None: ...
	def remove(self, ) -> None: ...
	def notify(self, ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def getReadHoldCount(self, ) -> Union[int, JInt]: ...
	def get(self, ) -> javawrappers.java.lang.Object: ...
	@staticmethod
	def withInitial(arg0: javawrappers.java.util.function.Supplier, ) -> javawrappers.java.lang.ThreadLocal: ...
	@overload
	def hasQueuedThreads(self, ) -> Union[int, JBoolean]: ...
	@overload
	def hasQueuedThreads(self, ) -> Union[int, JBoolean]: ...
	def getHoldCount(self, ) -> Union[int, JInt]: ...
	def isWriteLocked(self, ) -> Union[int, JBoolean]: ...
	def set(self, arg0: javawrappers.java.lang.Object, ) -> None: ...
	def getReadLockCount(self, ) -> Union[int, JInt]: ...
	def tryAcquireSharedNanos(self, arg0: Union[int, JInt], arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	def tryAcquireNanos(self, arg0: Union[int, JInt], arg1: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	def getWriteHoldCount(self, ) -> Union[int, JInt]: ...
	def hasQueuedPredecessors(self, ) -> Union[int, JBoolean]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def getSharedQueuedThreads(self, ) -> javawrappers.java.util.Collection: ...
	@overload
	def hasWaiters(self, arg0: javawrappers.java.util.concurrent.locks.Condition, ) -> Union[int, JBoolean]: ...
	@overload
	def hasWaiters(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> Union[int, JBoolean]: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def getWaitingThreads(self, arg0: javawrappers.java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject, ) -> javawrappers.java.util.Collection: ...


class AbstractOwnableSynchronizer:
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def notify(self, ) -> None: ...


class LockSupport:
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@staticmethod
	def getBlocker(arg0: javawrappers.java.lang.Thread, ) -> javawrappers.java.lang.Object: ...
	@overload
	@staticmethod
	def parkUntil(arg0: Union[long, JLong], ) -> None: ...
	@overload
	@staticmethod
	def parkUntil(arg0: javawrappers.java.lang.Object, arg1: Union[long, JLong], ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@staticmethod
	def unpark(arg0: javawrappers.java.lang.Thread, ) -> None: ...
	@overload
	@staticmethod
	def parkNanos(arg0: Union[long, JLong], ) -> None: ...
	@overload
	@staticmethod
	def parkNanos(arg0: javawrappers.java.lang.Object, arg1: Union[long, JLong], ) -> None: ...
	def notify(self, ) -> None: ...
	@overload
	@staticmethod
	def park() -> None: ...
	@overload
	@staticmethod
	def park(arg0: javawrappers.java.lang.Object, ) -> None: ...


class StampedLock:
	def __init__(self, ): ...
	class ReadWriteLockView:
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def writeLock(self, ) -> javawrappers.java.util.concurrent.locks.Lock: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def readLock(self, ) -> javawrappers.java.util.concurrent.locks.Lock: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def notify(self, ) -> None: ...


	class WriteLockView:
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def unlock(self, ) -> None: ...
		def lockInterruptibly(self, ) -> None: ...
		def newCondition(self, ) -> javawrappers.java.util.concurrent.locks.Condition: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def lock(self, ) -> None: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def notify(self, ) -> None: ...
		@overload
		def tryLock(self, arg0: Union[long, JLong], arg1: javawrappers.java.util.concurrent.TimeUnit, ) -> Union[int, JBoolean]: ...
		@overload
		def tryLock(self, ) -> Union[int, JBoolean]: ...


	class ReadLockView:
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def unlock(self, ) -> None: ...
		def lockInterruptibly(self, ) -> None: ...
		def newCondition(self, ) -> javawrappers.java.util.concurrent.locks.Condition: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def lock(self, ) -> None: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def notify(self, ) -> None: ...
		@overload
		def tryLock(self, arg0: Union[long, JLong], arg1: javawrappers.java.util.concurrent.TimeUnit, ) -> Union[int, JBoolean]: ...
		@overload
		def tryLock(self, ) -> Union[int, JBoolean]: ...


	class WNode:
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def notify(self, ) -> None: ...


	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def asReadLock(self, ) -> javawrappers.java.util.concurrent.locks.Lock: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@overload
	def writeLock(self, ) -> Union[long, JLong]: ...
	@overload
	def writeLock(self, ) -> javawrappers.java.util.concurrent.locks.Lock: ...
	def notifyAll(self, ) -> None: ...
	@overload
	def tryWriteLock(self, arg0: Union[long, JLong], arg1: javawrappers.java.util.concurrent.TimeUnit, ) -> Union[long, JLong]: ...
	@overload
	def tryWriteLock(self, ) -> Union[long, JLong]: ...
	def tryConvertToOptimisticRead(self, arg0: Union[long, JLong], ) -> Union[long, JLong]: ...
	def notify(self, ) -> None: ...
	def unlockWrite(self, arg0: Union[long, JLong], ) -> None: ...
	def isReadLocked(self, ) -> Union[int, JBoolean]: ...
	@overload
	def newCondition(self, ) -> javawrappers.java.util.concurrent.locks.Condition: ...
	@overload
	def newCondition(self, ) -> javawrappers.java.util.concurrent.locks.Condition: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@staticmethod
	def isOptimisticReadStamp(arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	@overload
	def lock(self, ) -> None: ...
	@overload
	def lock(self, ) -> None: ...
	def asWriteLock(self, ) -> javawrappers.java.util.concurrent.locks.Lock: ...
	def readLockInterruptibly(self, ) -> Union[long, JLong]: ...
	def isWriteLocked(self, ) -> Union[int, JBoolean]: ...
	def validate(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	def tryConvertToReadLock(self, arg0: Union[long, JLong], ) -> Union[long, JLong]: ...
	@overload
	def unlock(self, ) -> None: ...
	@overload
	def unlock(self, ) -> None: ...
	@overload
	def unlock(self, arg0: Union[long, JLong], ) -> None: ...
	def writeLockInterruptibly(self, ) -> Union[long, JLong]: ...
	def asReadWriteLock(self, ) -> javawrappers.java.util.concurrent.locks.ReadWriteLock: ...
	def getReadLockCount(self, ) -> Union[int, JInt]: ...
	@overload
	def readLock(self, ) -> Union[long, JLong]: ...
	@overload
	def readLock(self, ) -> javawrappers.java.util.concurrent.locks.Lock: ...
	@staticmethod
	def isLockStamp(arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	@staticmethod
	def isWriteLockStamp(arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	def tryUnlockWrite(self, ) -> Union[int, JBoolean]: ...
	@overload
	def tryLock(self, arg0: Union[long, JLong], arg1: javawrappers.java.util.concurrent.TimeUnit, ) -> Union[int, JBoolean]: ...
	@overload
	def tryLock(self, ) -> Union[int, JBoolean]: ...
	@overload
	def tryLock(self, arg0: Union[long, JLong], arg1: javawrappers.java.util.concurrent.TimeUnit, ) -> Union[int, JBoolean]: ...
	@overload
	def tryLock(self, ) -> Union[int, JBoolean]: ...
	def tryConvertToWriteLock(self, arg0: Union[long, JLong], ) -> Union[long, JLong]: ...
	@overload
	def lockInterruptibly(self, ) -> None: ...
	@overload
	def lockInterruptibly(self, ) -> None: ...
	@overload
	def tryReadLock(self, ) -> Union[long, JLong]: ...
	@overload
	def tryReadLock(self, arg0: Union[long, JLong], arg1: javawrappers.java.util.concurrent.TimeUnit, ) -> Union[long, JLong]: ...
	def tryOptimisticRead(self, ) -> Union[long, JLong]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@staticmethod
	def isReadLockStamp(arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def unlockRead(self, arg0: Union[long, JLong], ) -> None: ...
	def tryUnlockRead(self, ) -> Union[int, JBoolean]: ...


class ReadWriteLock:
	def writeLock(self, ) -> javawrappers.java.util.concurrent.locks.Lock: ...
	def readLock(self, ) -> javawrappers.java.util.concurrent.locks.Lock: ...


