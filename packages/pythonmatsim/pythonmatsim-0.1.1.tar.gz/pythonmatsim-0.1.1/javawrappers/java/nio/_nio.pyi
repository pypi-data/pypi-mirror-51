################################################################################
#          This file was automatically generated. Please do not edit.          #
################################################################################

import javawrappers.java.lang
import javawrappers.java.io
import javawrappers.java.util.stream
import javawrappers.java.nio

from jpype.types import *
from typing import Union

from typing import overload

class ByteBuffer:
	def asIntBuffer(self, ) -> javawrappers.java.nio.IntBuffer: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def compact(self, ) -> javawrappers.java.nio.ByteBuffer: ...
	def asLongBuffer(self, ) -> javawrappers.java.nio.LongBuffer: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.nio.ByteBuffer, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def put(self, arg0: Union[int, JInt], arg1: JByte, ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def put(self, arg0: JArray(JByte, 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def put(self, arg0: JByte, ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def put(self, arg0: JArray(JByte, 1), ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def put(self, arg0: javawrappers.java.nio.ByteBuffer, ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def slice(self, ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def slice(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def limit(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def limit(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def limit(self, ) -> Union[int, JInt]: ...
	@overload
	def order(self, ) -> javawrappers.java.nio.ByteOrder: ...
	@overload
	def order(self, arg0: javawrappers.java.nio.ByteOrder, ) -> javawrappers.java.nio.ByteBuffer: ...
	def asFloatBuffer(self, ) -> javawrappers.java.nio.FloatBuffer: ...
	def asCharBuffer(self, ) -> javawrappers.java.nio.CharBuffer: ...
	@staticmethod
	def allocateDirect(arg0: Union[int, JInt], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def putInt(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def putInt(self, arg0: Union[int, JInt], arg1: Union[int, JInt], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def duplicate(self, ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def duplicate(self, ) -> javawrappers.java.nio.Buffer: ...
	def remaining(self, ) -> Union[int, JInt]: ...
	@overload
	def putFloat(self, arg0: Union[float, JFloat], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def putFloat(self, arg0: Union[int, JInt], arg1: Union[float, JFloat], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def getInt(self, ) -> Union[int, JInt]: ...
	@overload
	def getInt(self, arg0: Union[int, JInt], ) -> Union[int, JInt]: ...
	@overload
	def getChar(self, arg0: Union[int, JInt], ) -> Union[string, JString]: ...
	@overload
	def getChar(self, ) -> Union[string, JString]: ...
	@staticmethod
	def allocate(arg0: Union[int, JInt], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def reset(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def reset(self, ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def position(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def position(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def position(self, ) -> Union[int, JInt]: ...
	def asShortBuffer(self, ) -> javawrappers.java.nio.ShortBuffer: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def notifyAll(self, ) -> None: ...
	@overload
	def putDouble(self, arg0: Union[int, JInt], arg1: Union[float, JDouble], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def putDouble(self, arg0: Union[float, JDouble], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def getDouble(self, ) -> Union[float, JDouble]: ...
	@overload
	def getDouble(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	@overload
	def getFloat(self, ) -> Union[float, JFloat]: ...
	@overload
	def getFloat(self, arg0: Union[int, JInt], ) -> Union[float, JFloat]: ...
	@overload
	def putLong(self, arg0: Union[int, JInt], arg1: Union[long, JLong], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def putLong(self, arg0: Union[long, JLong], ) -> javawrappers.java.nio.ByteBuffer: ...
	def notify(self, ) -> None: ...
	def asReadOnlyBuffer(self, ) -> javawrappers.java.nio.ByteBuffer: ...
	def capacity(self, ) -> Union[int, JInt]: ...
	def isReadOnly(self, ) -> Union[int, JBoolean]: ...
	@overload
	def array(self, ) -> javawrappers.java.lang.Object: ...
	@overload
	def array(self, ) -> JArray(JByte, 1): ...
	def asDoubleBuffer(self, ) -> javawrappers.java.nio.DoubleBuffer: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def get(self, arg0: JArray(JByte, 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def get(self, arg0: JArray(JByte, 1), ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def get(self, ) -> JByte: ...
	@overload
	def get(self, arg0: Union[int, JInt], ) -> JByte: ...
	def arrayOffset(self, ) -> Union[int, JInt]: ...
	@overload
	def putShort(self, arg0: Union[int, JInt], arg1: Union[int, JShort], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def putShort(self, arg0: Union[int, JShort], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def flip(self, ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def flip(self, ) -> javawrappers.java.nio.Buffer: ...
	def hasArray(self, ) -> Union[int, JBoolean]: ...
	@overload
	def getShort(self, ) -> Union[int, JShort]: ...
	@overload
	def getShort(self, arg0: Union[int, JInt], ) -> Union[int, JShort]: ...
	@overload
	def putChar(self, arg0: Union[int, JInt], arg1: Union[string, JString], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def putChar(self, arg0: Union[string, JString], ) -> javawrappers.java.nio.ByteBuffer: ...
	def hasRemaining(self, ) -> Union[int, JBoolean]: ...
	@overload
	def clear(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def clear(self, ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def getLong(self, ) -> Union[long, JLong]: ...
	@overload
	def getLong(self, arg0: Union[int, JInt], ) -> Union[long, JLong]: ...
	def alignmentOffset(self, arg0: Union[int, JInt], arg1: Union[int, JInt], ) -> Union[int, JInt]: ...
	@overload
	def rewind(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def rewind(self, ) -> javawrappers.java.nio.ByteBuffer: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def mismatch(self, arg0: javawrappers.java.nio.ByteBuffer, ) -> Union[int, JInt]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def alignedSlice(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	@staticmethod
	def wrap(arg0: JArray(JByte, 1), ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	@staticmethod
	def wrap(arg0: JArray(JByte, 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.nio.ByteBuffer: ...
	def isDirect(self, ) -> Union[int, JBoolean]: ...
	@overload
	def mark(self, ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def mark(self, ) -> javawrappers.java.nio.Buffer: ...


class Buffer:
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def hasArray(self, ) -> Union[int, JBoolean]: ...
	def notifyAll(self, ) -> None: ...
	def hasRemaining(self, ) -> Union[int, JBoolean]: ...
	def clear(self, ) -> javawrappers.java.nio.Buffer: ...
	def duplicate(self, ) -> javawrappers.java.nio.Buffer: ...
	def notify(self, ) -> None: ...
	def remaining(self, ) -> Union[int, JInt]: ...
	def capacity(self, ) -> Union[int, JInt]: ...
	def isReadOnly(self, ) -> Union[int, JBoolean]: ...
	def rewind(self, ) -> javawrappers.java.nio.Buffer: ...
	def slice(self, ) -> javawrappers.java.nio.Buffer: ...
	def array(self, ) -> javawrappers.java.lang.Object: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def limit(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def limit(self, ) -> Union[int, JInt]: ...
	def reset(self, ) -> javawrappers.java.nio.Buffer: ...
	def arrayOffset(self, ) -> Union[int, JInt]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def position(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def position(self, ) -> Union[int, JInt]: ...
	def flip(self, ) -> javawrappers.java.nio.Buffer: ...
	def isDirect(self, ) -> Union[int, JBoolean]: ...
	def mark(self, ) -> javawrappers.java.nio.Buffer: ...


class BufferOverflowException:
	def __init__(self, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@overload
	def printStackTrace(self, arg0: javawrappers.java.io.PrintStream, ) -> None: ...
	@overload
	def printStackTrace(self, ) -> None: ...
	@overload
	def printStackTrace(self, arg0: javawrappers.java.io.PrintWriter, ) -> None: ...
	def getLocalizedMessage(self, ) -> javawrappers.java.lang.String: ...
	def notifyAll(self, ) -> None: ...
	def initCause(self, arg0: javawrappers.java.lang.Throwable, ) -> javawrappers.java.lang.Throwable: ...
	def getMessage(self, ) -> javawrappers.java.lang.String: ...
	def getCause(self, ) -> javawrappers.java.lang.Throwable: ...
	def notify(self, ) -> None: ...
	def addSuppressed(self, arg0: javawrappers.java.lang.Throwable, ) -> None: ...
	def setStackTrace(self, arg0: JArray(javawrappers.java.lang.StackTraceElement, 1), ) -> None: ...
	def getStackTrace(self, ) -> JArray(javawrappers.java.lang.StackTraceElement, 1): ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def getSuppressed(self, ) -> JArray(javawrappers.java.lang.Throwable, 1): ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def fillInStackTrace(self, ) -> javawrappers.java.lang.Throwable: ...


class IntBuffer:
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def compact(self, ) -> javawrappers.java.nio.IntBuffer: ...
	def notifyAll(self, ) -> None: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.nio.IntBuffer, ) -> Union[int, JInt]: ...
	def notify(self, ) -> None: ...
	@overload
	def put(self, arg0: JArray(Union[int, JInt], 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.nio.IntBuffer: ...
	@overload
	def put(self, arg0: JArray(Union[int, JInt], 1), ) -> javawrappers.java.nio.IntBuffer: ...
	@overload
	def put(self, arg0: javawrappers.java.nio.IntBuffer, ) -> javawrappers.java.nio.IntBuffer: ...
	@overload
	def put(self, arg0: Union[int, JInt], arg1: Union[int, JInt], ) -> javawrappers.java.nio.IntBuffer: ...
	@overload
	def put(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.IntBuffer: ...
	def asReadOnlyBuffer(self, ) -> javawrappers.java.nio.IntBuffer: ...
	def capacity(self, ) -> Union[int, JInt]: ...
	def isReadOnly(self, ) -> Union[int, JBoolean]: ...
	@overload
	def slice(self, ) -> javawrappers.java.nio.IntBuffer: ...
	@overload
	def slice(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def array(self, ) -> javawrappers.java.lang.Object: ...
	@overload
	def array(self, ) -> JArray(Union[int, JInt], 1): ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def get(self, ) -> Union[int, JInt]: ...
	@overload
	def get(self, arg0: JArray(Union[int, JInt], 1), ) -> javawrappers.java.nio.IntBuffer: ...
	@overload
	def get(self, arg0: Union[int, JInt], ) -> Union[int, JInt]: ...
	@overload
	def get(self, arg0: JArray(Union[int, JInt], 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.nio.IntBuffer: ...
	@overload
	def limit(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def limit(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.IntBuffer: ...
	@overload
	def limit(self, ) -> Union[int, JInt]: ...
	def arrayOffset(self, ) -> Union[int, JInt]: ...
	@overload
	def flip(self, ) -> javawrappers.java.nio.IntBuffer: ...
	@overload
	def flip(self, ) -> javawrappers.java.nio.Buffer: ...
	def order(self, ) -> javawrappers.java.nio.ByteOrder: ...
	def hasArray(self, ) -> Union[int, JBoolean]: ...
	def hasRemaining(self, ) -> Union[int, JBoolean]: ...
	@overload
	def clear(self, ) -> javawrappers.java.nio.IntBuffer: ...
	@overload
	def clear(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def duplicate(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def duplicate(self, ) -> javawrappers.java.nio.IntBuffer: ...
	def remaining(self, ) -> Union[int, JInt]: ...
	@staticmethod
	def allocate(arg0: Union[int, JInt], ) -> javawrappers.java.nio.IntBuffer: ...
	@overload
	def rewind(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def rewind(self, ) -> javawrappers.java.nio.IntBuffer: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def mismatch(self, arg0: javawrappers.java.nio.IntBuffer, ) -> Union[int, JInt]: ...
	@overload
	def reset(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def reset(self, ) -> javawrappers.java.nio.IntBuffer: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def position(self, ) -> Union[int, JInt]: ...
	@overload
	def position(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.IntBuffer: ...
	@overload
	def position(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.Buffer: ...
	@overload
	@staticmethod
	def wrap(arg0: JArray(Union[int, JInt], 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.nio.IntBuffer: ...
	@overload
	@staticmethod
	def wrap(arg0: JArray(Union[int, JInt], 1), ) -> javawrappers.java.nio.IntBuffer: ...
	def isDirect(self, ) -> Union[int, JBoolean]: ...
	@overload
	def mark(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def mark(self, ) -> javawrappers.java.nio.IntBuffer: ...


class LongBuffer:
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def compact(self, ) -> javawrappers.java.nio.LongBuffer: ...
	def notifyAll(self, ) -> None: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.nio.LongBuffer, ) -> Union[int, JInt]: ...
	def notify(self, ) -> None: ...
	@overload
	def put(self, arg0: JArray(Union[long, JLong], 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.nio.LongBuffer: ...
	@overload
	def put(self, arg0: JArray(Union[long, JLong], 1), ) -> javawrappers.java.nio.LongBuffer: ...
	@overload
	def put(self, arg0: javawrappers.java.nio.LongBuffer, ) -> javawrappers.java.nio.LongBuffer: ...
	@overload
	def put(self, arg0: Union[int, JInt], arg1: Union[long, JLong], ) -> javawrappers.java.nio.LongBuffer: ...
	@overload
	def put(self, arg0: Union[long, JLong], ) -> javawrappers.java.nio.LongBuffer: ...
	def asReadOnlyBuffer(self, ) -> javawrappers.java.nio.LongBuffer: ...
	def capacity(self, ) -> Union[int, JInt]: ...
	def isReadOnly(self, ) -> Union[int, JBoolean]: ...
	@overload
	def slice(self, ) -> javawrappers.java.nio.LongBuffer: ...
	@overload
	def slice(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def array(self, ) -> javawrappers.java.lang.Object: ...
	@overload
	def array(self, ) -> JArray(Union[long, JLong], 1): ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def get(self, ) -> Union[long, JLong]: ...
	@overload
	def get(self, arg0: JArray(Union[long, JLong], 1), ) -> javawrappers.java.nio.LongBuffer: ...
	@overload
	def get(self, arg0: Union[int, JInt], ) -> Union[long, JLong]: ...
	@overload
	def get(self, arg0: JArray(Union[long, JLong], 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.nio.LongBuffer: ...
	@overload
	def limit(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def limit(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.LongBuffer: ...
	@overload
	def limit(self, ) -> Union[int, JInt]: ...
	def arrayOffset(self, ) -> Union[int, JInt]: ...
	@overload
	def flip(self, ) -> javawrappers.java.nio.LongBuffer: ...
	@overload
	def flip(self, ) -> javawrappers.java.nio.Buffer: ...
	def order(self, ) -> javawrappers.java.nio.ByteOrder: ...
	def hasArray(self, ) -> Union[int, JBoolean]: ...
	def hasRemaining(self, ) -> Union[int, JBoolean]: ...
	@overload
	def clear(self, ) -> javawrappers.java.nio.LongBuffer: ...
	@overload
	def clear(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def duplicate(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def duplicate(self, ) -> javawrappers.java.nio.LongBuffer: ...
	def remaining(self, ) -> Union[int, JInt]: ...
	@staticmethod
	def allocate(arg0: Union[int, JInt], ) -> javawrappers.java.nio.LongBuffer: ...
	@overload
	def rewind(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def rewind(self, ) -> javawrappers.java.nio.LongBuffer: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def mismatch(self, arg0: javawrappers.java.nio.LongBuffer, ) -> Union[int, JInt]: ...
	@overload
	def reset(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def reset(self, ) -> javawrappers.java.nio.LongBuffer: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def position(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.LongBuffer: ...
	@overload
	def position(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def position(self, ) -> Union[int, JInt]: ...
	@overload
	@staticmethod
	def wrap(arg0: JArray(Union[long, JLong], 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.nio.LongBuffer: ...
	@overload
	@staticmethod
	def wrap(arg0: JArray(Union[long, JLong], 1), ) -> javawrappers.java.nio.LongBuffer: ...
	def isDirect(self, ) -> Union[int, JBoolean]: ...
	@overload
	def mark(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def mark(self, ) -> javawrappers.java.nio.LongBuffer: ...


class MappedByteBuffer:
	def asIntBuffer(self, ) -> javawrappers.java.nio.IntBuffer: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	def compact(self, ) -> javawrappers.java.nio.ByteBuffer: ...
	def asLongBuffer(self, ) -> javawrappers.java.nio.LongBuffer: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.nio.ByteBuffer, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	def isLoaded(self, ) -> Union[int, JBoolean]: ...
	@overload
	def put(self, arg0: Union[int, JInt], arg1: JByte, ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def put(self, arg0: JArray(JByte, 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def put(self, arg0: JByte, ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def put(self, arg0: JArray(JByte, 1), ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def put(self, arg0: javawrappers.java.nio.ByteBuffer, ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def slice(self, ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def slice(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def limit(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def limit(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def limit(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.MappedByteBuffer: ...
	@overload
	def limit(self, ) -> Union[int, JInt]: ...
	@overload
	def order(self, ) -> javawrappers.java.nio.ByteOrder: ...
	@overload
	def order(self, arg0: javawrappers.java.nio.ByteOrder, ) -> javawrappers.java.nio.ByteBuffer: ...
	def asFloatBuffer(self, ) -> javawrappers.java.nio.FloatBuffer: ...
	def asCharBuffer(self, ) -> javawrappers.java.nio.CharBuffer: ...
	@staticmethod
	def allocateDirect(arg0: Union[int, JInt], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def putInt(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def putInt(self, arg0: Union[int, JInt], arg1: Union[int, JInt], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def duplicate(self, ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def duplicate(self, ) -> javawrappers.java.nio.Buffer: ...
	def remaining(self, ) -> Union[int, JInt]: ...
	@overload
	def putFloat(self, arg0: Union[float, JFloat], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def putFloat(self, arg0: Union[int, JInt], arg1: Union[float, JFloat], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def getInt(self, ) -> Union[int, JInt]: ...
	@overload
	def getInt(self, arg0: Union[int, JInt], ) -> Union[int, JInt]: ...
	@overload
	def getChar(self, arg0: Union[int, JInt], ) -> Union[string, JString]: ...
	@overload
	def getChar(self, ) -> Union[string, JString]: ...
	@staticmethod
	def allocate(arg0: Union[int, JInt], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def reset(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def reset(self, ) -> javawrappers.java.nio.MappedByteBuffer: ...
	@overload
	def reset(self, ) -> javawrappers.java.nio.ByteBuffer: ...
	def force(self, ) -> javawrappers.java.nio.MappedByteBuffer: ...
	@overload
	def position(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def position(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def position(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.MappedByteBuffer: ...
	@overload
	def position(self, ) -> Union[int, JInt]: ...
	def asShortBuffer(self, ) -> javawrappers.java.nio.ShortBuffer: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def notifyAll(self, ) -> None: ...
	@overload
	def putDouble(self, arg0: Union[int, JInt], arg1: Union[float, JDouble], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def putDouble(self, arg0: Union[float, JDouble], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def getDouble(self, ) -> Union[float, JDouble]: ...
	@overload
	def getDouble(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	@overload
	def getFloat(self, ) -> Union[float, JFloat]: ...
	@overload
	def getFloat(self, arg0: Union[int, JInt], ) -> Union[float, JFloat]: ...
	@overload
	def putLong(self, arg0: Union[int, JInt], arg1: Union[long, JLong], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def putLong(self, arg0: Union[long, JLong], ) -> javawrappers.java.nio.ByteBuffer: ...
	def notify(self, ) -> None: ...
	def asReadOnlyBuffer(self, ) -> javawrappers.java.nio.ByteBuffer: ...
	def capacity(self, ) -> Union[int, JInt]: ...
	def isReadOnly(self, ) -> Union[int, JBoolean]: ...
	def load(self, ) -> javawrappers.java.nio.MappedByteBuffer: ...
	@overload
	def array(self, ) -> javawrappers.java.lang.Object: ...
	@overload
	def array(self, ) -> JArray(JByte, 1): ...
	def asDoubleBuffer(self, ) -> javawrappers.java.nio.DoubleBuffer: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def get(self, arg0: JArray(JByte, 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def get(self, arg0: JArray(JByte, 1), ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def get(self, ) -> JByte: ...
	@overload
	def get(self, arg0: Union[int, JInt], ) -> JByte: ...
	def arrayOffset(self, ) -> Union[int, JInt]: ...
	@overload
	def putShort(self, arg0: Union[int, JInt], arg1: Union[int, JShort], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def putShort(self, arg0: Union[int, JShort], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def flip(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def flip(self, ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def flip(self, ) -> javawrappers.java.nio.MappedByteBuffer: ...
	def hasArray(self, ) -> Union[int, JBoolean]: ...
	@overload
	def getShort(self, ) -> Union[int, JShort]: ...
	@overload
	def getShort(self, arg0: Union[int, JInt], ) -> Union[int, JShort]: ...
	@overload
	def putChar(self, arg0: Union[int, JInt], arg1: Union[string, JString], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def putChar(self, arg0: Union[string, JString], ) -> javawrappers.java.nio.ByteBuffer: ...
	def hasRemaining(self, ) -> Union[int, JBoolean]: ...
	@overload
	def clear(self, ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def clear(self, ) -> javawrappers.java.nio.MappedByteBuffer: ...
	@overload
	def clear(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def getLong(self, ) -> Union[long, JLong]: ...
	@overload
	def getLong(self, arg0: Union[int, JInt], ) -> Union[long, JLong]: ...
	def alignmentOffset(self, arg0: Union[int, JInt], arg1: Union[int, JInt], ) -> Union[int, JInt]: ...
	@overload
	def rewind(self, ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def rewind(self, ) -> javawrappers.java.nio.MappedByteBuffer: ...
	@overload
	def rewind(self, ) -> javawrappers.java.nio.Buffer: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def mismatch(self, arg0: javawrappers.java.nio.ByteBuffer, ) -> Union[int, JInt]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def alignedSlice(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	@staticmethod
	def wrap(arg0: JArray(JByte, 1), ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	@staticmethod
	def wrap(arg0: JArray(JByte, 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.nio.ByteBuffer: ...
	def isDirect(self, ) -> Union[int, JBoolean]: ...
	@overload
	def mark(self, ) -> javawrappers.java.nio.MappedByteBuffer: ...
	@overload
	def mark(self, ) -> javawrappers.java.nio.ByteBuffer: ...
	@overload
	def mark(self, ) -> javawrappers.java.nio.Buffer: ...


class InvalidMarkException:
	def __init__(self, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@overload
	def printStackTrace(self, arg0: javawrappers.java.io.PrintStream, ) -> None: ...
	@overload
	def printStackTrace(self, ) -> None: ...
	@overload
	def printStackTrace(self, arg0: javawrappers.java.io.PrintWriter, ) -> None: ...
	def getLocalizedMessage(self, ) -> javawrappers.java.lang.String: ...
	def notifyAll(self, ) -> None: ...
	def initCause(self, arg0: javawrappers.java.lang.Throwable, ) -> javawrappers.java.lang.Throwable: ...
	def getMessage(self, ) -> javawrappers.java.lang.String: ...
	def getCause(self, ) -> javawrappers.java.lang.Throwable: ...
	def notify(self, ) -> None: ...
	def addSuppressed(self, arg0: javawrappers.java.lang.Throwable, ) -> None: ...
	def setStackTrace(self, arg0: JArray(javawrappers.java.lang.StackTraceElement, 1), ) -> None: ...
	def getStackTrace(self, ) -> JArray(javawrappers.java.lang.StackTraceElement, 1): ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def getSuppressed(self, ) -> JArray(javawrappers.java.lang.Throwable, 1): ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def fillInStackTrace(self, ) -> javawrappers.java.lang.Throwable: ...


class ReadOnlyBufferException:
	def __init__(self, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@overload
	def printStackTrace(self, arg0: javawrappers.java.io.PrintStream, ) -> None: ...
	@overload
	def printStackTrace(self, ) -> None: ...
	@overload
	def printStackTrace(self, arg0: javawrappers.java.io.PrintWriter, ) -> None: ...
	def getLocalizedMessage(self, ) -> javawrappers.java.lang.String: ...
	def notifyAll(self, ) -> None: ...
	def initCause(self, arg0: javawrappers.java.lang.Throwable, ) -> javawrappers.java.lang.Throwable: ...
	def getMessage(self, ) -> javawrappers.java.lang.String: ...
	def getCause(self, ) -> javawrappers.java.lang.Throwable: ...
	def notify(self, ) -> None: ...
	def addSuppressed(self, arg0: javawrappers.java.lang.Throwable, ) -> None: ...
	def setStackTrace(self, arg0: JArray(javawrappers.java.lang.StackTraceElement, 1), ) -> None: ...
	def getStackTrace(self, ) -> JArray(javawrappers.java.lang.StackTraceElement, 1): ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def getSuppressed(self, ) -> JArray(javawrappers.java.lang.Throwable, 1): ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def fillInStackTrace(self, ) -> javawrappers.java.lang.Throwable: ...


class BufferUnderflowException:
	def __init__(self, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@overload
	def printStackTrace(self, arg0: javawrappers.java.io.PrintStream, ) -> None: ...
	@overload
	def printStackTrace(self, ) -> None: ...
	@overload
	def printStackTrace(self, arg0: javawrappers.java.io.PrintWriter, ) -> None: ...
	def getLocalizedMessage(self, ) -> javawrappers.java.lang.String: ...
	def notifyAll(self, ) -> None: ...
	def initCause(self, arg0: javawrappers.java.lang.Throwable, ) -> javawrappers.java.lang.Throwable: ...
	def getMessage(self, ) -> javawrappers.java.lang.String: ...
	def getCause(self, ) -> javawrappers.java.lang.Throwable: ...
	def notify(self, ) -> None: ...
	def addSuppressed(self, arg0: javawrappers.java.lang.Throwable, ) -> None: ...
	def setStackTrace(self, arg0: JArray(javawrappers.java.lang.StackTraceElement, 1), ) -> None: ...
	def getStackTrace(self, ) -> JArray(javawrappers.java.lang.StackTraceElement, 1): ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def getSuppressed(self, ) -> JArray(javawrappers.java.lang.Throwable, 1): ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def fillInStackTrace(self, ) -> javawrappers.java.lang.Throwable: ...


class ShortBuffer:
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def compact(self, ) -> javawrappers.java.nio.ShortBuffer: ...
	def notifyAll(self, ) -> None: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.nio.ShortBuffer, ) -> Union[int, JInt]: ...
	def notify(self, ) -> None: ...
	@overload
	def put(self, arg0: JArray(Union[int, JShort], 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.nio.ShortBuffer: ...
	@overload
	def put(self, arg0: JArray(Union[int, JShort], 1), ) -> javawrappers.java.nio.ShortBuffer: ...
	@overload
	def put(self, arg0: javawrappers.java.nio.ShortBuffer, ) -> javawrappers.java.nio.ShortBuffer: ...
	@overload
	def put(self, arg0: Union[int, JInt], arg1: Union[int, JShort], ) -> javawrappers.java.nio.ShortBuffer: ...
	@overload
	def put(self, arg0: Union[int, JShort], ) -> javawrappers.java.nio.ShortBuffer: ...
	def asReadOnlyBuffer(self, ) -> javawrappers.java.nio.ShortBuffer: ...
	def capacity(self, ) -> Union[int, JInt]: ...
	def isReadOnly(self, ) -> Union[int, JBoolean]: ...
	@overload
	def slice(self, ) -> javawrappers.java.nio.ShortBuffer: ...
	@overload
	def slice(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def array(self, ) -> javawrappers.java.lang.Object: ...
	@overload
	def array(self, ) -> JArray(Union[int, JShort], 1): ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def get(self, ) -> Union[int, JShort]: ...
	@overload
	def get(self, arg0: JArray(Union[int, JShort], 1), ) -> javawrappers.java.nio.ShortBuffer: ...
	@overload
	def get(self, arg0: Union[int, JInt], ) -> Union[int, JShort]: ...
	@overload
	def get(self, arg0: JArray(Union[int, JShort], 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.nio.ShortBuffer: ...
	@overload
	def limit(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def limit(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.ShortBuffer: ...
	@overload
	def limit(self, ) -> Union[int, JInt]: ...
	def arrayOffset(self, ) -> Union[int, JInt]: ...
	@overload
	def flip(self, ) -> javawrappers.java.nio.ShortBuffer: ...
	@overload
	def flip(self, ) -> javawrappers.java.nio.Buffer: ...
	def order(self, ) -> javawrappers.java.nio.ByteOrder: ...
	def hasArray(self, ) -> Union[int, JBoolean]: ...
	def hasRemaining(self, ) -> Union[int, JBoolean]: ...
	@overload
	def clear(self, ) -> javawrappers.java.nio.ShortBuffer: ...
	@overload
	def clear(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def duplicate(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def duplicate(self, ) -> javawrappers.java.nio.ShortBuffer: ...
	def remaining(self, ) -> Union[int, JInt]: ...
	@staticmethod
	def allocate(arg0: Union[int, JInt], ) -> javawrappers.java.nio.ShortBuffer: ...
	@overload
	def rewind(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def rewind(self, ) -> javawrappers.java.nio.ShortBuffer: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def mismatch(self, arg0: javawrappers.java.nio.ShortBuffer, ) -> Union[int, JInt]: ...
	@overload
	def reset(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def reset(self, ) -> javawrappers.java.nio.ShortBuffer: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def position(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.ShortBuffer: ...
	@overload
	def position(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def position(self, ) -> Union[int, JInt]: ...
	@overload
	@staticmethod
	def wrap(arg0: JArray(Union[int, JShort], 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.nio.ShortBuffer: ...
	@overload
	@staticmethod
	def wrap(arg0: JArray(Union[int, JShort], 1), ) -> javawrappers.java.nio.ShortBuffer: ...
	def isDirect(self, ) -> Union[int, JBoolean]: ...
	@overload
	def mark(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def mark(self, ) -> javawrappers.java.nio.ShortBuffer: ...


class DoubleBuffer:
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def compact(self, ) -> javawrappers.java.nio.DoubleBuffer: ...
	def notifyAll(self, ) -> None: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.nio.DoubleBuffer, ) -> Union[int, JInt]: ...
	def notify(self, ) -> None: ...
	@overload
	def put(self, arg0: JArray(Union[float, JDouble], 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.nio.DoubleBuffer: ...
	@overload
	def put(self, arg0: JArray(Union[float, JDouble], 1), ) -> javawrappers.java.nio.DoubleBuffer: ...
	@overload
	def put(self, arg0: javawrappers.java.nio.DoubleBuffer, ) -> javawrappers.java.nio.DoubleBuffer: ...
	@overload
	def put(self, arg0: Union[int, JInt], arg1: Union[float, JDouble], ) -> javawrappers.java.nio.DoubleBuffer: ...
	@overload
	def put(self, arg0: Union[float, JDouble], ) -> javawrappers.java.nio.DoubleBuffer: ...
	def asReadOnlyBuffer(self, ) -> javawrappers.java.nio.DoubleBuffer: ...
	def capacity(self, ) -> Union[int, JInt]: ...
	def isReadOnly(self, ) -> Union[int, JBoolean]: ...
	@overload
	def slice(self, ) -> javawrappers.java.nio.DoubleBuffer: ...
	@overload
	def slice(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def array(self, ) -> javawrappers.java.lang.Object: ...
	@overload
	def array(self, ) -> JArray(Union[float, JDouble], 1): ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def get(self, ) -> Union[float, JDouble]: ...
	@overload
	def get(self, arg0: JArray(Union[float, JDouble], 1), ) -> javawrappers.java.nio.DoubleBuffer: ...
	@overload
	def get(self, arg0: Union[int, JInt], ) -> Union[float, JDouble]: ...
	@overload
	def get(self, arg0: JArray(Union[float, JDouble], 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.nio.DoubleBuffer: ...
	@overload
	def limit(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def limit(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.DoubleBuffer: ...
	@overload
	def limit(self, ) -> Union[int, JInt]: ...
	def arrayOffset(self, ) -> Union[int, JInt]: ...
	@overload
	def flip(self, ) -> javawrappers.java.nio.DoubleBuffer: ...
	@overload
	def flip(self, ) -> javawrappers.java.nio.Buffer: ...
	def order(self, ) -> javawrappers.java.nio.ByteOrder: ...
	def hasArray(self, ) -> Union[int, JBoolean]: ...
	def hasRemaining(self, ) -> Union[int, JBoolean]: ...
	@overload
	def clear(self, ) -> javawrappers.java.nio.DoubleBuffer: ...
	@overload
	def clear(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def duplicate(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def duplicate(self, ) -> javawrappers.java.nio.DoubleBuffer: ...
	def remaining(self, ) -> Union[int, JInt]: ...
	@staticmethod
	def allocate(arg0: Union[int, JInt], ) -> javawrappers.java.nio.DoubleBuffer: ...
	@overload
	def rewind(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def rewind(self, ) -> javawrappers.java.nio.DoubleBuffer: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def mismatch(self, arg0: javawrappers.java.nio.DoubleBuffer, ) -> Union[int, JInt]: ...
	@overload
	def reset(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def reset(self, ) -> javawrappers.java.nio.DoubleBuffer: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def position(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.DoubleBuffer: ...
	@overload
	def position(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def position(self, ) -> Union[int, JInt]: ...
	@overload
	@staticmethod
	def wrap(arg0: JArray(Union[float, JDouble], 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.nio.DoubleBuffer: ...
	@overload
	@staticmethod
	def wrap(arg0: JArray(Union[float, JDouble], 1), ) -> javawrappers.java.nio.DoubleBuffer: ...
	def isDirect(self, ) -> Union[int, JBoolean]: ...
	@overload
	def mark(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def mark(self, ) -> javawrappers.java.nio.DoubleBuffer: ...


class ByteOrder:
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@staticmethod
	def nativeOrder() -> javawrappers.java.nio.ByteOrder: ...
	def notify(self, ) -> None: ...


class FloatBuffer:
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def compact(self, ) -> javawrappers.java.nio.FloatBuffer: ...
	def notifyAll(self, ) -> None: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.nio.FloatBuffer, ) -> Union[int, JInt]: ...
	def notify(self, ) -> None: ...
	@overload
	def put(self, arg0: JArray(Union[float, JFloat], 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.nio.FloatBuffer: ...
	@overload
	def put(self, arg0: JArray(Union[float, JFloat], 1), ) -> javawrappers.java.nio.FloatBuffer: ...
	@overload
	def put(self, arg0: javawrappers.java.nio.FloatBuffer, ) -> javawrappers.java.nio.FloatBuffer: ...
	@overload
	def put(self, arg0: Union[int, JInt], arg1: Union[float, JFloat], ) -> javawrappers.java.nio.FloatBuffer: ...
	@overload
	def put(self, arg0: Union[float, JFloat], ) -> javawrappers.java.nio.FloatBuffer: ...
	def asReadOnlyBuffer(self, ) -> javawrappers.java.nio.FloatBuffer: ...
	def capacity(self, ) -> Union[int, JInt]: ...
	def isReadOnly(self, ) -> Union[int, JBoolean]: ...
	@overload
	def slice(self, ) -> javawrappers.java.nio.FloatBuffer: ...
	@overload
	def slice(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def array(self, ) -> javawrappers.java.lang.Object: ...
	@overload
	def array(self, ) -> JArray(Union[float, JFloat], 1): ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def get(self, ) -> Union[float, JFloat]: ...
	@overload
	def get(self, arg0: JArray(Union[float, JFloat], 1), ) -> javawrappers.java.nio.FloatBuffer: ...
	@overload
	def get(self, arg0: Union[int, JInt], ) -> Union[float, JFloat]: ...
	@overload
	def get(self, arg0: JArray(Union[float, JFloat], 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.nio.FloatBuffer: ...
	@overload
	def limit(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def limit(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.FloatBuffer: ...
	@overload
	def limit(self, ) -> Union[int, JInt]: ...
	def arrayOffset(self, ) -> Union[int, JInt]: ...
	@overload
	def flip(self, ) -> javawrappers.java.nio.FloatBuffer: ...
	@overload
	def flip(self, ) -> javawrappers.java.nio.Buffer: ...
	def order(self, ) -> javawrappers.java.nio.ByteOrder: ...
	def hasArray(self, ) -> Union[int, JBoolean]: ...
	def hasRemaining(self, ) -> Union[int, JBoolean]: ...
	@overload
	def clear(self, ) -> javawrappers.java.nio.FloatBuffer: ...
	@overload
	def clear(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def duplicate(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def duplicate(self, ) -> javawrappers.java.nio.FloatBuffer: ...
	def remaining(self, ) -> Union[int, JInt]: ...
	@staticmethod
	def allocate(arg0: Union[int, JInt], ) -> javawrappers.java.nio.FloatBuffer: ...
	@overload
	def rewind(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def rewind(self, ) -> javawrappers.java.nio.FloatBuffer: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def mismatch(self, arg0: javawrappers.java.nio.FloatBuffer, ) -> Union[int, JInt]: ...
	@overload
	def reset(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def reset(self, ) -> javawrappers.java.nio.FloatBuffer: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def position(self, ) -> Union[int, JInt]: ...
	@overload
	def position(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.FloatBuffer: ...
	@overload
	def position(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.Buffer: ...
	@overload
	@staticmethod
	def wrap(arg0: JArray(Union[float, JFloat], 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.nio.FloatBuffer: ...
	@overload
	@staticmethod
	def wrap(arg0: JArray(Union[float, JFloat], 1), ) -> javawrappers.java.nio.FloatBuffer: ...
	def isDirect(self, ) -> Union[int, JBoolean]: ...
	@overload
	def mark(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def mark(self, ) -> javawrappers.java.nio.FloatBuffer: ...


class CharBuffer:
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def compact(self, ) -> javawrappers.java.nio.CharBuffer: ...
	def notifyAll(self, ) -> None: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.nio.CharBuffer, ) -> Union[int, JInt]: ...
	def notify(self, ) -> None: ...
	@overload
	def put(self, arg0: Union[int, JInt], arg1: Union[string, JString], ) -> javawrappers.java.nio.CharBuffer: ...
	@overload
	def put(self, arg0: JArray(Union[string, JString], 1), ) -> javawrappers.java.nio.CharBuffer: ...
	@overload
	def put(self, arg0: javawrappers.java.lang.String, arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.nio.CharBuffer: ...
	@overload
	def put(self, arg0: JArray(Union[string, JString], 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.nio.CharBuffer: ...
	@overload
	def put(self, arg0: javawrappers.java.nio.CharBuffer, ) -> javawrappers.java.nio.CharBuffer: ...
	@overload
	def put(self, arg0: Union[string, JString], ) -> javawrappers.java.nio.CharBuffer: ...
	@overload
	def put(self, arg0: javawrappers.java.lang.String, ) -> javawrappers.java.nio.CharBuffer: ...
	def asReadOnlyBuffer(self, ) -> javawrappers.java.nio.CharBuffer: ...
	def capacity(self, ) -> Union[int, JInt]: ...
	def isReadOnly(self, ) -> Union[int, JBoolean]: ...
	@overload
	def slice(self, ) -> javawrappers.java.nio.CharBuffer: ...
	@overload
	def slice(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def array(self, ) -> JArray(Union[string, JString], 1): ...
	@overload
	def array(self, ) -> javawrappers.java.lang.Object: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def get(self, arg0: JArray(Union[string, JString], 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.nio.CharBuffer: ...
	@overload
	def get(self, arg0: Union[int, JInt], ) -> Union[string, JString]: ...
	@overload
	def get(self, arg0: JArray(Union[string, JString], 1), ) -> javawrappers.java.nio.CharBuffer: ...
	@overload
	def get(self, ) -> Union[string, JString]: ...
	@overload
	def limit(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def limit(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.CharBuffer: ...
	@overload
	def limit(self, ) -> Union[int, JInt]: ...
	def arrayOffset(self, ) -> Union[int, JInt]: ...
	@overload
	def flip(self, ) -> javawrappers.java.nio.CharBuffer: ...
	@overload
	def flip(self, ) -> javawrappers.java.nio.Buffer: ...
	def codePoints(self, ) -> javawrappers.java.util.stream.IntStream: ...
	def order(self, ) -> javawrappers.java.nio.ByteOrder: ...
	def hasArray(self, ) -> Union[int, JBoolean]: ...
	def read(self, arg0: javawrappers.java.nio.CharBuffer, ) -> Union[int, JInt]: ...
	def hasRemaining(self, ) -> Union[int, JBoolean]: ...
	@overload
	def clear(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def clear(self, ) -> javawrappers.java.nio.CharBuffer: ...
	def length(self, ) -> Union[int, JInt]: ...
	@overload
	def duplicate(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def duplicate(self, ) -> javawrappers.java.nio.CharBuffer: ...
	@overload
	def subSequence(self, arg0: Union[int, JInt], arg1: Union[int, JInt], ) -> javawrappers.java.nio.CharBuffer: ...
	@overload
	def subSequence(self, arg0: Union[int, JInt], arg1: Union[int, JInt], ) -> javawrappers.java.lang.CharSequence: ...
	def remaining(self, ) -> Union[int, JInt]: ...
	@staticmethod
	def allocate(arg0: Union[int, JInt], ) -> javawrappers.java.nio.CharBuffer: ...
	@overload
	def rewind(self, ) -> javawrappers.java.nio.CharBuffer: ...
	@overload
	def rewind(self, ) -> javawrappers.java.nio.Buffer: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def mismatch(self, arg0: javawrappers.java.nio.CharBuffer, ) -> Union[int, JInt]: ...
	@overload
	def reset(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def reset(self, ) -> javawrappers.java.nio.CharBuffer: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def position(self, ) -> Union[int, JInt]: ...
	@overload
	def position(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.CharBuffer: ...
	@overload
	def position(self, arg0: Union[int, JInt], ) -> javawrappers.java.nio.Buffer: ...
	@overload
	@staticmethod
	def wrap(arg0: javawrappers.java.lang.CharSequence, arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.nio.CharBuffer: ...
	@overload
	@staticmethod
	def wrap(arg0: javawrappers.java.lang.CharSequence, ) -> javawrappers.java.nio.CharBuffer: ...
	@overload
	@staticmethod
	def wrap(arg0: JArray(Union[string, JString], 1), ) -> javawrappers.java.nio.CharBuffer: ...
	@overload
	@staticmethod
	def wrap(arg0: JArray(Union[string, JString], 1), arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.nio.CharBuffer: ...
	def isDirect(self, ) -> Union[int, JBoolean]: ...
	@overload
	def mark(self, ) -> javawrappers.java.nio.Buffer: ...
	@overload
	def mark(self, ) -> javawrappers.java.nio.CharBuffer: ...
	def chars(self, ) -> javawrappers.java.util.stream.IntStream: ...
	def charAt(self, arg0: Union[int, JInt], ) -> Union[string, JString]: ...
	@overload
	def append(self, arg0: javawrappers.java.lang.CharSequence, ) -> javawrappers.java.nio.CharBuffer: ...
	@overload
	def append(self, arg0: javawrappers.java.lang.CharSequence, ) -> javawrappers.java.lang.Appendable: ...
	@overload
	def append(self, arg0: Union[string, JString], ) -> javawrappers.java.nio.CharBuffer: ...
	@overload
	def append(self, arg0: Union[string, JString], ) -> javawrappers.java.lang.Appendable: ...
	@overload
	def append(self, arg0: javawrappers.java.lang.CharSequence, arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.nio.CharBuffer: ...
	@overload
	def append(self, arg0: javawrappers.java.lang.CharSequence, arg1: Union[int, JInt], arg2: Union[int, JInt], ) -> javawrappers.java.lang.Appendable: ...


