################################################################################
#          This file was automatically generated. Please do not edit.          #
################################################################################

import javawrappers.java.util
import javawrappers.java.time.format
import javawrappers.java.lang
import javawrappers.java.time
import javawrappers.java.io
import javawrappers.java.time.chrono
import javawrappers.java.time.temporal
import javawrappers.java.util.function

from jpype.types import *
from typing import Union

from typing import overload

class TemporalField:
	def resolve(self, arg0: javawrappers.java.util.Map, arg1: javawrappers.java.time.temporal.TemporalAccessor, arg2: javawrappers.java.time.format.ResolverStyle, ) -> javawrappers.java.time.temporal.TemporalAccessor: ...
	def getDisplayName(self, arg0: javawrappers.java.util.Locale, ) -> javawrappers.java.lang.String: ...
	def rangeRefinedBy(self, arg0: javawrappers.java.time.temporal.TemporalAccessor, ) -> javawrappers.java.time.temporal.ValueRange: ...
	def getBaseUnit(self, ) -> javawrappers.java.time.temporal.TemporalUnit: ...
	def isTimeBased(self, ) -> Union[int, JBoolean]: ...
	def adjustInto(self, arg0: javawrappers.java.time.temporal.Temporal, arg1: Union[long, JLong], ) -> javawrappers.java.time.temporal.Temporal: ...
	def range(self, ) -> javawrappers.java.time.temporal.ValueRange: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def getRangeUnit(self, ) -> javawrappers.java.time.temporal.TemporalUnit: ...
	def isDateBased(self, ) -> Union[int, JBoolean]: ...
	def isSupportedBy(self, arg0: javawrappers.java.time.temporal.TemporalAccessor, ) -> Union[int, JBoolean]: ...
	def getFrom(self, arg0: javawrappers.java.time.temporal.TemporalAccessor, ) -> Union[long, JLong]: ...


class JulianFields:
	class Field:
		JULIAN_DAY: JulianFields.Field = ...
		MODIFIED_JULIAN_DAY: JulianFields.Field = ...
		RATA_DIE: JulianFields.Field = ...
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		@overload
		def resolve(self, arg0: javawrappers.java.util.Map, arg1: javawrappers.java.time.temporal.TemporalAccessor, arg2: javawrappers.java.time.format.ResolverStyle, ) -> javawrappers.java.time.chrono.ChronoLocalDate: ...
		@overload
		def resolve(self, arg0: javawrappers.java.util.Map, arg1: javawrappers.java.time.temporal.TemporalAccessor, arg2: javawrappers.java.time.format.ResolverStyle, ) -> javawrappers.java.time.temporal.TemporalAccessor: ...
		@overload
		@staticmethod
		def valueOf(arg0: javawrappers.java.lang.Class, arg1: javawrappers.java.lang.String, ) -> javawrappers.java.lang.Enum: ...
		@overload
		@staticmethod
		def valueOf(arg0: javawrappers.java.lang.String, ) -> javawrappers.java.time.temporal.JulianFields.Field: ...
		def notifyAll(self, ) -> None: ...
		@staticmethod
		def values() -> JArray(javawrappers.java.time.temporal.JulianFields.Field, 1): ...
		def adjustInto(self, arg0: javawrappers.java.time.temporal.Temporal, arg1: Union[long, JLong], ) -> javawrappers.java.time.temporal.Temporal: ...
		def range(self, ) -> javawrappers.java.time.temporal.ValueRange: ...
		def getRangeUnit(self, ) -> javawrappers.java.time.temporal.TemporalUnit: ...
		@overload
		def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
		@overload
		def compareTo(self, arg0: javawrappers.java.lang.Enum, ) -> Union[int, JInt]: ...
		def notify(self, ) -> None: ...
		def getDeclaringClass(self, ) -> javawrappers.java.lang.Class: ...
		def getDisplayName(self, arg0: javawrappers.java.util.Locale, ) -> javawrappers.java.lang.String: ...
		def rangeRefinedBy(self, arg0: javawrappers.java.time.temporal.TemporalAccessor, ) -> javawrappers.java.time.temporal.ValueRange: ...
		def getBaseUnit(self, ) -> javawrappers.java.time.temporal.TemporalUnit: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def isTimeBased(self, ) -> Union[int, JBoolean]: ...
		def name(self, ) -> javawrappers.java.lang.String: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def isDateBased(self, ) -> Union[int, JBoolean]: ...
		def ordinal(self, ) -> Union[int, JInt]: ...
		def isSupportedBy(self, arg0: javawrappers.java.time.temporal.TemporalAccessor, ) -> Union[int, JBoolean]: ...
		def getFrom(self, arg0: javawrappers.java.time.temporal.TemporalAccessor, ) -> Union[long, JLong]: ...


	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@overload
	def resolve(self, arg0: javawrappers.java.util.Map, arg1: javawrappers.java.time.temporal.TemporalAccessor, arg2: javawrappers.java.time.format.ResolverStyle, ) -> javawrappers.java.time.chrono.ChronoLocalDate: ...
	@overload
	def resolve(self, arg0: javawrappers.java.util.Map, arg1: javawrappers.java.time.temporal.TemporalAccessor, arg2: javawrappers.java.time.format.ResolverStyle, ) -> javawrappers.java.time.temporal.TemporalAccessor: ...
	@overload
	@staticmethod
	def valueOf(arg0: javawrappers.java.lang.Class, arg1: javawrappers.java.lang.String, ) -> javawrappers.java.lang.Enum: ...
	@overload
	@staticmethod
	def valueOf(arg0: javawrappers.java.lang.String, ) -> javawrappers.java.time.temporal.JulianFields.Field: ...
	@staticmethod
	def values() -> JArray(javawrappers.java.time.temporal.JulianFields.Field, 1): ...
	def notifyAll(self, ) -> None: ...
	def adjustInto(self, arg0: javawrappers.java.time.temporal.Temporal, arg1: Union[long, JLong], ) -> javawrappers.java.time.temporal.Temporal: ...
	def range(self, ) -> javawrappers.java.time.temporal.ValueRange: ...
	def getRangeUnit(self, ) -> javawrappers.java.time.temporal.TemporalUnit: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Enum, ) -> Union[int, JInt]: ...
	def notify(self, ) -> None: ...
	def getDeclaringClass(self, ) -> javawrappers.java.lang.Class: ...
	def getDisplayName(self, arg0: javawrappers.java.util.Locale, ) -> javawrappers.java.lang.String: ...
	def rangeRefinedBy(self, arg0: javawrappers.java.time.temporal.TemporalAccessor, ) -> javawrappers.java.time.temporal.ValueRange: ...
	def getBaseUnit(self, ) -> javawrappers.java.time.temporal.TemporalUnit: ...
	@overload
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def hashCode(self, ) -> Union[int, JInt]: ...
	def isTimeBased(self, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def name(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def isDateBased(self, ) -> Union[int, JBoolean]: ...
	def ordinal(self, ) -> Union[int, JInt]: ...
	def isSupportedBy(self, arg0: javawrappers.java.time.temporal.TemporalAccessor, ) -> Union[int, JBoolean]: ...
	def getFrom(self, arg0: javawrappers.java.time.temporal.TemporalAccessor, ) -> Union[long, JLong]: ...


class TemporalUnit:
	def isDurationEstimated(self, ) -> Union[int, JBoolean]: ...
	def getDuration(self, ) -> javawrappers.java.time.Duration: ...
	def isTimeBased(self, ) -> Union[int, JBoolean]: ...
	def addTo(self, arg0: javawrappers.java.time.temporal.Temporal, arg1: Union[long, JLong], ) -> javawrappers.java.time.temporal.Temporal: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def isDateBased(self, ) -> Union[int, JBoolean]: ...
	def between(self, arg0: javawrappers.java.time.temporal.Temporal, arg1: javawrappers.java.time.temporal.Temporal, ) -> Union[long, JLong]: ...
	def isSupportedBy(self, arg0: javawrappers.java.time.temporal.Temporal, ) -> Union[int, JBoolean]: ...


class ChronoUnit:
	NANOS: ChronoUnit = ...
	MICROS: ChronoUnit = ...
	MILLIS: ChronoUnit = ...
	SECONDS: ChronoUnit = ...
	MINUTES: ChronoUnit = ...
	HOURS: ChronoUnit = ...
	HALF_DAYS: ChronoUnit = ...
	DAYS: ChronoUnit = ...
	WEEKS: ChronoUnit = ...
	MONTHS: ChronoUnit = ...
	YEARS: ChronoUnit = ...
	DECADES: ChronoUnit = ...
	CENTURIES: ChronoUnit = ...
	MILLENNIA: ChronoUnit = ...
	ERAS: ChronoUnit = ...
	FOREVER: ChronoUnit = ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@overload
	@staticmethod
	def valueOf(arg0: javawrappers.java.lang.Class, arg1: javawrappers.java.lang.String, ) -> javawrappers.java.lang.Enum: ...
	@overload
	@staticmethod
	def valueOf(arg0: javawrappers.java.lang.String, ) -> javawrappers.java.time.temporal.ChronoUnit: ...
	def notifyAll(self, ) -> None: ...
	@staticmethod
	def values() -> JArray(javawrappers.java.time.temporal.ChronoUnit, 1): ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Enum, ) -> Union[int, JInt]: ...
	def notify(self, ) -> None: ...
	def getDeclaringClass(self, ) -> javawrappers.java.lang.Class: ...
	def isDurationEstimated(self, ) -> Union[int, JBoolean]: ...
	def getDuration(self, ) -> javawrappers.java.time.Duration: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def isTimeBased(self, ) -> Union[int, JBoolean]: ...
	def name(self, ) -> javawrappers.java.lang.String: ...
	def addTo(self, arg0: javawrappers.java.time.temporal.Temporal, arg1: Union[long, JLong], ) -> javawrappers.java.time.temporal.Temporal: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def isDateBased(self, ) -> Union[int, JBoolean]: ...
	def between(self, arg0: javawrappers.java.time.temporal.Temporal, arg1: javawrappers.java.time.temporal.Temporal, ) -> Union[long, JLong]: ...
	def ordinal(self, ) -> Union[int, JInt]: ...
	def isSupportedBy(self, arg0: javawrappers.java.time.temporal.Temporal, ) -> Union[int, JBoolean]: ...


class WeekFields:
	class ComputedDayOfField:
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		@overload
		def resolve(self, arg0: javawrappers.java.util.Map, arg1: javawrappers.java.time.temporal.TemporalAccessor, arg2: javawrappers.java.time.format.ResolverStyle, ) -> javawrappers.java.time.chrono.ChronoLocalDate: ...
		@overload
		def resolve(self, arg0: javawrappers.java.util.Map, arg1: javawrappers.java.time.temporal.TemporalAccessor, arg2: javawrappers.java.time.format.ResolverStyle, ) -> javawrappers.java.time.temporal.TemporalAccessor: ...
		def notifyAll(self, ) -> None: ...
		def adjustInto(self, arg0: javawrappers.java.time.temporal.Temporal, arg1: Union[long, JLong], ) -> javawrappers.java.time.temporal.Temporal: ...
		def range(self, ) -> javawrappers.java.time.temporal.ValueRange: ...
		def getRangeUnit(self, ) -> javawrappers.java.time.temporal.TemporalUnit: ...
		def notify(self, ) -> None: ...
		def getDisplayName(self, arg0: javawrappers.java.util.Locale, ) -> javawrappers.java.lang.String: ...
		def rangeRefinedBy(self, arg0: javawrappers.java.time.temporal.TemporalAccessor, ) -> javawrappers.java.time.temporal.ValueRange: ...
		def getBaseUnit(self, ) -> javawrappers.java.time.temporal.TemporalUnit: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def isTimeBased(self, ) -> Union[int, JBoolean]: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def isDateBased(self, ) -> Union[int, JBoolean]: ...
		def isSupportedBy(self, arg0: javawrappers.java.time.temporal.TemporalAccessor, ) -> Union[int, JBoolean]: ...
		def getFrom(self, arg0: javawrappers.java.time.temporal.TemporalAccessor, ) -> Union[long, JLong]: ...


	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def getMinimalDaysInFirstWeek(self, ) -> Union[int, JInt]: ...
	def weekOfYear(self, ) -> javawrappers.java.time.temporal.TemporalField: ...
	@overload
	def resolve(self, arg0: javawrappers.java.util.Map, arg1: javawrappers.java.time.temporal.TemporalAccessor, arg2: javawrappers.java.time.format.ResolverStyle, ) -> javawrappers.java.time.chrono.ChronoLocalDate: ...
	@overload
	def resolve(self, arg0: javawrappers.java.util.Map, arg1: javawrappers.java.time.temporal.TemporalAccessor, arg2: javawrappers.java.time.format.ResolverStyle, ) -> javawrappers.java.time.temporal.TemporalAccessor: ...
	def notifyAll(self, ) -> None: ...
	def adjustInto(self, arg0: javawrappers.java.time.temporal.Temporal, arg1: Union[long, JLong], ) -> javawrappers.java.time.temporal.Temporal: ...
	def range(self, ) -> javawrappers.java.time.temporal.ValueRange: ...
	def getRangeUnit(self, ) -> javawrappers.java.time.temporal.TemporalUnit: ...
	def notify(self, ) -> None: ...
	def dayOfWeek(self, ) -> javawrappers.java.time.temporal.TemporalField: ...
	def getBaseUnit(self, ) -> javawrappers.java.time.temporal.TemporalUnit: ...
	def weekOfWeekBasedYear(self, ) -> javawrappers.java.time.temporal.TemporalField: ...
	@overload
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def hashCode(self, ) -> Union[int, JInt]: ...
	def isTimeBased(self, ) -> Union[int, JBoolean]: ...
	@overload
	@staticmethod
	def of(arg0: javawrappers.java.util.Locale, ) -> javawrappers.java.time.temporal.WeekFields: ...
	@overload
	@staticmethod
	def of(arg0: javawrappers.java.time.DayOfWeek, arg1: Union[int, JInt], ) -> javawrappers.java.time.temporal.WeekFields: ...
	def isDateBased(self, ) -> Union[int, JBoolean]: ...
	def getFrom(self, arg0: javawrappers.java.time.temporal.TemporalAccessor, ) -> Union[long, JLong]: ...
	def weekOfMonth(self, ) -> javawrappers.java.time.temporal.TemporalField: ...
	def weekBasedYear(self, ) -> javawrappers.java.time.temporal.TemporalField: ...
	def getFirstDayOfWeek(self, ) -> javawrappers.java.time.DayOfWeek: ...
	def getDisplayName(self, arg0: javawrappers.java.util.Locale, ) -> javawrappers.java.lang.String: ...
	def rangeRefinedBy(self, arg0: javawrappers.java.time.temporal.TemporalAccessor, ) -> javawrappers.java.time.temporal.ValueRange: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def isSupportedBy(self, arg0: javawrappers.java.time.temporal.TemporalAccessor, ) -> Union[int, JBoolean]: ...


class TemporalQuery:
	def queryFrom(self, arg0: javawrappers.java.time.temporal.TemporalAccessor, ) -> javawrappers.java.lang.Object: ...


class TemporalAdjusters:
	@staticmethod
	def next(arg0: javawrappers.java.time.DayOfWeek, ) -> javawrappers.java.time.temporal.TemporalAdjuster: ...
	@staticmethod
	def ofDateAdjuster(arg0: javawrappers.java.util.function.UnaryOperator, ) -> javawrappers.java.time.temporal.TemporalAdjuster: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@staticmethod
	def firstDayOfYear() -> javawrappers.java.time.temporal.TemporalAdjuster: ...
	@staticmethod
	def previous(arg0: javawrappers.java.time.DayOfWeek, ) -> javawrappers.java.time.temporal.TemporalAdjuster: ...
	@staticmethod
	def firstDayOfNextMonth() -> javawrappers.java.time.temporal.TemporalAdjuster: ...
	def notifyAll(self, ) -> None: ...
	@staticmethod
	def lastInMonth(arg0: javawrappers.java.time.DayOfWeek, ) -> javawrappers.java.time.temporal.TemporalAdjuster: ...
	@staticmethod
	def firstDayOfMonth() -> javawrappers.java.time.temporal.TemporalAdjuster: ...
	@staticmethod
	def firstDayOfNextYear() -> javawrappers.java.time.temporal.TemporalAdjuster: ...
	@staticmethod
	def lastDayOfMonth() -> javawrappers.java.time.temporal.TemporalAdjuster: ...
	def notify(self, ) -> None: ...
	@staticmethod
	def dayOfWeekInMonth(arg0: Union[int, JInt], arg1: javawrappers.java.time.DayOfWeek, ) -> javawrappers.java.time.temporal.TemporalAdjuster: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@staticmethod
	def nextOrSame(arg0: javawrappers.java.time.DayOfWeek, ) -> javawrappers.java.time.temporal.TemporalAdjuster: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@staticmethod
	def firstInMonth(arg0: javawrappers.java.time.DayOfWeek, ) -> javawrappers.java.time.temporal.TemporalAdjuster: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@staticmethod
	def lastDayOfYear() -> javawrappers.java.time.temporal.TemporalAdjuster: ...
	@staticmethod
	def previousOrSame(arg0: javawrappers.java.time.DayOfWeek, ) -> javawrappers.java.time.temporal.TemporalAdjuster: ...


class UnsupportedTemporalTypeException:
	@overload
	def __init__(self, arg0: javawrappers.java.lang.String, ): ...
	@overload
	def __init__(self, arg0: javawrappers.java.lang.String, arg1: javawrappers.java.lang.Throwable, ): ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@overload
	def printStackTrace(self, arg0: javawrappers.java.io.PrintStream, ) -> None: ...
	@overload
	def printStackTrace(self, ) -> None: ...
	@overload
	def printStackTrace(self, arg0: javawrappers.java.io.PrintWriter, ) -> None: ...
	def getLocalizedMessage(self, ) -> javawrappers.java.lang.String: ...
	def notifyAll(self, ) -> None: ...
	def initCause(self, arg0: javawrappers.java.lang.Throwable, ) -> javawrappers.java.lang.Throwable: ...
	def getMessage(self, ) -> javawrappers.java.lang.String: ...
	def getCause(self, ) -> javawrappers.java.lang.Throwable: ...
	def notify(self, ) -> None: ...
	def addSuppressed(self, arg0: javawrappers.java.lang.Throwable, ) -> None: ...
	def setStackTrace(self, arg0: JArray(javawrappers.java.lang.StackTraceElement, 1), ) -> None: ...
	def getStackTrace(self, ) -> JArray(javawrappers.java.lang.StackTraceElement, 1): ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def getSuppressed(self, ) -> JArray(javawrappers.java.lang.Throwable, 1): ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def fillInStackTrace(self, ) -> javawrappers.java.lang.Throwable: ...


class IsoFields:
	class Unit:
		WEEK_BASED_YEARS: IsoFields.Unit = ...
		QUARTER_YEARS: IsoFields.Unit = ...
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		@overload
		@staticmethod
		def valueOf(arg0: javawrappers.java.lang.Class, arg1: javawrappers.java.lang.String, ) -> javawrappers.java.lang.Enum: ...
		@overload
		@staticmethod
		def valueOf(arg0: javawrappers.java.lang.String, ) -> javawrappers.java.time.temporal.IsoFields.Unit: ...
		def notifyAll(self, ) -> None: ...
		@staticmethod
		def values() -> JArray(javawrappers.java.time.temporal.IsoFields.Unit, 1): ...
		@overload
		def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
		@overload
		def compareTo(self, arg0: javawrappers.java.lang.Enum, ) -> Union[int, JInt]: ...
		def notify(self, ) -> None: ...
		def getDeclaringClass(self, ) -> javawrappers.java.lang.Class: ...
		def isDurationEstimated(self, ) -> Union[int, JBoolean]: ...
		def getDuration(self, ) -> javawrappers.java.time.Duration: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def isTimeBased(self, ) -> Union[int, JBoolean]: ...
		def name(self, ) -> javawrappers.java.lang.String: ...
		def addTo(self, arg0: javawrappers.java.time.temporal.Temporal, arg1: Union[long, JLong], ) -> javawrappers.java.time.temporal.Temporal: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def isDateBased(self, ) -> Union[int, JBoolean]: ...
		def between(self, arg0: javawrappers.java.time.temporal.Temporal, arg1: javawrappers.java.time.temporal.Temporal, ) -> Union[long, JLong]: ...
		def ordinal(self, ) -> Union[int, JInt]: ...
		def isSupportedBy(self, arg0: javawrappers.java.time.temporal.Temporal, ) -> Union[int, JBoolean]: ...


	class Field:
		DAY_OF_QUARTER: IsoFields.Field = ...
		QUARTER_OF_YEAR: IsoFields.Field = ...
		WEEK_OF_WEEK_BASED_YEAR: IsoFields.Field = ...
		WEEK_BASED_YEAR: IsoFields.Field = ...
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def resolve(self, arg0: javawrappers.java.util.Map, arg1: javawrappers.java.time.temporal.TemporalAccessor, arg2: javawrappers.java.time.format.ResolverStyle, ) -> javawrappers.java.time.temporal.TemporalAccessor: ...
		@overload
		@staticmethod
		def valueOf(arg0: javawrappers.java.lang.Class, arg1: javawrappers.java.lang.String, ) -> javawrappers.java.lang.Enum: ...
		@overload
		@staticmethod
		def valueOf(arg0: javawrappers.java.lang.String, ) -> javawrappers.java.time.temporal.IsoFields.Field: ...
		def notifyAll(self, ) -> None: ...
		@staticmethod
		def values() -> JArray(javawrappers.java.time.temporal.IsoFields.Field, 1): ...
		def adjustInto(self, arg0: javawrappers.java.time.temporal.Temporal, arg1: Union[long, JLong], ) -> javawrappers.java.time.temporal.Temporal: ...
		def range(self, ) -> javawrappers.java.time.temporal.ValueRange: ...
		def getRangeUnit(self, ) -> javawrappers.java.time.temporal.TemporalUnit: ...
		@overload
		def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
		@overload
		def compareTo(self, arg0: javawrappers.java.lang.Enum, ) -> Union[int, JInt]: ...
		def notify(self, ) -> None: ...
		def getDeclaringClass(self, ) -> javawrappers.java.lang.Class: ...
		def getDisplayName(self, arg0: javawrappers.java.util.Locale, ) -> javawrappers.java.lang.String: ...
		def getBaseUnit(self, ) -> javawrappers.java.time.temporal.TemporalUnit: ...
		def rangeRefinedBy(self, arg0: javawrappers.java.time.temporal.TemporalAccessor, ) -> javawrappers.java.time.temporal.ValueRange: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def isTimeBased(self, ) -> Union[int, JBoolean]: ...
		def name(self, ) -> javawrappers.java.lang.String: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def isDateBased(self, ) -> Union[int, JBoolean]: ...
		def isSupportedBy(self, arg0: javawrappers.java.time.temporal.TemporalAccessor, ) -> Union[int, JBoolean]: ...
		def getFrom(self, arg0: javawrappers.java.time.temporal.TemporalAccessor, ) -> Union[long, JLong]: ...
		def ordinal(self, ) -> Union[int, JInt]: ...


	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def resolve(self, arg0: javawrappers.java.util.Map, arg1: javawrappers.java.time.temporal.TemporalAccessor, arg2: javawrappers.java.time.format.ResolverStyle, ) -> javawrappers.java.time.temporal.TemporalAccessor: ...
	@overload
	@staticmethod
	def values() -> JArray(javawrappers.java.time.temporal.IsoFields.Field, 1): ...
	@overload
	@staticmethod
	def values() -> JArray(javawrappers.java.time.temporal.IsoFields.Unit, 1): ...
	def notifyAll(self, ) -> None: ...
	def adjustInto(self, arg0: javawrappers.java.time.temporal.Temporal, arg1: Union[long, JLong], ) -> javawrappers.java.time.temporal.Temporal: ...
	def range(self, ) -> javawrappers.java.time.temporal.ValueRange: ...
	def getRangeUnit(self, ) -> javawrappers.java.time.temporal.TemporalUnit: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Enum, ) -> Union[int, JInt]: ...
	def notify(self, ) -> None: ...
	def getDeclaringClass(self, ) -> javawrappers.java.lang.Class: ...
	def isDurationEstimated(self, ) -> Union[int, JBoolean]: ...
	def getDuration(self, ) -> javawrappers.java.time.Duration: ...
	def getBaseUnit(self, ) -> javawrappers.java.time.temporal.TemporalUnit: ...
	@overload
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def isTimeBased(self, ) -> Union[int, JBoolean]: ...
	@overload
	def isTimeBased(self, ) -> Union[int, JBoolean]: ...
	@overload
	def isDateBased(self, ) -> Union[int, JBoolean]: ...
	@overload
	def isDateBased(self, ) -> Union[int, JBoolean]: ...
	def between(self, arg0: javawrappers.java.time.temporal.Temporal, arg1: javawrappers.java.time.temporal.Temporal, ) -> Union[long, JLong]: ...
	def getFrom(self, arg0: javawrappers.java.time.temporal.TemporalAccessor, ) -> Union[long, JLong]: ...
	@overload
	@staticmethod
	def valueOf(arg0: javawrappers.java.lang.Class, arg1: javawrappers.java.lang.String, ) -> javawrappers.java.lang.Enum: ...
	@overload
	@staticmethod
	def valueOf(arg0: javawrappers.java.lang.String, ) -> javawrappers.java.time.temporal.IsoFields.Field: ...
	@overload
	@staticmethod
	def valueOf(arg0: javawrappers.java.lang.String, ) -> javawrappers.java.time.temporal.IsoFields.Unit: ...
	def getDisplayName(self, arg0: javawrappers.java.util.Locale, ) -> javawrappers.java.lang.String: ...
	def rangeRefinedBy(self, arg0: javawrappers.java.time.temporal.TemporalAccessor, ) -> javawrappers.java.time.temporal.ValueRange: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def name(self, ) -> javawrappers.java.lang.String: ...
	def addTo(self, arg0: javawrappers.java.time.temporal.Temporal, arg1: Union[long, JLong], ) -> javawrappers.java.time.temporal.Temporal: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def isSupportedBy(self, arg0: javawrappers.java.time.temporal.TemporalAccessor, ) -> Union[int, JBoolean]: ...
	@overload
	def isSupportedBy(self, arg0: javawrappers.java.time.temporal.Temporal, ) -> Union[int, JBoolean]: ...
	def ordinal(self, ) -> Union[int, JInt]: ...


class TemporalAmount:
	def subtractFrom(self, arg0: javawrappers.java.time.temporal.Temporal, ) -> javawrappers.java.time.temporal.Temporal: ...
	def get(self, arg0: javawrappers.java.time.temporal.TemporalUnit, ) -> Union[long, JLong]: ...
	def getUnits(self, ) -> javawrappers.java.util.List: ...
	def addTo(self, arg0: javawrappers.java.time.temporal.Temporal, ) -> javawrappers.java.time.temporal.Temporal: ...


class ValueRange:
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def notifyAll(self, ) -> None: ...
	def getMaximum(self, ) -> Union[long, JLong]: ...
	def getSmallestMaximum(self, ) -> Union[long, JLong]: ...
	def notify(self, ) -> None: ...
	def isIntValue(self, ) -> Union[int, JBoolean]: ...
	def isValidValue(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...
	def getLargestMinimum(self, ) -> Union[long, JLong]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	@staticmethod
	def of(arg0: Union[long, JLong], arg1: Union[long, JLong], ) -> javawrappers.java.time.temporal.ValueRange: ...
	@overload
	@staticmethod
	def of(arg0: Union[long, JLong], arg1: Union[long, JLong], arg2: Union[long, JLong], ) -> javawrappers.java.time.temporal.ValueRange: ...
	@overload
	@staticmethod
	def of(arg0: Union[long, JLong], arg1: Union[long, JLong], arg2: Union[long, JLong], arg3: Union[long, JLong], ) -> javawrappers.java.time.temporal.ValueRange: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def getMinimum(self, ) -> Union[long, JLong]: ...
	def checkValidValue(self, arg0: Union[long, JLong], arg1: javawrappers.java.time.temporal.TemporalField, ) -> Union[long, JLong]: ...
	def checkValidIntValue(self, arg0: Union[long, JLong], arg1: javawrappers.java.time.temporal.TemporalField, ) -> Union[int, JInt]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def isFixed(self, ) -> Union[int, JBoolean]: ...
	def isValidIntValue(self, arg0: Union[long, JLong], ) -> Union[int, JBoolean]: ...


class TemporalAdjuster:
	def adjustInto(self, arg0: javawrappers.java.time.temporal.Temporal, ) -> javawrappers.java.time.temporal.Temporal: ...


class TemporalQueries:
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@staticmethod
	def offset() -> javawrappers.java.time.temporal.TemporalQuery: ...
	def notifyAll(self, ) -> None: ...
	@staticmethod
	def precision() -> javawrappers.java.time.temporal.TemporalQuery: ...
	@staticmethod
	def chronology() -> javawrappers.java.time.temporal.TemporalQuery: ...
	def notify(self, ) -> None: ...
	@staticmethod
	def localTime() -> javawrappers.java.time.temporal.TemporalQuery: ...
	@staticmethod
	def zone() -> javawrappers.java.time.temporal.TemporalQuery: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@staticmethod
	def zoneId() -> javawrappers.java.time.temporal.TemporalQuery: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@staticmethod
	def localDate() -> javawrappers.java.time.temporal.TemporalQuery: ...


class ChronoField:
	NANO_OF_SECOND: ChronoField = ...
	NANO_OF_DAY: ChronoField = ...
	MICRO_OF_SECOND: ChronoField = ...
	MICRO_OF_DAY: ChronoField = ...
	MILLI_OF_SECOND: ChronoField = ...
	MILLI_OF_DAY: ChronoField = ...
	SECOND_OF_MINUTE: ChronoField = ...
	SECOND_OF_DAY: ChronoField = ...
	MINUTE_OF_HOUR: ChronoField = ...
	MINUTE_OF_DAY: ChronoField = ...
	HOUR_OF_AMPM: ChronoField = ...
	CLOCK_HOUR_OF_AMPM: ChronoField = ...
	HOUR_OF_DAY: ChronoField = ...
	CLOCK_HOUR_OF_DAY: ChronoField = ...
	AMPM_OF_DAY: ChronoField = ...
	DAY_OF_WEEK: ChronoField = ...
	ALIGNED_DAY_OF_WEEK_IN_MONTH: ChronoField = ...
	ALIGNED_DAY_OF_WEEK_IN_YEAR: ChronoField = ...
	DAY_OF_MONTH: ChronoField = ...
	DAY_OF_YEAR: ChronoField = ...
	EPOCH_DAY: ChronoField = ...
	ALIGNED_WEEK_OF_MONTH: ChronoField = ...
	ALIGNED_WEEK_OF_YEAR: ChronoField = ...
	MONTH_OF_YEAR: ChronoField = ...
	PROLEPTIC_MONTH: ChronoField = ...
	YEAR_OF_ERA: ChronoField = ...
	YEAR: ChronoField = ...
	ERA: ChronoField = ...
	INSTANT_SECONDS: ChronoField = ...
	OFFSET_SECONDS: ChronoField = ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def resolve(self, arg0: javawrappers.java.util.Map, arg1: javawrappers.java.time.temporal.TemporalAccessor, arg2: javawrappers.java.time.format.ResolverStyle, ) -> javawrappers.java.time.temporal.TemporalAccessor: ...
	def notifyAll(self, ) -> None: ...
	@staticmethod
	def values() -> JArray(javawrappers.java.time.temporal.ChronoField, 1): ...
	def adjustInto(self, arg0: javawrappers.java.time.temporal.Temporal, arg1: Union[long, JLong], ) -> javawrappers.java.time.temporal.Temporal: ...
	def range(self, ) -> javawrappers.java.time.temporal.ValueRange: ...
	def getRangeUnit(self, ) -> javawrappers.java.time.temporal.TemporalUnit: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Enum, ) -> Union[int, JInt]: ...
	def notify(self, ) -> None: ...
	def getDeclaringClass(self, ) -> javawrappers.java.lang.Class: ...
	def getBaseUnit(self, ) -> javawrappers.java.time.temporal.TemporalUnit: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def isTimeBased(self, ) -> Union[int, JBoolean]: ...
	def checkValidIntValue(self, arg0: Union[long, JLong], ) -> Union[int, JInt]: ...
	def isDateBased(self, ) -> Union[int, JBoolean]: ...
	def getFrom(self, arg0: javawrappers.java.time.temporal.TemporalAccessor, ) -> Union[long, JLong]: ...
	@overload
	@staticmethod
	def valueOf(arg0: javawrappers.java.lang.Class, arg1: javawrappers.java.lang.String, ) -> javawrappers.java.lang.Enum: ...
	@overload
	@staticmethod
	def valueOf(arg0: javawrappers.java.lang.String, ) -> javawrappers.java.time.temporal.ChronoField: ...
	def getDisplayName(self, arg0: javawrappers.java.util.Locale, ) -> javawrappers.java.lang.String: ...
	def rangeRefinedBy(self, arg0: javawrappers.java.time.temporal.TemporalAccessor, ) -> javawrappers.java.time.temporal.ValueRange: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def name(self, ) -> javawrappers.java.lang.String: ...
	def checkValidValue(self, arg0: Union[long, JLong], ) -> Union[long, JLong]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def ordinal(self, ) -> Union[int, JInt]: ...
	def isSupportedBy(self, arg0: javawrappers.java.time.temporal.TemporalAccessor, ) -> Union[int, JBoolean]: ...


class Temporal:
	def getLong(self, arg0: javawrappers.java.time.temporal.TemporalField, ) -> Union[long, JLong]: ...
	@overload
	def with(self, arg0: javawrappers.java.time.temporal.TemporalField, arg1: Union[long, JLong], ) -> javawrappers.java.time.temporal.Temporal: ...
	@overload
	def with(self, arg0: javawrappers.java.time.temporal.TemporalAdjuster, ) -> javawrappers.java.time.temporal.Temporal: ...
	@overload
	def minus(self, arg0: javawrappers.java.time.temporal.TemporalAmount, ) -> javawrappers.java.time.temporal.Temporal: ...
	@overload
	def minus(self, arg0: Union[long, JLong], arg1: javawrappers.java.time.temporal.TemporalUnit, ) -> javawrappers.java.time.temporal.Temporal: ...
	def query(self, arg0: javawrappers.java.time.temporal.TemporalQuery, ) -> javawrappers.java.lang.Object: ...
	def get(self, arg0: javawrappers.java.time.temporal.TemporalField, ) -> Union[int, JInt]: ...
	def range(self, arg0: javawrappers.java.time.temporal.TemporalField, ) -> javawrappers.java.time.temporal.ValueRange: ...
	def until(self, arg0: javawrappers.java.time.temporal.Temporal, arg1: javawrappers.java.time.temporal.TemporalUnit, ) -> Union[long, JLong]: ...
	@overload
	def isSupported(self, arg0: javawrappers.java.time.temporal.TemporalField, ) -> Union[int, JBoolean]: ...
	@overload
	def isSupported(self, arg0: javawrappers.java.time.temporal.TemporalUnit, ) -> Union[int, JBoolean]: ...
	@overload
	def plus(self, arg0: Union[long, JLong], arg1: javawrappers.java.time.temporal.TemporalUnit, ) -> javawrappers.java.time.temporal.Temporal: ...
	@overload
	def plus(self, arg0: javawrappers.java.time.temporal.TemporalAmount, ) -> javawrappers.java.time.temporal.Temporal: ...


class TemporalAccessor:
	def getLong(self, arg0: javawrappers.java.time.temporal.TemporalField, ) -> Union[long, JLong]: ...
	def query(self, arg0: javawrappers.java.time.temporal.TemporalQuery, ) -> javawrappers.java.lang.Object: ...
	def get(self, arg0: javawrappers.java.time.temporal.TemporalField, ) -> Union[int, JInt]: ...
	def range(self, arg0: javawrappers.java.time.temporal.TemporalField, ) -> javawrappers.java.time.temporal.ValueRange: ...
	def isSupported(self, arg0: javawrappers.java.time.temporal.TemporalField, ) -> Union[int, JBoolean]: ...


