################################################################################
#          This file was automatically generated. Please do not edit.          #
################################################################################

import javawrappers.javax.measure
import javawrappers.java.lang
import javawrappers.java.time
import javawrappers.tec.uom.se
import javawrappers.java.util.concurrent
import javawrappers.tec.uom.se.quantity.time
import javawrappers.java.time.temporal
import javawrappers.java.util.function
import javawrappers.java.math

from jpype.types import *
from typing import Union

from typing import overload

class TimeUnitQuantity:
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def notifyAll(self, ) -> None: ...
	def decimalValue(self, arg0: javawrappers.javax.measure.Unit, arg1: javawrappers.java.math.MathContext, ) -> javawrappers.java.math.BigDecimal: ...
	def isBig(self, ) -> Union[int, JBoolean]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JInt]: ...
	def notify(self, ) -> None: ...
	@overload
	def asType(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def asType(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def isEquivalentTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	def toQuantity(self, ) -> javawrappers.javax.measure.Quantity: ...
	def isGreaterThanOrEqualTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	@staticmethod
	def of(arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.quantity.time.TimeUnitQuantity: ...
	@overload
	@staticmethod
	def of(arg0: javawrappers.java.util.concurrent.TimeUnit, arg1: javawrappers.java.lang.Integer, ) -> javawrappers.tec.uom.se.quantity.time.TimeUnitQuantity: ...
	@overload
	def divide(self, arg0: javawrappers.javax.measure.Quantity, arg1: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def divide(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def divide(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def divide(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def divide(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def multiply(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def multiply(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def multiply(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def multiply(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def multiply(self, arg0: javawrappers.javax.measure.Quantity, arg1: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def add(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def add(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def isLessThan(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	@overload
	def inverse(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def inverse(self, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def inverse(self, ) -> javawrappers.javax.measure.Quantity: ...
	def intValue(self, arg0: javawrappers.javax.measure.Unit, ) -> Union[int, JInt]: ...
	def toSI(self, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def subtract(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def subtract(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	def isGreaterThan(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	def toUnit(self, ) -> javawrappers.javax.measure.Unit: ...
	@staticmethod
	def parse(arg0: javawrappers.java.lang.CharSequence, ) -> javawrappers.javax.measure.Quantity: ...
	def doubleValue(self, arg0: javawrappers.javax.measure.Unit, ) -> Union[float, JDouble]: ...
	def getTimeUnit(self, ) -> javawrappers.java.util.concurrent.TimeUnit: ...
	@overload
	def getValue(self, ) -> javawrappers.java.lang.Number: ...
	@overload
	def getValue(self, ) -> javawrappers.java.lang.Object: ...
	@overload
	def getValue(self, ) -> javawrappers.java.lang.Integer: ...
	def isLessThanOrEqualTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.tec.uom.se.AbstractQuantity, arg1: Union[float, JDouble], arg2: javawrappers.javax.measure.Unit, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def to(self, arg0: javawrappers.javax.measure.Unit, arg1: javawrappers.java.math.MathContext, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def to(self, arg0: javawrappers.javax.measure.Unit, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def to(self, arg0: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def to(self, arg0: javawrappers.java.util.concurrent.TimeUnit, ) -> javawrappers.tec.uom.se.quantity.time.TimeUnitQuantity: ...
	def getUnit(self, ) -> javawrappers.javax.measure.Unit: ...


class TimedData:
	def getInstant(self, ) -> javawrappers.java.time.Instant: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def getName(self, ) -> javawrappers.java.lang.String: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def getTimestamp(self, ) -> Union[long, JLong]: ...
	def notifyAll(self, ) -> None: ...
	@staticmethod
	def of(arg0: javawrappers.java.lang.Object, arg1: Union[long, JLong], ) -> javawrappers.tec.uom.se.quantity.time.TimedData: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def get(self, ) -> javawrappers.java.lang.Object: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def notify(self, ) -> None: ...


class TemporalQuantity:
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def notifyAll(self, ) -> None: ...
	def decimalValue(self, arg0: javawrappers.javax.measure.Unit, arg1: javawrappers.java.math.MathContext, ) -> javawrappers.java.math.BigDecimal: ...
	def isBig(self, ) -> Union[int, JBoolean]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JInt]: ...
	def notify(self, ) -> None: ...
	@overload
	def asType(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def asType(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def getTemporalAmount(self, ) -> javawrappers.java.time.temporal.TemporalAmount: ...
	def isEquivalentTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	def toQuantity(self, ) -> javawrappers.javax.measure.Quantity: ...
	def isGreaterThanOrEqualTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def getTemporalUnit(self, ) -> javawrappers.java.time.temporal.TemporalUnit: ...
	@overload
	@staticmethod
	def of(arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.quantity.time.TemporalQuantity: ...
	@overload
	@staticmethod
	def of(arg0: javawrappers.java.lang.Integer, arg1: javawrappers.java.time.temporal.TemporalUnit, ) -> javawrappers.tec.uom.se.quantity.time.TemporalQuantity: ...
	@overload
	def divide(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def divide(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def divide(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def divide(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def divide(self, arg0: javawrappers.javax.measure.Quantity, arg1: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def multiply(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def multiply(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def multiply(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def multiply(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def multiply(self, arg0: javawrappers.javax.measure.Quantity, arg1: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def add(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def add(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def isLessThan(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	@overload
	def inverse(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def inverse(self, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def inverse(self, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def intValue(self, arg0: javawrappers.javax.measure.Unit, ) -> Union[int, JInt]: ...
	def toSI(self, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def subtract(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def subtract(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	def isGreaterThan(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	def toUnit(self, ) -> javawrappers.javax.measure.Unit: ...
	@staticmethod
	def parse(arg0: javawrappers.java.lang.CharSequence, ) -> javawrappers.javax.measure.Quantity: ...
	def doubleValue(self, arg0: javawrappers.javax.measure.Unit, ) -> Union[float, JDouble]: ...
	@overload
	def getValue(self, ) -> javawrappers.java.lang.Number: ...
	@overload
	def getValue(self, ) -> javawrappers.java.lang.Object: ...
	@overload
	def getValue(self, ) -> javawrappers.java.lang.Integer: ...
	def isLessThanOrEqualTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.tec.uom.se.AbstractQuantity, arg1: Union[float, JDouble], arg2: javawrappers.javax.measure.Unit, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def to(self, arg0: javawrappers.java.time.temporal.TemporalUnit, ) -> javawrappers.tec.uom.se.quantity.time.TemporalQuantity: ...
	@overload
	def to(self, arg0: javawrappers.javax.measure.Unit, arg1: javawrappers.java.math.MathContext, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def to(self, arg0: javawrappers.javax.measure.Unit, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def to(self, arg0: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def getUnit(self, ) -> javawrappers.javax.measure.Unit: ...


class TimeQuantities:
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@overload
	@staticmethod
	def getQuantity(arg0: javawrappers.java.lang.Integer, arg1: javawrappers.java.time.temporal.TemporalUnit, ) -> javawrappers.tec.uom.se.quantity.time.TemporalQuantity: ...
	@overload
	@staticmethod
	def getQuantity(arg0: javawrappers.java.time.LocalTime, arg1: javawrappers.java.util.function.Supplier, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	@staticmethod
	def getQuantity(arg0: javawrappers.java.time.temporal.Temporal, arg1: javawrappers.java.util.function.Supplier, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	@staticmethod
	def getQuantity(arg0: javawrappers.java.time.LocalTime, arg1: javawrappers.java.time.LocalTime, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	@staticmethod
	def getQuantity(arg0: javawrappers.java.time.temporal.Temporal, arg1: javawrappers.java.time.temporal.Temporal, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	@staticmethod
	def getQuantity(arg0: javawrappers.java.lang.Integer, arg1: javawrappers.java.util.concurrent.TimeUnit, ) -> javawrappers.tec.uom.se.quantity.time.TimeUnitQuantity: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@staticmethod
	def toTemporalSeconds(arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.quantity.time.TemporalQuantity: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def notify(self, ) -> None: ...
	@staticmethod
	def toTimeUnitSeconds(arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.quantity.time.TimeUnitQuantity: ...


