################################################################################
#          This file was automatically generated. Please do not edit.          #
################################################################################

import javawrappers.javax.measure
import javawrappers.javax.measure.spi
import javawrappers.java.lang.reflect
import javawrappers.java.lang
import javawrappers.java.util
import javawrappers.tec.uom.se
import javawrappers.tec.uom.se.quantity
import javawrappers.java.math

from jpype.types import *
from typing import Union

from typing import overload

class NumberQuantity:
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def notifyAll(self, ) -> None: ...
	def decimalValue(self, arg0: javawrappers.javax.measure.Unit, arg1: javawrappers.java.math.MathContext, ) -> javawrappers.java.math.BigDecimal: ...
	def isBig(self, ) -> Union[int, JBoolean]: ...
	@overload
	def compareTo(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JInt]: ...
	@overload
	def compareTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JInt]: ...
	def notify(self, ) -> None: ...
	@overload
	def asType(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def asType(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def isEquivalentTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	def isGreaterThanOrEqualTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	@staticmethod
	def of(arg0: Union[float, JFloat], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: Union[float, JDouble], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: Union[int, JInt], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: Union[long, JLong], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: Union[int, JShort], arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	@staticmethod
	def of(arg0: JByte, arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.AbstractQuantity: ...
	@overload
	def divide(self, arg0: javawrappers.javax.measure.Quantity, arg1: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def divide(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def divide(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def divide(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def divide(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def multiply(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def multiply(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def multiply(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def multiply(self, arg0: javawrappers.java.lang.Number, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def multiply(self, arg0: javawrappers.javax.measure.Quantity, arg1: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def add(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def add(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def isLessThan(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	@overload
	def inverse(self, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def inverse(self, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def inverse(self, arg0: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def intValue(self, arg0: javawrappers.javax.measure.Unit, ) -> Union[int, JInt]: ...
	def toSI(self, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def subtract(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	def subtract(self, arg0: javawrappers.javax.measure.Quantity, ) -> javawrappers.javax.measure.Quantity: ...
	def isGreaterThan(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	@staticmethod
	def parse(arg0: javawrappers.java.lang.CharSequence, ) -> javawrappers.javax.measure.Quantity: ...
	def doubleValue(self, arg0: javawrappers.javax.measure.Unit, ) -> Union[float, JDouble]: ...
	@overload
	def getValue(self, ) -> javawrappers.java.lang.Object: ...
	@overload
	def getValue(self, ) -> javawrappers.java.lang.Number: ...
	def isLessThanOrEqualTo(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.tec.uom.se.AbstractQuantity, arg1: Union[float, JDouble], arg2: javawrappers.javax.measure.Unit, ) -> Union[int, JBoolean]: ...
	@overload
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@overload
	def to(self, arg0: javawrappers.javax.measure.Unit, arg1: javawrappers.java.math.MathContext, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def to(self, arg0: javawrappers.javax.measure.Unit, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def to(self, arg0: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def getUnit(self, ) -> javawrappers.javax.measure.Unit: ...


class QuantityDimension:
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def getBaseDimensions(self, ) -> javawrappers.java.util.Map: ...
	def notifyAll(self, ) -> None: ...
	@staticmethod
	def parse(arg0: Union[string, JString], ) -> javawrappers.javax.measure.Dimension: ...
	def notify(self, ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	def root(self, arg0: Union[int, JInt], ) -> javawrappers.tec.uom.se.quantity.QuantityDimension: ...
	@overload
	def root(self, arg0: Union[int, JInt], ) -> javawrappers.javax.measure.Dimension: ...
	@staticmethod
	def of(arg0: javawrappers.java.lang.Class, ) -> javawrappers.javax.measure.Dimension: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def pow(self, arg0: Union[int, JInt], ) -> javawrappers.javax.measure.Dimension: ...
	@overload
	def pow(self, arg0: Union[int, JInt], ) -> javawrappers.tec.uom.se.quantity.QuantityDimension: ...
	@overload
	def divide(self, arg0: javawrappers.tec.uom.se.quantity.QuantityDimension, ) -> javawrappers.tec.uom.se.quantity.QuantityDimension: ...
	@overload
	def divide(self, arg0: javawrappers.javax.measure.Dimension, ) -> javawrappers.javax.measure.Dimension: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@staticmethod
	def getInstance(arg0: javawrappers.java.lang.Class, ) -> javawrappers.javax.measure.Dimension: ...
	@overload
	def multiply(self, arg0: javawrappers.javax.measure.Dimension, ) -> javawrappers.javax.measure.Dimension: ...
	@overload
	def multiply(self, arg0: javawrappers.tec.uom.se.quantity.QuantityDimension, ) -> javawrappers.tec.uom.se.quantity.QuantityDimension: ...


class DefaultQuantityFactory:
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def create(self, arg0: javawrappers.java.lang.Number, arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.javax.measure.Quantity: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@staticmethod
	def getInstance(arg0: javawrappers.java.lang.Class, ) -> javawrappers.javax.measure.spi.QuantityFactory: ...
	def getSystemUnit(self, ) -> javawrappers.javax.measure.Unit: ...
	def notify(self, ) -> None: ...


class QuantityRange:
	def getResolution(self, ) -> javawrappers.java.lang.Object: ...
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def hasMinimum(self, ) -> Union[int, JBoolean]: ...
	def notifyAll(self, ) -> None: ...
	def getMaximum(self, ) -> javawrappers.java.lang.Object: ...
	def notify(self, ) -> None: ...
	@overload
	def contains(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def contains(self, arg0: javawrappers.javax.measure.Quantity, ) -> Union[int, JBoolean]: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	@overload
	@staticmethod
	def of(arg0: javawrappers.javax.measure.Quantity, arg1: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.quantity.QuantityRange: ...
	@overload
	@staticmethod
	def of(arg0: javawrappers.javax.measure.Quantity, arg1: javawrappers.javax.measure.Quantity, arg2: javawrappers.javax.measure.Quantity, ) -> javawrappers.tec.uom.se.quantity.QuantityRange: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def getMinimum(self, ) -> javawrappers.java.lang.Object: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def hasMaximum(self, ) -> Union[int, JBoolean]: ...


class Quantities:
	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	@overload
	@staticmethod
	def getQuantity(arg0: javawrappers.java.lang.CharSequence, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	@overload
	@staticmethod
	def getQuantity(arg0: javawrappers.java.lang.Number, arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.tec.uom.se.ComparableQuantity: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	def notify(self, ) -> None: ...


class ProxyQuantityFactory:
	def __init__(self, ): ...
	class GenericHandler:
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		def invoke(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.reflect.Method, arg2: JArray(javawrappers.java.lang.Object, 1), ) -> javawrappers.java.lang.Object: ...
		def notify(self, ) -> None: ...


	class Default:
		def getClass(self, ) -> javawrappers.java.lang.Class: ...
		@overload
		def wait(self, arg0: Union[long, JLong], ) -> None: ...
		@overload
		def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
		@overload
		def wait(self, ) -> None: ...
		def hashCode(self, ) -> Union[int, JInt]: ...
		def notifyAll(self, ) -> None: ...
		def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
		def create(self, arg0: javawrappers.java.lang.Number, arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.javax.measure.Quantity: ...
		def toString(self, ) -> javawrappers.java.lang.String: ...
		@staticmethod
		def getInstance(arg0: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.quantity.ProxyQuantityFactory: ...
		def getSystemUnit(self, ) -> javawrappers.javax.measure.Unit: ...
		def notify(self, ) -> None: ...


	def getClass(self, ) -> javawrappers.java.lang.Class: ...
	@overload
	def wait(self, arg0: Union[long, JLong], ) -> None: ...
	@overload
	def wait(self, arg0: Union[long, JLong], arg1: Union[int, JInt], ) -> None: ...
	@overload
	def wait(self, ) -> None: ...
	def hashCode(self, ) -> Union[int, JInt]: ...
	def notifyAll(self, ) -> None: ...
	def equals(self, arg0: javawrappers.java.lang.Object, ) -> Union[int, JBoolean]: ...
	@overload
	def create(self, arg0: javawrappers.java.lang.Number, arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.javax.measure.Quantity: ...
	@overload
	def create(self, arg0: javawrappers.java.lang.Number, arg1: javawrappers.javax.measure.Unit, ) -> javawrappers.javax.measure.Quantity: ...
	def invoke(self, arg0: javawrappers.java.lang.Object, arg1: javawrappers.java.lang.reflect.Method, arg2: JArray(javawrappers.java.lang.Object, 1), ) -> javawrappers.java.lang.Object: ...
	def toString(self, ) -> javawrappers.java.lang.String: ...
	@staticmethod
	def getInstance(arg0: javawrappers.java.lang.Class, ) -> javawrappers.tec.uom.se.quantity.ProxyQuantityFactory: ...
	@overload
	def getSystemUnit(self, ) -> javawrappers.javax.measure.Unit: ...
	@overload
	def getSystemUnit(self, ) -> javawrappers.javax.measure.Unit: ...
	def notify(self, ) -> None: ...


