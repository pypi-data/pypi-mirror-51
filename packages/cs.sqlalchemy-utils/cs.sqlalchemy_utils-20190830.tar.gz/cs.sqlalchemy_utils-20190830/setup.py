#!/usr/bin/env python
from setuptools import setup
setup(
  name = 'cs.sqlalchemy_utils',
  description = 'Assorted utility functions to support working with SQLAlchemy.',
  author = 'Cameron Simpson',
  author_email = 'cs@cskk.id.au',
  version = '20190830',
  url = 'https://bitbucket.org/cameron_simpson/css/commits/all',
  classifiers = ['Programming Language :: Python', 'Programming Language :: Python :: 2', 'Programming Language :: Python :: 3', 'Topic :: Database', 'Development Status :: 4 - Beta', 'Intended Audience :: Developers', 'Operating System :: OS Independent', 'License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)'],
  include_package_data = True,
  install_requires = ['icontract', 'sqlalchemy', 'cs.deco', 'cs.py.func', 'cs.resources'],
  keywords = ['python2', 'python3'],
  license = 'GNU General Public License v3 or later (GPLv3+)',
  long_description = "*Latest release 20190830*:\n@json_column: small docstring improvement.\n\nAssorted utility functions to support working with SQLAlchemy.\n\n## Function `auto_session(func)`\n\nDecorator to run a function in a session if one is not presupplied.\nThe function `func` runs within a transaction,\nnested if the session already exists.\n\n## Function `find_json_field(column_value, field_name, *, infill=False)`\n\nDescend a JSONable Python object `column_value`\nto `field_name`.\nReturn `column_value` (possibly infilled), `final_field`, `final_field_name`.\n\nThis supports database row columns which are JSON columns.\n\nParameters:\n* `column_value`: the original value of the column\n* `field_name`: the field within the column to locate\n* `infill`: optional keyword parameter, default `False`.\n  If true,\n  `column_value` and its innards will be filled in as `dict`s\n  to allow deferencing the `field_name`.\n\nThe `field_name` is a `str`\nconsisting of a period (`'.'`) separated sequence of field parts.\nEach field part becomes a key to index the column mapping.\nThese keys are split into the leading field parts\nand the final field part,\nwhich is returned as `final_field_name` above.\n\nThe `final_field` return value above\nis the mapping within which `final_field_value` may lie\nand where `final_field_value` may be set.\nNote: it may not be present.\n\nIf a leading key is missing and `infill` is true\nthe corresponding part of the `column_value` is set to an empty dictionary\nin order to allow deferencing the leading key.\nThis includes the case when `column_value` itself is `None`,\nwhich is why the `column_value` is part of the return.\n\nIf a leading key is missing and `infill` is false\nthis function will raise a `KeyError`\nfor the portion of the `field_name` which failed.\n\nExamples:\n\n    >>> find_json_field({'a':{'b':{}}}, 'a.b')\n    ({'a': {'b': {}}}, {'b': {}}, 'b')\n    >>> find_json_field({'a':{}}, 'a.b')\n    ({'a': {}}, {}, 'b')\n    >>> find_json_field({'a':{'b':{}}}, 'a.b.c.d')\n    Traceback (most recent call last):\n        ...\n    KeyError: 'a.b.c'\n    >>> find_json_field({'a':{'b':{}}}, 'a.b.c.d', infill=True)\n    ({'a': {'b': {'c': {}}}}, {}, 'd')\n    >>> find_json_field(None, 'a.b.c.d')\n    Traceback (most recent call last):\n        ...\n    KeyError: 'a'\n    >>> find_json_field(None, 'a.b.c.d', infill=True)\n    ({'a': {'b': {'c': {}}}}, {}, 'd')\n\n## Function `get_json_field(column_value, field_name, *, default=None)`\n\nReturn the value of `field_name` from `column_value`\nor a defaault if the field is not present.\n\nParameters:\n* `column_value`: the original value of the column\n* `field_name`: the field within the column to locate\n* `default`: default value to return if the field is not present,\n  default: `None`\n\nExamples:\n\n    >>> get_json_field({'a': 1}, 'a')\n    1\n    >>> get_json_field({'b': 1}, 'a')\n    >>> get_json_field({'a': {}}, 'a.b')\n    >>> get_json_field({'a': {'b': 2}}, 'a.b')\n    2\n\n## Function `json_column(*da, **dkw)`\n\nClass decorator to declare a virtual column name on a table\nwhere the value resides inside a JSON column of the table.\n\nParameters:\n* `cls`: the class to annotate\n* `attr`: the virtual column name to present as a row attribute\n* `json_field_name`: the field within the JSON column\n  used to store this value,\n  default the same as `attr`\n* `json_column_name`: the name of the associated JSON column,\n  default `'info'`\n* `default`: the default value returned by the getter\n  if the field is not present,\n  default `None`\n\nExample use:\n\n    Base = declarative_base()\n    ...\n    @json_column('virtual_name', 'json.field.name')\n    class TableClass(Base):\n      ...\n\nThis annotates the class with a `.virtual_name` property\nwhich can be accessed or set,\naccessing or modifying the associated JSON column\n(in this instance, the column `info`,\naccessing `info['json']['field']['name']`).\n\n## Function `log_level(*da, **dkw)`\n\nDecorator to run `func` at the specified logging `level`, default `logging.DEBUG`.\n\n## Class `ORM`\n\nMRO: `cs.resources.MultiOpenMixin`  \nA convenience base class for an ORM class.\n\nThis defines a `.Base` attribute which is a new `DeclarativeBase`\nand provides various Session related convenience methods.\nIt is also a `MultiOpenMixin` subclass\nsupporting nested open/close sequences and use as a context manager.\n\nSubclasses must define the following:\n* `.Session`: a factory in their own `__init__`, typically\n  `self.Session=sessionmaker(bind=engine)`\n* `.startup` and `.shutdown` methods to support the `MultiOpenMixin`,\n  even if these just `pass`\n\n## Function `orm_auto_session(method)`\n\nDecorator to run a method in a session derived from `self.orm`\nif a session is not presupplied.\nIntended to assist classes with a `.orm` attribute.\n\n## Function `push_log_level(level)`\n\nTemporarily set the level of the default SQLAlchemy logger to `level`.\nYields the logger.\n\n*NOTE*: this is not MT safe - competing Threads can mix log levels up.\n\n## Function `set_json_field(column_value, field_name, value, *, infill=False)`\n\nSet a new `value` for `field_name` of `column_value`.\nReturn the new `column_value`.\n\nParameters:\n* `column_value`: the original value of the column\n* `field_name`: the field within the column to locate\n* `value`: the value to store as `field_name`\n* `infill`: optional keyword parameter, default `False`.\n  If true,\n  `column_value` and its innards will be filled in as `dict`s\n  to allow deferencing the `field_name`.\n\nAs with `find_json_field`,\na true `infill` may modify `column_value` to provide `field_name`\nwhich is why this function returns the new `column_value`.\n\nExamples:\n\n    >>> set_json_field({'a': 2}, 'a', 3)\n    {'a': 3}\n    >>> set_json_field({'a': 2, 'b': {'c': 5}}, 'b.c', 4)\n    {'a': 2, 'b': {'c': 4}}\n    >>> set_json_field({'a': 2}, 'b.c', 4)\n    Traceback (most recent call last):\n        ...\n    KeyError: 'b'\n    >>> set_json_field({'a': 2}, 'b.c', 4, infill=True)\n    {'a': 2, 'b': {'c': 4}}\n    >>> set_json_field(None, 'b.c', 4, infill=True)\n    {'b': {'c': 4}}\n\n## Function `with_session(func, *a, orm=None, session=None, **kw)`\n\nCall `func(*a,session=session,**kw)`, creating a session if required.\nThe function `func` runs within a transaction,\nnested if the session already exists.\n\nThis is the inner mechanism of `@auto_session` and\n`ORM.auto_session_method`.\n\nParameters:\n* `func`: the function to call\n* `a`: the positional parameters\n* `orm`: optional ORM class with a `.session()` context manager method\n  such as the `ORM` base class supplied by this module.\n* `session`: optional existing ORM session\n\nOne of `orm` or `session` must be not `None`; if `session`\nis `None` then one is made from `orm.session()` and used as\na context manager.\n\nThe `session` is also passed to `func` as\nthe keyword parameter `session` to support nested calls.\n\n\n\n# Release Log\n\n*Release 20190830*:\n@json_column: small docstring improvement.\n\n*Release 20190829*:\nBugfix @json_column setter: mark the column as modified for the ORM.\nNew push_log_level context manager and @log_level decorator to temporarily change the SQLAlchemy logging handler level.\n\n*Release 20190812*:\nMake ORM a MultiOpenMixin.\nget_json_field: use forgotten `default` parameter.\nOther minor changes.\n\n*Release 20190526*:\nSupport for virtual columns mapped to a JSON column interior value:\nNew functions find_json_field, get_json_field, set_json_field.\nNew decorator @json_column for declaritive_base tables.\n\n*Release 20190517*:\nMake ORM._Session private session factory the public ORM.Session factory for external use.\nwith_session: preexisting sessions still trigger a session.begin_nested, removes flush/commit tension elsewhere.\n\n*Release 20190403*:\nRename @ORM.orm_auto_session to @ORM.auto_session.\nNew @orm_auto_session decorator for methods of objects with a .orm attribute.\n\n*Release 20190319.1*:\nInitial release. ORM base class, @auto_session decorator.",
  long_description_content_type = 'text/markdown',
  package_dir = {'': 'lib/python'},
  py_modules = ['cs.sqlalchemy_utils'],
)
