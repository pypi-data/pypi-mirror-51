# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.0
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError('Python 2.7 or later required')

# Import the low-level C/C++ module
if __package__ or '.' in __name__:
    from . import _cbcpy
else:
    import _cbcpy

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if name == "thisown":
        return self.this.own(value)
    if name == "this":
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if not static:
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if name == "thisown":
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class doubleArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, nelements):
        _cbcpy.doubleArray_swiginit(self, _cbcpy.new_doubleArray(nelements))
    __swig_destroy__ = _cbcpy.delete_doubleArray

    def __getitem__(self, index):
        return _cbcpy.doubleArray___getitem__(self, index)

    def __setitem__(self, index, value):
        return _cbcpy.doubleArray___setitem__(self, index, value)

    def cast(self):
        return _cbcpy.doubleArray_cast(self)

    @staticmethod
    def frompointer(t):
        return _cbcpy.doubleArray_frompointer(t)

# Register doubleArray in _cbcpy:
_cbcpy.doubleArray_swigregister(doubleArray)

def doubleArray_frompointer(t):
    return _cbcpy.doubleArray_frompointer(t)

class CbcModel(object):
    r"""
    Simple Branch and bound class

     The initialSolve() method solves the initial LP relaxation of the MIP
     problem. The branchAndBound() method can then be called to finish using
     a branch and cut algorithm.

     ### Search Tree Traversal

     Subproblems (aka nodes) requiring additional evaluation are stored using
     the CbcNode and CbcNodeInfo objects. Ancestry linkage is maintained in the
     CbcNodeInfo object. Evaluation of a subproblem within branchAndBound()
     proceeds as follows:

       *  The node representing the most promising parent subproblem is popped
     from the heap which holds the set of subproblems requiring further
     evaluation.
       *  Using branching instructions stored in the node, and information in
     its ancestors, the model and solver are adjusted to create the
     active subproblem.
       *  If the parent subproblem will require further evaluation
     (*i.e.*, there are branches remaining) its node is pushed back
     on the heap. Otherwise, the node is deleted.  This may trigger
     recursive deletion of ancestors.
       *  The newly created subproblem is evaluated.
       *  If the subproblem requires further evaluation, a node is created.
     All information needed to recreate the subproblem (branching
     information, row and column cuts) is placed in the node and the node
     is added to the set of subproblems awaiting further evaluation.

     Note that there is never a node representing the active subproblem; the model
     and solver represent the active subproblem.

     ### Row (Constraint) Cut Handling

     For a typical subproblem, the sequence of events is as follows:

       *  The subproblem is rebuilt for further evaluation: One result of a
     call to addCuts() is a traversal of ancestors, leaving a list of all
     cuts used in the ancestors in #addedCuts_. This list is then scanned
     to construct a basis that includes only tight cuts. Entries for
     loose cuts are set to NULL.
       *  The subproblem is evaluated: One result of a call to solveWithCuts()
            is the return of a set of newly generated cuts for the subproblem.
     #addedCuts_ is also kept up-to-date as old cuts become loose.
       *  The subproblem is stored for further processing: A call to
     CbcNodeInfo::addCuts() adds the newly generated cuts to the
     CbcNodeInfo object associated with this node.

     See CbcCountRowCut for details of the bookkeeping associated with cut
     management.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    CbcMaxNumNode = _cbcpy.CbcModel_CbcMaxNumNode
    r""" The maximum number of nodes before terminating"""
    CbcMaxNumSol = _cbcpy.CbcModel_CbcMaxNumSol
    r""" The maximum number of solutions before terminating"""
    CbcFathomDiscipline = _cbcpy.CbcModel_CbcFathomDiscipline
    r"""
    Fathoming discipline

             Controls objective function comparisons for purposes of fathoming by bound
             or determining monotonic variables.

             If 1, action is taken only when the current objective is strictly worse
             than the target. Implementation is handled by adding a small tolerance to
             the target.
    """
    CbcPrinting = _cbcpy.CbcModel_CbcPrinting
    r"""
    Adjusts printout
               1 does different node message with number unsatisfied on last branch
    """
    CbcNumberBranches = _cbcpy.CbcModel_CbcNumberBranches
    r"""
    Number of branches (may be more than number of nodes as may
               include strong branching)
    """
    CbcLastIntParam = _cbcpy.CbcModel_CbcLastIntParam
    r""" Just a marker, so that a static sized array can store parameters."""
    CbcIntegerTolerance = _cbcpy.CbcModel_CbcIntegerTolerance
    r"""
    The maximum amount the value of an integer variable can vary from
               integer and still be considered feasible.
    """
    CbcInfeasibilityWeight = _cbcpy.CbcModel_CbcInfeasibilityWeight
    r"""
    The objective is assumed to worsen by this amount for each
               integer infeasibility.
    """
    CbcCutoffIncrement = _cbcpy.CbcModel_CbcCutoffIncrement
    r"""
    The amount by which to tighten the objective function cutoff when
               a new solution is discovered.
    """
    CbcAllowableGap = _cbcpy.CbcModel_CbcAllowableGap
    r"""
    Stop when the gap between the objective value of the best known solution
             and the best bound on the objective of any solution is less than this.

             This is an absolute value. Conversion from a percentage is left to the
             client.
    """
    CbcAllowableFractionGap = _cbcpy.CbcModel_CbcAllowableFractionGap
    r"""
    Stop when the gap between the objective value of the best known solution
             and the best bound on the objective of any solution is less than this
             fraction of of the absolute value of best known solution.

             Code stops if either this test or CbcAllowableGap test succeeds
    """
    CbcMaximumSeconds = _cbcpy.CbcModel_CbcMaximumSeconds
    r"""
    The maximum number of seconds before terminating.
                  A double should be adequate!
    """
    CbcCurrentCutoff = _cbcpy.CbcModel_CbcCurrentCutoff
    r""" Cutoff - stored for speed"""
    CbcOptimizationDirection = _cbcpy.CbcModel_CbcOptimizationDirection
    r""" Optimization direction - stored for speed"""
    CbcCurrentObjectiveValue = _cbcpy.CbcModel_CbcCurrentObjectiveValue
    r""" Current objective value"""
    CbcCurrentMinimizationObjectiveValue = _cbcpy.CbcModel_CbcCurrentMinimizationObjectiveValue
    r""" Current minimization objective value"""
    CbcStartSeconds = _cbcpy.CbcModel_CbcStartSeconds
    r"""
    The time at start of model.
                  So that other pieces of code can access
    """
    CbcHeuristicGap = _cbcpy.CbcModel_CbcHeuristicGap
    r"""
    Stop doing heuristics when the gap between the objective value of the
               best known solution and the best bound on the objective of any solution
               is less than this.

             This is an absolute value. Conversion from a percentage is left to the
             client.
    """
    CbcHeuristicFractionGap = _cbcpy.CbcModel_CbcHeuristicFractionGap
    r"""
    Stop doing heuristics when the gap between the objective value of the
               best known solution and the best bound on the objective of any solution
               is less than this fraction of of the absolute value of best known
               solution.

             Code stops if either this test or CbcAllowableGap test succeeds
    """
    CbcSmallestChange = _cbcpy.CbcModel_CbcSmallestChange
    r""" Smallest non-zero change on a branch"""
    CbcSumChange = _cbcpy.CbcModel_CbcSumChange
    r""" Sum of non-zero changes on a branch"""
    CbcLargestChange = _cbcpy.CbcModel_CbcLargestChange
    r""" Largest non-zero change on a branch"""
    CbcSmallChange = _cbcpy.CbcModel_CbcSmallChange
    r""" Small non-zero change on a branch to be used as guess"""
    CbcLastDblParam = _cbcpy.CbcModel_CbcLastDblParam
    r""" Just a marker, so that a static sized array can store parameters."""

    def initialSolve(self):
        r"""
        Solve the initial LP relaxation

             Invoke the solver's %initialSolve() method.
        """
        return _cbcpy.CbcModel_initialSolve(self)

    def branchAndBound(self, doStatistics=0):
        r"""
        Invoke the branch & cut algorithm

             The method assumes that initialSolve() has been called to solve the
             LP relaxation. It processes the root node, then proceeds to explore the
             branch & cut search tree. The search ends when the tree is exhausted or
             one of several execution limits is reached.
             If doStatistics is 1 summary statistics are printed
             if 2 then also the path to best solution (if found by branching)
             if 3 then also one line per node
        """
        return _cbcpy.CbcModel_branchAndBound(self, doStatistics)

    def preProcess(self):
        r""" Returns CglPreProcess used before branch and bound"""
        return _cbcpy.CbcModel_preProcess(self)

    def setPreProcess(self, preProcess):
        r""" Set CglPreProcess used before branch and bound"""
        return _cbcpy.CbcModel_setPreProcess(self, preProcess)

    def addUpdateInformation(self, data):
        r""" Adds an update information object"""
        return _cbcpy.CbcModel_addUpdateInformation(self, data)

    def doOneNode(self, baseModel, node, newNode):
        r"""
        Do one node - broken out for clarity?
               also for parallel (when baseModel!=this)
               Returns 1 if solution found
               node NULL on return if no branches left
               newNode NULL if no new node created
        """
        return _cbcpy.CbcModel_doOneNode(self, baseModel, node, newNode)

    def makeGlobalCut(self, *args):
        r"""
        *Overload 1:*
        Make given cut into a global cut

        |

        *Overload 2:*
        Make given cut into a global cut

        |

        *Overload 3:*
        Make given column cut into a global cut

        |

        *Overload 4:*
        Make given column cut into a global cut
        """
        return _cbcpy.CbcModel_makeGlobalCut(self, *args)

    def makePartialCut(self, cut, solver=None):
        r""" Make partial cut into a global cut and save"""
        return _cbcpy.CbcModel_makePartialCut(self, cut, solver)

    def makeGlobalCuts(self, *args):
        r"""
        *Overload 1:*
        Make given rows (L or G) into global cuts and remove from lp

        |

        *Overload 2:*
        Make partial cuts into global cuts
        """
        return _cbcpy.CbcModel_makeGlobalCuts(self, *args)

    def whichGenerator(self):
        r""" Which cut generator generated this cut"""
        return _cbcpy.CbcModel_whichGenerator(self)

    def findCliques(self, makeEquality, atLeastThisMany, lessThanThis, defaultValue=1000):
        r"""
        Identify cliques and construct corresponding objects.

               Find cliques with size in the range
               [atLeastThisMany, lessThanThis] and construct corresponding
               CbcClique objects.
               If makeEquality is true then a new model may be returned if
               modifications had to be made, otherwise ``this`` is returned.
               If the problem is infeasible #numberObjects_ is set to -1.
               A client must use deleteObjects() before a second call to findCliques().
               If priorities exist, clique priority is set to the default.
        """
        return _cbcpy.CbcModel_findCliques(self, makeEquality, atLeastThisMany, lessThanThis, defaultValue)

    def integerPresolve(self, weak=False):
        r"""
        Do integer presolve, creating a new (presolved) model.

             Returns the new model, or NULL if feasibility is lost.
             If weak is true then just does a normal presolve

             TODO: It remains to work out the cleanest way of getting a solution to
                   the original problem at the end. So this is very preliminary.
        """
        return _cbcpy.CbcModel_integerPresolve(self, weak)

    def integerPresolveThisModel(self, originalSolver, weak=False):
        r"""
        Do integer presolve, modifying the current model.

               Returns true if the model remains feasible after presolve.
        """
        return _cbcpy.CbcModel_integerPresolveThisModel(self, originalSolver, weak)

    def originalModel(self, presolvedModel, weak):
        r""" Put back information into the original model after integer presolve."""
        return _cbcpy.CbcModel_originalModel(self, presolvedModel, weak)

    def tightenVubs(self, *args):
        r"""
        *Overload 1:*
        For variables involved in VUB constraints, see if we can tighten
                  bounds by solving lp's

               Returns false if feasibility is lost.
               If CglProbing is available, it will be tried as well to see if it can
               tighten bounds.
               This routine is just a front end for tightenVubs(int,const int*,double).

               If type = -1 all variables are processed (could be very slow).
               If type = 0 only variables involved in VUBs are processed.
               If type = n > 0, only the n most expensive VUB variables
               are processed, where it is assumed that x is at its maximum so delta
               would have to go to 1 (if x not at bound).

               If allowMultipleBinary is true, then a VUB constraint is a row with
               one continuous variable and any number of binary variables.

               If useCutoff < 1.0e30, the original objective is installed as a
               constraint with useCutoff as a bound.

        |

        *Overload 2:*
        For variables involved in VUB constraints, see if we can tighten
                  bounds by solving lp's

             This version is just handed a list of variables to be processed.

        |

        *Overload 3:*
        For variables involved in VUB constraints, see if we can tighten
                  bounds by solving lp's

             This version is just handed a list of variables to be processed.
        """
        return _cbcpy.CbcModel_tightenVubs(self, *args)

    def analyzeObjective(self):
        r"""

        Analyze problem to find a minimum change in the objective function.
        """
        return _cbcpy.CbcModel_analyzeObjective(self)

    def postProcessedSolver(self, solutionType=1):
        r"""
        Returns postProcessed solution in solver(called from event handler)
            Normally used for integer solution (not really tested otherwise)
           solutionType 1 is best integer so far, 0 is current solution
           (may not be integer)
        """
        return _cbcpy.CbcModel_postProcessedSolver(self, solutionType)

    def AddIntegers(self):
        r"""

        Add additional integers.
        """
        return _cbcpy.CbcModel_AddIntegers(self)

    def saveModel(self, saveSolver, checkCutoffForRestart, feasible):
        r"""

        Save copy of the model.
        """
        return _cbcpy.CbcModel_saveModel(self, saveSolver, checkCutoffForRestart, feasible)

    def flipModel(self):
        r"""

        Flip direction of optimization on all models
        """
        return _cbcpy.CbcModel_flipModel(self)

    def cleanBounds(self, solver, cleanVariables):
        r"""

        Clean model i.e. make SOS/integer variables exactly at bound if needed.
        Only if moreSpecialOptions2_ 15 bit set (32768) as there is a small
        overhead (more2 in standalone cbc).
        Fine tuning can be done in configure with -DCLEAN_INTEGER_VARIABLES
        and -DZERO_ODD_TOLERANCE=1.0e-nn
        If CLEAN_INTEGER_VARIABLES not defined then cleaning is only done for
        SOS variables.
        If ZERO_ODD_TOLERANCE not defined then 1.0e-14 used.  You can define as
        0.0 if you are paranoid.
        Returns number of variables forced out
        cleanVariables array will be used if exists
        """
        return _cbcpy.CbcModel_cleanBounds(self, solver, cleanVariables)

    def setupCleanVariables(self):
        r""" Sets up cleanVariables array (i.e. ones to be careful about)"""
        return _cbcpy.CbcModel_setupCleanVariables(self)

    def numberObjects(self):
        r""" Get the number of objects"""
        return _cbcpy.CbcModel_numberObjects(self)

    def setNumberObjects(self, number):
        r""" Set the number of objects"""
        return _cbcpy.CbcModel_setNumberObjects(self, number)

    def objects(self):
        r""" Get the array of objects"""
        return _cbcpy.CbcModel_objects(self)

    def object(self, which):
        r""" Get the specified object"""
        return _cbcpy.CbcModel_object(self, which)

    def modifiableObject(self, which):
        r""" Get the specified object"""
        return _cbcpy.CbcModel_modifiableObject(self, which)

    def setOptionalInteger(self, index):
        return _cbcpy.CbcModel_setOptionalInteger(self, index)

    def deleteObjects(self, findIntegers=True):
        r""" Delete all object information (and just back to integers if true)"""
        return _cbcpy.CbcModel_deleteObjects(self, findIntegers)

    def addObjects(self, *args):
        r"""
        *Overload 1:*
        Add in object information.

             Objects are cloned; the owner can delete the originals.

        |

        *Overload 2:*
        Add in object information.

             Objects are cloned; the owner can delete the originals.
        """
        return _cbcpy.CbcModel_addObjects(self, *args)

    def synchronizeModel(self):
        r""" Ensure attached objects point to this model."""
        return _cbcpy.CbcModel_synchronizeModel(self)

    def findIntegers(self, startAgain, type=0):
        r"""
        Identify integer variables and create corresponding objects.

             Record integer variables and create an CbcSimpleInteger object for each
             one.
             If startAgain is true, a new scan is forced, overwriting any existing
             integer variable information.
             If type > 0 then 1==PseudoCost, 2 new ones low priority
        """
        return _cbcpy.CbcModel_findIntegers(self, startAgain, type)

    def addSOSEtcToSolver(self):
        r"""
        Add SOS info to solver -
        Overwrites SOS information in solver with information
        in CbcModel.  Has no effect with some solvers.
        Also updates integer info.
        """
        return _cbcpy.CbcModel_addSOSEtcToSolver(self)

    def setIntParam(self, key, value):
        r""" Set an integer parameter"""
        return _cbcpy.CbcModel_setIntParam(self, key, value)

    def setDblParam(self, key, value):
        r""" Set a double parameter"""
        return _cbcpy.CbcModel_setDblParam(self, key, value)

    def getIntParam(self, key):
        r""" Get an integer parameter"""
        return _cbcpy.CbcModel_getIntParam(self, key)

    def getDblParam(self, key):
        r""" Get a double parameter"""
        return _cbcpy.CbcModel_getDblParam(self, key)

    def setCutoff(self, value):
        r"""
        Set cutoff bound on the objective function.

             When using strict comparison, the bound is adjusted by a tolerance to
             avoid accidentally cutting off the optimal solution.
        """
        return _cbcpy.CbcModel_setCutoff(self, value)

    def getCutoff(self):
        r""" Get the cutoff bound on the objective function - always as minimize"""
        return _cbcpy.CbcModel_getCutoff(self)

    def setMaximumNodes(self, value):
        r""" Set the CbcModel::CbcMaxNumNode maximum node limit"""
        return _cbcpy.CbcModel_setMaximumNodes(self, value)

    def getMaximumNodes(self):
        r""" Get the CbcModel::CbcMaxNumNode maximum node limit"""
        return _cbcpy.CbcModel_getMaximumNodes(self)

    def setMaximumSolutions(self, value):
        r"""
        Set the
               CbcModel::CbcMaxNumSol maximum number of solutions
               desired.
        """
        return _cbcpy.CbcModel_setMaximumSolutions(self, value)

    def getMaximumSolutions(self):
        r"""
        Get the
               CbcModel::CbcMaxNumSol maximum number of solutions
               desired.
        """
        return _cbcpy.CbcModel_getMaximumSolutions(self)

    def setPrintingMode(self, value):
        r""" Set the printing mode"""
        return _cbcpy.CbcModel_setPrintingMode(self, value)

    def getPrintingMode(self):
        r""" Get the printing mode"""
        return _cbcpy.CbcModel_getPrintingMode(self)

    def setMaximumSeconds(self, value):
        r"""
        Set the
               CbcModel::CbcMaximumSeconds maximum number of seconds
               desired.
        """
        return _cbcpy.CbcModel_setMaximumSeconds(self, value)

    def getMaximumSeconds(self):
        r"""
        Get the
               CbcModel::CbcMaximumSeconds maximum number of seconds
               desired.
        """
        return _cbcpy.CbcModel_getMaximumSeconds(self)

    def getCurrentSeconds(self):
        r""" Current time since start of branchAndbound"""
        return _cbcpy.CbcModel_getCurrentSeconds(self)

    def maximumSecondsReached(self):
        r""" Return true if maximum time reached"""
        return _cbcpy.CbcModel_maximumSecondsReached(self)

    def setIntegerTolerance(self, value):
        r"""
        Set the
             CbcModel::CbcIntegerTolerance integrality tolerance
        """
        return _cbcpy.CbcModel_setIntegerTolerance(self, value)

    def getIntegerTolerance(self):
        r"""
        Get the
             CbcModel::CbcIntegerTolerance integrality tolerance
        """
        return _cbcpy.CbcModel_getIntegerTolerance(self)

    def setInfeasibilityWeight(self, value):
        r"""
        Set the
               CbcModel::CbcInfeasibilityWeight
                 weight per integer infeasibility
        """
        return _cbcpy.CbcModel_setInfeasibilityWeight(self, value)

    def getInfeasibilityWeight(self):
        r"""
        Get the
               CbcModel::CbcInfeasibilityWeight
                 weight per integer infeasibility
        """
        return _cbcpy.CbcModel_getInfeasibilityWeight(self)

    def setAllowableGap(self, value):
        r"""
        Set the CbcModel::CbcAllowableGap allowable gap
               between the best known solution and the best possible solution.
        """
        return _cbcpy.CbcModel_setAllowableGap(self, value)

    def getAllowableGap(self):
        r"""
        Get the CbcModel::CbcAllowableGap allowable gap
               between the best known solution and the best possible solution.
        """
        return _cbcpy.CbcModel_getAllowableGap(self)

    def setAllowableFractionGap(self, value):
        r"""
        Set the CbcModel::CbcAllowableFractionGap fraction allowable gap
               between the best known solution and the best possible solution.
        """
        return _cbcpy.CbcModel_setAllowableFractionGap(self, value)

    def getAllowableFractionGap(self):
        r"""
        Get the CbcModel::CbcAllowableFractionGap fraction allowable gap
               between the best known solution and the best possible solution.
        """
        return _cbcpy.CbcModel_getAllowableFractionGap(self)

    def setAllowablePercentageGap(self, value):
        r"""
        Set the CbcModel::CbcAllowableFractionGap percentage allowable gap
               between the best known solution and the best possible solution.
        """
        return _cbcpy.CbcModel_setAllowablePercentageGap(self, value)

    def getAllowablePercentageGap(self):
        r"""
        Get the CbcModel::CbcAllowableFractionGap percentage allowable gap
               between the best known solution and the best possible solution.
        """
        return _cbcpy.CbcModel_getAllowablePercentageGap(self)

    def setHeuristicGap(self, value):
        r"""
        Set the CbcModel::CbcHeuristicGap heuristic gap
               between the best known solution and the best possible solution.
        """
        return _cbcpy.CbcModel_setHeuristicGap(self, value)

    def getHeuristicGap(self):
        r"""
        Get the CbcModel::CbcHeuristicGap heuristic gap
               between the best known solution and the best possible solution.
        """
        return _cbcpy.CbcModel_getHeuristicGap(self)

    def setHeuristicFractionGap(self, value):
        r"""
        Set the CbcModel::CbcHeuristicFractionGap fraction heuristic gap
               between the best known solution and the best possible solution.
        """
        return _cbcpy.CbcModel_setHeuristicFractionGap(self, value)

    def getHeuristicFractionGap(self):
        r"""
        Get the CbcModel::CbcHeuristicFractionGap fraction heuristic gap
               between the best known solution and the best possible solution.
        """
        return _cbcpy.CbcModel_getHeuristicFractionGap(self)

    def setCutoffIncrement(self, value):
        r"""
        Set the
               CbcModel::CbcCutoffIncrement
               desired.
        """
        return _cbcpy.CbcModel_setCutoffIncrement(self, value)

    def getCutoffIncrement(self):
        r"""
        Get the
               CbcModel::CbcCutoffIncrement
               desired.
        """
        return _cbcpy.CbcModel_getCutoffIncrement(self)

    def canStopOnGap(self):
        r""" See if can stop on gap"""
        return _cbcpy.CbcModel_canStopOnGap(self)

    def setHotstartSolution(self, solution, priorities=None):
        r"""
        Pass in target solution and optional priorities.
               If priorities then >0 means only branch if incorrect
               while <0 means branch even if correct. +1 or -1 are
               highest priority
        """
        return _cbcpy.CbcModel_setHotstartSolution(self, solution, priorities)

    def setMinimumDrop(self, value):
        r""" Set the minimum drop to continue cuts"""
        return _cbcpy.CbcModel_setMinimumDrop(self, value)

    def getMinimumDrop(self):
        r""" Get the minimum drop to continue cuts"""
        return _cbcpy.CbcModel_getMinimumDrop(self)

    def setMaximumCutPassesAtRoot(self, value):
        r"""
        Set the maximum number of cut passes at root node (default 20)
               Minimum drop can also be used for fine tuning
        """
        return _cbcpy.CbcModel_setMaximumCutPassesAtRoot(self, value)

    def getMaximumCutPassesAtRoot(self):
        r""" Get the maximum number of cut passes at root node"""
        return _cbcpy.CbcModel_getMaximumCutPassesAtRoot(self)

    def setMaximumCutPasses(self, value):
        r"""
        Set the maximum number of cut passes at other nodes (default 10)
               Minimum drop can also be used for fine tuning
        """
        return _cbcpy.CbcModel_setMaximumCutPasses(self, value)

    def getMaximumCutPasses(self):
        r""" Get the maximum number of cut passes at other nodes (default 10)"""
        return _cbcpy.CbcModel_getMaximumCutPasses(self)

    def getCurrentPassNumber(self):
        r"""
        Get current cut pass number in this round of cuts.
               (1 is first pass)
        """
        return _cbcpy.CbcModel_getCurrentPassNumber(self)

    def setCurrentPassNumber(self, value):
        r"""
        Set current cut pass number in this round of cuts.
               (1 is first pass)
        """
        return _cbcpy.CbcModel_setCurrentPassNumber(self, value)

    def setNumberStrong(self, number):
        r"""
        Set the maximum number of candidates to be evaluated for strong
             branching.

             A value of 0 disables strong branching.
        """
        return _cbcpy.CbcModel_setNumberStrong(self, number)

    def numberStrong(self):
        r"""
        Get the maximum number of candidates to be evaluated for strong
             branching.
        """
        return _cbcpy.CbcModel_numberStrong(self)

    def setPreferredWay(self, value):
        r"""
        Set global preferred way to branch
               -1 down, +1 up, 0 no preference
        """
        return _cbcpy.CbcModel_setPreferredWay(self, value)

    def getPreferredWay(self):
        r""" Get the preferred way to branch (default 0)"""
        return _cbcpy.CbcModel_getPreferredWay(self)

    def whenCuts(self):
        r""" Get at which depths to do cuts"""
        return _cbcpy.CbcModel_whenCuts(self)

    def setWhenCuts(self, value):
        r""" Set at which depths to do cuts"""
        return _cbcpy.CbcModel_setWhenCuts(self, value)

    def doCutsNow(self, allowForTopOfTree):
        r"""
        Return true if we want to do cuts
               If allowForTopOfTree zero then just does on multiples of depth
               if 1 then allows for doing at top of tree
               if 2 then says if cuts allowed anywhere apart from root
        """
        return _cbcpy.CbcModel_doCutsNow(self, allowForTopOfTree)

    def setNumberBeforeTrust(self, number):
        r"""
        Set the number of branches before pseudo costs believed
               in dynamic strong branching.

             A value of 0 disables dynamic strong branching.
        """
        return _cbcpy.CbcModel_setNumberBeforeTrust(self, number)

    def numberBeforeTrust(self):
        r"""
        get the number of branches before pseudo costs believed
               in dynamic strong branching.
        """
        return _cbcpy.CbcModel_numberBeforeTrust(self)

    def setNumberPenalties(self, number):
        r"""
        Set the number of variables for which to compute penalties
               in dynamic strong branching.

             A value of 0 disables penalties.
        """
        return _cbcpy.CbcModel_setNumberPenalties(self, number)

    def numberPenalties(self):
        r"""
        get the number of variables for which to compute penalties
               in dynamic strong branching.
        """
        return _cbcpy.CbcModel_numberPenalties(self)

    def topOfTree(self):
        r""" Pointer to top of tree"""
        return _cbcpy.CbcModel_topOfTree(self)

    def setNumberAnalyzeIterations(self, number):
        r""" Number of analyze iterations to do"""
        return _cbcpy.CbcModel_setNumberAnalyzeIterations(self, number)

    def numberAnalyzeIterations(self):
        return _cbcpy.CbcModel_numberAnalyzeIterations(self)

    def penaltyScaleFactor(self):
        r"""
        Get scale factor to make penalties match strong.
               Should/will be computed
        """
        return _cbcpy.CbcModel_penaltyScaleFactor(self)

    def setPenaltyScaleFactor(self, value):
        r"""
        Set scale factor to make penalties match strong.
               Should/will be computed
        """
        return _cbcpy.CbcModel_setPenaltyScaleFactor(self, value)

    def setProblemType(self, number):
        r"""
        Problem type as set by user or found by analysis.  This will be extended
               0 - not known
               1 - Set partitioning <=
               2 - Set partitioning ==
               3 - Set covering
               4 - all +- 1 or all +1 and odd
        """
        return _cbcpy.CbcModel_setProblemType(self, number)

    def problemType(self):
        return _cbcpy.CbcModel_problemType(self)

    def currentDepth(self):
        r""" Current depth"""
        return _cbcpy.CbcModel_currentDepth(self)

    def setHowOftenGlobalScan(self, number):
        r""" Set how often to scan global cuts"""
        return _cbcpy.CbcModel_setHowOftenGlobalScan(self, number)

    def howOftenGlobalScan(self):
        r""" Get how often to scan global cuts"""
        return _cbcpy.CbcModel_howOftenGlobalScan(self)

    def originalColumns(self):
        r""" Original columns as created by integerPresolve or preprocessing"""
        return _cbcpy.CbcModel_originalColumns(self)

    def setOriginalColumns(self, *args):
        r""" Set original columns as created by preprocessing"""
        return _cbcpy.CbcModel_setOriginalColumns(self, *args)

    def conflictCut(self, solver, localCuts):
        r""" Create conflict cut (well - most of)"""
        return _cbcpy.CbcModel_conflictCut(self, solver, localCuts)

    def setPrintFrequency(self, number):
        r"""
        Set the print frequency.

             Controls the number of nodes evaluated between status prints.
             If number <=0</tt> the print frequency is set to 100 nodes for large
             problems, 1000 for small problems.
             Print frequency has very slight overhead if small.
        """
        return _cbcpy.CbcModel_setPrintFrequency(self, number)

    def printFrequency(self):
        r""" Get the print frequency"""
        return _cbcpy.CbcModel_printFrequency(self)

    def isAbandoned(self):
        r""" Are there a numerical difficulties?"""
        return _cbcpy.CbcModel_isAbandoned(self)

    def isProvenOptimal(self):
        r""" Is optimality proven?"""
        return _cbcpy.CbcModel_isProvenOptimal(self)

    def isProvenInfeasible(self):
        r""" Is  infeasiblity proven (or none better than cutoff)?"""
        return _cbcpy.CbcModel_isProvenInfeasible(self)

    def isContinuousUnbounded(self):
        r""" Was continuous solution unbounded"""
        return _cbcpy.CbcModel_isContinuousUnbounded(self)

    def isProvenDualInfeasible(self):
        r""" Was continuous solution unbounded"""
        return _cbcpy.CbcModel_isProvenDualInfeasible(self)

    def isNodeLimitReached(self):
        r""" Node limit reached?"""
        return _cbcpy.CbcModel_isNodeLimitReached(self)

    def isSecondsLimitReached(self):
        r""" Time limit reached?"""
        return _cbcpy.CbcModel_isSecondsLimitReached(self)

    def isSolutionLimitReached(self):
        r""" Solution limit reached?"""
        return _cbcpy.CbcModel_isSolutionLimitReached(self)

    def getIterationCount(self):
        r""" Get how many iterations it took to solve the problem."""
        return _cbcpy.CbcModel_getIterationCount(self)

    def incrementIterationCount(self, value):
        r""" Increment how many iterations it took to solve the problem."""
        return _cbcpy.CbcModel_incrementIterationCount(self, value)

    def getNodeCount(self):
        r""" Get how many Nodes it took to solve the problem (including those in complete fathoming B&B inside CLP)."""
        return _cbcpy.CbcModel_getNodeCount(self)

    def incrementNodeCount(self, value):
        r""" Increment how many nodes it took to solve the problem."""
        return _cbcpy.CbcModel_incrementNodeCount(self, value)

    def getExtraNodeCount(self):
        r""" Get how many Nodes were enumerated in complete fathoming B&B inside CLP"""
        return _cbcpy.CbcModel_getExtraNodeCount(self)

    def getFathomCount(self):
        r""" Get how many times complete fathoming B&B was done"""
        return _cbcpy.CbcModel_getFathomCount(self)

    def status(self):
        r"""
        Final status of problem
               Some of these can be found out by is...... functions
               -1 before branchAndBound
               0 finished - check isProvenOptimal or isProvenInfeasible to see if solution found
               (or check value of best solution)
               1 stopped - on maxnodes, maxsols, maxtime
               2 difficulties so run was abandoned
               (5 event user programmed event occurred)
        """
        return _cbcpy.CbcModel_status(self)

    def setProblemStatus(self, value):
        return _cbcpy.CbcModel_setProblemStatus(self, value)

    def secondaryStatus(self):
        r"""
        Secondary status of problem
               -1 unset (status_ will also be -1)
               0 search completed with solution
               1 linear relaxation not feasible (or worse than cutoff)
               2 stopped on gap
               3 stopped on nodes
               4 stopped on time
               5 stopped on user event
               6 stopped on solutions
               7 linear relaxation unbounded
               8 stopped on iteration limit
        """
        return _cbcpy.CbcModel_secondaryStatus(self)

    def setSecondaryStatus(self, value):
        return _cbcpy.CbcModel_setSecondaryStatus(self, value)

    def isInitialSolveAbandoned(self):
        r""" Are there numerical difficulties (for initialSolve) ?"""
        return _cbcpy.CbcModel_isInitialSolveAbandoned(self)

    def isInitialSolveProvenOptimal(self):
        r""" Is optimality proven (for initialSolve) ?"""
        return _cbcpy.CbcModel_isInitialSolveProvenOptimal(self)

    def isInitialSolveProvenPrimalInfeasible(self):
        r""" Is primal infeasiblity proven (for initialSolve) ?"""
        return _cbcpy.CbcModel_isInitialSolveProvenPrimalInfeasible(self)

    def isInitialSolveProvenDualInfeasible(self):
        r""" Is dual infeasiblity proven (for initialSolve) ?"""
        return _cbcpy.CbcModel_isInitialSolveProvenDualInfeasible(self)

    def numberRowsAtContinuous(self):
        r""" Number of rows in continuous (root) problem."""
        return _cbcpy.CbcModel_numberRowsAtContinuous(self)

    def getNumCols(self):
        r""" Get number of columns"""
        return _cbcpy.CbcModel_getNumCols(self)

    def getNumRows(self):
        r""" Get number of rows"""
        return _cbcpy.CbcModel_getNumRows(self)

    def getNumElements(self):
        r""" Get number of nonzero elements"""
        return _cbcpy.CbcModel_getNumElements(self)

    def numberIntegers(self):
        r""" Number of integers in problem"""
        return _cbcpy.CbcModel_numberIntegers(self)

    def integerVariable(self):
        return _cbcpy.CbcModel_integerVariable(self)

    def integerType(self, *args):
        r"""
        *Overload 1:*
        Whether or not integer

        |

        *Overload 2:*
        Whether or not integer
        """
        return _cbcpy.CbcModel_integerType(self, *args)

    def getColLower(self):
        r""" Get pointer to array[getNumCols()] of column lower bounds"""
        return _cbcpy.CbcModel_getColLower(self)

    def getColUpper(self):
        r""" Get pointer to array[getNumCols()] of column upper bounds"""
        return _cbcpy.CbcModel_getColUpper(self)

    def getRowSense(self):
        r"""
        Get pointer to array[getNumRows()] of row constraint senses.

               * 'L': <= constraint
               * 'E': =  constraint
               * 'G': >= constraint
               * 'R': ranged constraint
               * 'N': free constraint

        """
        return _cbcpy.CbcModel_getRowSense(self)

    def getRightHandSide(self):
        r"""
        Get pointer to array[getNumRows()] of rows right-hand sides

               *  if rowsense()[i] == 'L' then rhs()[i] == rowupper()[i]
               *  if rowsense()[i] == 'G' then rhs()[i] == rowlower()[i]
               *  if rowsense()[i] == 'R' then rhs()[i] == rowupper()[i]
               *  if rowsense()[i] == 'N' then rhs()[i] == 0.0

        """
        return _cbcpy.CbcModel_getRightHandSide(self)

    def getRowRange(self):
        r"""
        Get pointer to array[getNumRows()] of row ranges.

               *  if rowsense()[i] == 'R' then
               rowrange()[i] == rowupper()[i] - rowlower()[i]
               *  if rowsense()[i] != 'R' then
               rowrange()[i] is 0.0

        """
        return _cbcpy.CbcModel_getRowRange(self)

    def getRowLower(self):
        r""" Get pointer to array[getNumRows()] of row lower bounds"""
        return _cbcpy.CbcModel_getRowLower(self)

    def getRowUpper(self):
        r""" Get pointer to array[getNumRows()] of row upper bounds"""
        return _cbcpy.CbcModel_getRowUpper(self)

    def getObjCoefficients(self):
        r""" Get pointer to array[getNumCols()] of objective function coefficients"""
        return _cbcpy.CbcModel_getObjCoefficients(self)

    def getObjSense(self):
        r""" Get objective function sense (1 for min (default), -1 for max)"""
        return _cbcpy.CbcModel_getObjSense(self)

    def isContinuous(self, colIndex):
        r""" Return true if variable is continuous"""
        return _cbcpy.CbcModel_isContinuous(self, colIndex)

    def isBinary(self, colIndex):
        r""" Return true if variable is binary"""
        return _cbcpy.CbcModel_isBinary(self, colIndex)

    def isInteger(self, colIndex):
        r"""
        Return true if column is integer.
               Note: This function returns true if the the column
               is binary or a general integer.
        """
        return _cbcpy.CbcModel_isInteger(self, colIndex)

    def isIntegerNonBinary(self, colIndex):
        r""" Return true if variable is general integer"""
        return _cbcpy.CbcModel_isIntegerNonBinary(self, colIndex)

    def isFreeBinary(self, colIndex):
        r""" Return true if variable is binary and not fixed at either bound"""
        return _cbcpy.CbcModel_isFreeBinary(self, colIndex)

    def getMatrixByRow(self):
        r""" Get pointer to row-wise copy of matrix"""
        return _cbcpy.CbcModel_getMatrixByRow(self)

    def getMatrixByCol(self):
        r""" Get pointer to column-wise copy of matrix"""
        return _cbcpy.CbcModel_getMatrixByCol(self)

    def getInfinity(self):
        r""" Get solver's value for infinity"""
        return _cbcpy.CbcModel_getInfinity(self)

    def getCbcColLower(self):
        r""" Get pointer to array[getNumCols()] (for speed) of column lower bounds"""
        return _cbcpy.CbcModel_getCbcColLower(self)

    def getCbcColUpper(self):
        r""" Get pointer to array[getNumCols()] (for speed) of column upper bounds"""
        return _cbcpy.CbcModel_getCbcColUpper(self)

    def getCbcRowLower(self):
        r""" Get pointer to array[getNumRows()] (for speed) of row lower bounds"""
        return _cbcpy.CbcModel_getCbcRowLower(self)

    def getCbcRowUpper(self):
        r""" Get pointer to array[getNumRows()] (for speed) of row upper bounds"""
        return _cbcpy.CbcModel_getCbcRowUpper(self)

    def getCbcColSolution(self):
        r""" Get pointer to array[getNumCols()] (for speed) of primal solution vector"""
        return _cbcpy.CbcModel_getCbcColSolution(self)

    def getCbcRowPrice(self):
        r""" Get pointer to array[getNumRows()] (for speed) of dual prices"""
        return _cbcpy.CbcModel_getCbcRowPrice(self)

    def getCbcReducedCost(self):
        r""" Get a pointer to array[getNumCols()] (for speed) of reduced costs"""
        return _cbcpy.CbcModel_getCbcReducedCost(self)

    def getCbcRowActivity(self):
        r""" Get pointer to array[getNumRows()] (for speed) of row activity levels."""
        return _cbcpy.CbcModel_getCbcRowActivity(self)

    def continuousSolution(self):
        r""" Holds solution at continuous (after cuts if branchAndBound called)"""
        return _cbcpy.CbcModel_continuousSolution(self)

    def usedInSolution(self):
        r"""
        Array marked whenever a solution is found if non-zero.
               Code marks if heuristic returns better so heuristic
               need only mark if it wants to on solutions which
               are worse than current
        """
        return _cbcpy.CbcModel_usedInSolution(self)

    def incrementUsed(self, solution):
        r""" Increases usedInSolution for nonzeros"""
        return _cbcpy.CbcModel_incrementUsed(self, solution)

    def setBestObjectiveValue(self, objectiveValue):
        r""" Just update objectiveValue"""
        return _cbcpy.CbcModel_setBestObjectiveValue(self, objectiveValue)

    def dealWithEventHandler(self, event, objValue, solution):
        r""" Deals with event handler and solution"""
        return _cbcpy.CbcModel_dealWithEventHandler(self, event, objValue, solution)

    def checkSolution(self, cutoff, solution, fixVariables, originalObjValue):
        r"""
        Call this to really test if a valid solution can be feasible
               Solution is number columns in size.
               If fixVariables true then bounds of continuous solver updated.
               Returns objective value (worse than cutoff if not feasible)
               Previously computed objective value is now passed in (in case user does not do solve)
        virtual so user can override
        """
        return _cbcpy.CbcModel_checkSolution(self, cutoff, solution, fixVariables, originalObjValue)

    def feasibleSolution(self, numberIntegerInfeasibilities, numberObjectInfeasibilities):
        r"""
        Test the current solution for feasiblility.

             Scan all objects for indications of infeasibility. This is broken down
             into simple integer infeasibility (numberIntegerInfeasibilities)
             and all other reports of infeasibility (numberObjectInfeasibilities).
        """
        return _cbcpy.CbcModel_feasibleSolution(self, numberIntegerInfeasibilities, numberObjectInfeasibilities)

    def currentSolution(self):
        r"""
        Solution to the most recent lp relaxation.

             The solver's solution to the most recent lp relaxation.
        """
        return _cbcpy.CbcModel_currentSolution(self)

    def testSolution(self):
        r"""
        For testing infeasibilities - will point to
               currentSolution_ or solver-->getColSolution()
        """
        return _cbcpy.CbcModel_testSolution(self)

    def setTestSolution(self, solution):
        return _cbcpy.CbcModel_setTestSolution(self, solution)

    def reserveCurrentSolution(self, solution=None):
        r""" Make sure region there and optionally copy solution"""
        return _cbcpy.CbcModel_reserveCurrentSolution(self, solution)

    def getColSolution(self):
        r""" Get pointer to array[getNumCols()] of primal solution vector"""
        return _cbcpy.CbcModel_getColSolution(self)

    def getRowPrice(self):
        r""" Get pointer to array[getNumRows()] of dual prices"""
        return _cbcpy.CbcModel_getRowPrice(self)

    def getReducedCost(self):
        r""" Get a pointer to array[getNumCols()] of reduced costs"""
        return _cbcpy.CbcModel_getReducedCost(self)

    def getRowActivity(self):
        r""" Get pointer to array[getNumRows()] of row activity levels."""
        return _cbcpy.CbcModel_getRowActivity(self)

    def getCurrentObjValue(self):
        r""" Get current objective function value"""
        return _cbcpy.CbcModel_getCurrentObjValue(self)

    def getCurrentMinimizationObjValue(self):
        r""" Get current minimization objective function value"""
        return _cbcpy.CbcModel_getCurrentMinimizationObjValue(self)

    def getMinimizationObjValue(self):
        r""" Get best objective function value as minimization"""
        return _cbcpy.CbcModel_getMinimizationObjValue(self)

    def setMinimizationObjValue(self, value):
        r""" Set best objective function value as minimization"""
        return _cbcpy.CbcModel_setMinimizationObjValue(self, value)

    def getObjValue(self):
        r""" Get best objective function value"""
        return _cbcpy.CbcModel_getObjValue(self)

    def getBestPossibleObjValue(self):
        r"""
        Get best possible objective function value.
               This is better of best possible left on tree
               and best solution found.
               If called from within branch and cut may be optimistic.
        """
        return _cbcpy.CbcModel_getBestPossibleObjValue(self)

    def setObjValue(self, value):
        r""" Set best objective function value"""
        return _cbcpy.CbcModel_setObjValue(self, value)

    def getSolverObjValue(self):
        r""" Get solver objective function value (as minimization)"""
        return _cbcpy.CbcModel_getSolverObjValue(self)

    def bestSolution(self):
        r"""
        The best solution to the integer programming problem.

             The best solution to the integer programming problem found during
             the search. If no solution is found, the method returns null.
        """
        return _cbcpy.CbcModel_bestSolution(self)

    def setBestSolution(self, *args):
        r"""
        *Overload 1:*
        Record a new incumbent solution and update objectiveValue

        |

        *Overload 2:*
        User callable setBestSolution.
               If check false does not check valid
               If true then sees if feasible and warns if objective value
               worse than given (so just set to COIN_DBL_MAX if you don't care).
               If check true then does not save solution if not feasible

        |

        *Overload 3:*
        User callable setBestSolution.
               If check false does not check valid
               If true then sees if feasible and warns if objective value
               worse than given (so just set to COIN_DBL_MAX if you don't care).
               If check true then does not save solution if not feasible
        """
        return _cbcpy.CbcModel_setBestSolution(self, *args)

    def getSolutionCount(self):
        r""" Get number of solutions"""
        return _cbcpy.CbcModel_getSolutionCount(self)

    def setSolutionCount(self, value):
        r""" Set number of solutions (so heuristics will be different)"""
        return _cbcpy.CbcModel_setSolutionCount(self, value)

    def numberSavedSolutions(self):
        r""" Number of saved solutions (including best)"""
        return _cbcpy.CbcModel_numberSavedSolutions(self)

    def maximumSavedSolutions(self):
        r""" Maximum number of extra saved solutions"""
        return _cbcpy.CbcModel_maximumSavedSolutions(self)

    def setMaximumSavedSolutions(self, value):
        r""" Set maximum number of extra saved solutions"""
        return _cbcpy.CbcModel_setMaximumSavedSolutions(self, value)

    def savedSolution(self, which):
        r""" Return a saved solution (0==best) - NULL if off end"""
        return _cbcpy.CbcModel_savedSolution(self, which)

    def savedSolutionObjective(self, which):
        r""" Return a saved solution objective (0==best) - COIN_DBL_MAX if off end"""
        return _cbcpy.CbcModel_savedSolutionObjective(self, which)

    def deleteSavedSolution(self, which):
        r""" Delete a saved solution and move others up"""
        return _cbcpy.CbcModel_deleteSavedSolution(self, which)

    def phase(self):
        r"""
        Current phase (so heuristics etc etc can find out).
               0 - initial solve
               1 - solve with cuts at root
               2 - solve with cuts
               3 - other e.g. strong branching
               4 - trying to validate a solution
               5 - at end of search
        """
        return _cbcpy.CbcModel_phase(self)

    def getNumberHeuristicSolutions(self):
        r""" Get number of heuristic solutions"""
        return _cbcpy.CbcModel_getNumberHeuristicSolutions(self)

    def setNumberHeuristicSolutions(self, value):
        r""" Set number of heuristic solutions"""
        return _cbcpy.CbcModel_setNumberHeuristicSolutions(self, value)

    def setObjSense(self, s):
        r""" Set objective function sense (1 for min (default), -1 for max,)"""
        return _cbcpy.CbcModel_setObjSense(self, s)

    def getContinuousObjective(self):
        r""" Value of objective at continuous"""
        return _cbcpy.CbcModel_getContinuousObjective(self)

    def setContinuousObjective(self, value):
        return _cbcpy.CbcModel_setContinuousObjective(self, value)

    def getContinuousInfeasibilities(self):
        r""" Number of infeasibilities at continuous"""
        return _cbcpy.CbcModel_getContinuousInfeasibilities(self)

    def setContinuousInfeasibilities(self, value):
        return _cbcpy.CbcModel_setContinuousInfeasibilities(self, value)

    def rootObjectiveAfterCuts(self):
        r""" Value of objective after root node cuts added"""
        return _cbcpy.CbcModel_rootObjectiveAfterCuts(self)

    def sumChangeObjective(self):
        r""" Sum of Changes to objective by first solve"""
        return _cbcpy.CbcModel_sumChangeObjective(self)

    def numberGlobalViolations(self):
        r"""
        Number of times global cuts violated.  When global cut pool then this
               should be kept for each cut and type of cut
        """
        return _cbcpy.CbcModel_numberGlobalViolations(self)

    def clearNumberGlobalViolations(self):
        return _cbcpy.CbcModel_clearNumberGlobalViolations(self)

    def resolveAfterTakeOffCuts(self):
        r""" Whether to force a resolve after takeOffCuts"""
        return _cbcpy.CbcModel_resolveAfterTakeOffCuts(self)

    def setResolveAfterTakeOffCuts(self, yesNo):
        return _cbcpy.CbcModel_setResolveAfterTakeOffCuts(self, yesNo)

    def maximumRows(self):
        r""" Maximum number of rows"""
        return _cbcpy.CbcModel_maximumRows(self)

    def workingBasis(self):
        r""" Work basis for temporary use"""
        return _cbcpy.CbcModel_workingBasis(self)

    def getStopNumberIterations(self):
        r""" Get number of "iterations" to stop after"""
        return _cbcpy.CbcModel_getStopNumberIterations(self)

    def setStopNumberIterations(self, value):
        r""" Set number of "iterations" to stop after"""
        return _cbcpy.CbcModel_setStopNumberIterations(self, value)

    def heuristicModel(self):
        r""" A pointer to model from CbcHeuristic"""
        return _cbcpy.CbcModel_heuristicModel(self)

    def setHeuristicModel(self, model):
        r""" Set a pointer to model from CbcHeuristic"""
        return _cbcpy.CbcModel_setHeuristicModel(self, model)

    def nodeComparison(self):
        return _cbcpy.CbcModel_nodeComparison(self)

    def setNodeComparison(self, *args):
        return _cbcpy.CbcModel_setNodeComparison(self, *args)

    def problemFeasibility(self):
        return _cbcpy.CbcModel_problemFeasibility(self)

    def setProblemFeasibility(self, *args):
        return _cbcpy.CbcModel_setProblemFeasibility(self, *args)

    def tree(self):
        r""" Tree method e.g. heap (which may be overridden by inheritance)"""
        return _cbcpy.CbcModel_tree(self)

    def passInTreeHandler(self, tree):
        r""" For modifying tree handling (original is cloned)"""
        return _cbcpy.CbcModel_passInTreeHandler(self, tree)

    def passInSubTreeModel(self, model):
        r"""
        For passing in an CbcModel to do a sub Tree (with derived tree handlers).
               Passed in model must exist for duration of branch and bound
        """
        return _cbcpy.CbcModel_passInSubTreeModel(self, model)

    def subTreeModel(self, solver=None):
        r"""
        For retrieving a copy of subtree model with given OsiSolver.
               If no subtree model will use self (up to user to reset cutoff etc).
               If solver NULL uses current
        """
        return _cbcpy.CbcModel_subTreeModel(self, solver)

    def numberStoppedSubTrees(self):
        r""" Returns number of times any subtree stopped on nodes, time etc"""
        return _cbcpy.CbcModel_numberStoppedSubTrees(self)

    def incrementSubTreeStopped(self):
        r""" Says a sub tree was stopped"""
        return _cbcpy.CbcModel_incrementSubTreeStopped(self)

    def typePresolve(self):
        r"""
        Whether to automatically do presolve before branch and bound (subTrees).
               0 - no
               1 - ordinary presolve
               2 - integer presolve (dodgy)
        """
        return _cbcpy.CbcModel_typePresolve(self)

    def setTypePresolve(self, value):
        return _cbcpy.CbcModel_setTypePresolve(self, value)

    def branchingMethod(self):
        r""" Get the current branching decision method."""
        return _cbcpy.CbcModel_branchingMethod(self)

    def setBranchingMethod(self, *args):
        return _cbcpy.CbcModel_setBranchingMethod(self, *args)

    def cutModifier(self):
        r""" Get the current cut modifier method"""
        return _cbcpy.CbcModel_cutModifier(self)

    def setCutModifier(self, *args):
        return _cbcpy.CbcModel_setCutModifier(self, *args)

    def stateOfSearch(self):
        r"""
        State of search
               0 - no solution
               1 - only heuristic solutions
               2 - branched to a solution
               3 - no solution but many nodes
        """
        return _cbcpy.CbcModel_stateOfSearch(self)

    def setStateOfSearch(self, state):
        return _cbcpy.CbcModel_setStateOfSearch(self, state)

    def searchStrategy(self):
        r""" Strategy worked out - mainly at root node for use by CbcNode"""
        return _cbcpy.CbcModel_searchStrategy(self)

    def setSearchStrategy(self, value):
        r""" Set strategy worked out - mainly at root node for use by CbcNode"""
        return _cbcpy.CbcModel_setSearchStrategy(self, value)

    def strongStrategy(self):
        r""" Stong branching strategy"""
        return _cbcpy.CbcModel_strongStrategy(self)

    def setStrongStrategy(self, value):
        r""" Set strong branching strategy"""
        return _cbcpy.CbcModel_setStrongStrategy(self, value)

    def numberCutGenerators(self):
        r""" Get the number of cut generators"""
        return _cbcpy.CbcModel_numberCutGenerators(self)

    def cutGenerators(self):
        r""" Get the list of cut generators"""
        return _cbcpy.CbcModel_cutGenerators(self)

    def cutGenerator(self, i):
        r"""Get the specified cut generator"""
        return _cbcpy.CbcModel_cutGenerator(self, i)

    def virginCutGenerator(self, i):
        r"""Get the specified cut generator before any changes"""
        return _cbcpy.CbcModel_virginCutGenerator(self, i)

    def addCutGenerator(self, generator, howOften=1, name=None, normal=True, atSolution=False, infeasible=False, howOftenInSub=-100, whatDepth=-1, whatDepthInSub=-1):
        r"""
        Add one generator - up to user to delete generators.
               howoften affects how generator is used. 0 or 1 means always,
               >1 means every that number of nodes.  Negative values have same
               meaning as positive but they may be switched off (-> -100) by code if
               not many cuts generated at continuous.  -99 is just done at root.
               Name is just for printout.
               If depth >0 overrides how often generator is called (if howOften==-1 or >0).
        """
        return _cbcpy.CbcModel_addCutGenerator(self, generator, howOften, name, normal, atSolution, infeasible, howOftenInSub, whatDepth, whatDepthInSub)

    def strategy(self):
        r""" Get the current strategy"""
        return _cbcpy.CbcModel_strategy(self)

    def setStrategy(self, *args):
        r"""
        *Overload 1:*
        Set the strategy. Clones

        |

        *Overload 2:*
        Set the strategy. assigns
        """
        return _cbcpy.CbcModel_setStrategy(self, *args)

    def parentModel(self):
        r""" Get the current parent model"""
        return _cbcpy.CbcModel_parentModel(self)

    def setParentModel(self, parentModel):
        r""" Set the parent model"""
        return _cbcpy.CbcModel_setParentModel(self, parentModel)

    def addHeuristic(self, generator, name=None, before=-1):
        r"""
        Add one heuristic - up to user to delete

             The name is just used for print messages.
        """
        return _cbcpy.CbcModel_addHeuristic(self, generator, name, before)

    def heuristic(self, i):
        r"""Get the specified heuristic"""
        return _cbcpy.CbcModel_heuristic(self, i)

    def numberHeuristics(self):
        r""" Get the number of heuristics"""
        return _cbcpy.CbcModel_numberHeuristics(self)

    def setNumberHeuristics(self, value):
        r""" Set the number of heuristics"""
        return _cbcpy.CbcModel_setNumberHeuristics(self, value)

    def lastHeuristic(self):
        r""" Pointer to heuristic solver which found last solution (or NULL)"""
        return _cbcpy.CbcModel_lastHeuristic(self)

    def setLastHeuristic(self, last):
        r""" set last heuristic which found a solution"""
        return _cbcpy.CbcModel_setLastHeuristic(self, last)

    def passInPriorities(self, priorities, ifNotSimpleIntegers):
        return _cbcpy.CbcModel_passInPriorities(self, priorities, ifNotSimpleIntegers)

    def priority(self, sequence):
        r""" Returns priority level for an object (or 1000 if no priorities exist)"""
        return _cbcpy.CbcModel_priority(self, sequence)

    def passInEventHandler(self, eventHandler):
        r"""
        Set an event handler

             A clone of the handler passed as a parameter is stored in CbcModel.
        """
        return _cbcpy.CbcModel_passInEventHandler(self, eventHandler)

    def getEventHandler(self):
        r""" Retrieve a pointer to the event handler"""
        return _cbcpy.CbcModel_getEventHandler(self)

    def setApplicationData(self, appData):
        r"""
        Set application data.

           This is a pointer that the application can store into and
           retrieve from the solver interface.
           This field is available for the application to optionally
           define and use.
        """
        return _cbcpy.CbcModel_setApplicationData(self, appData)

    def getApplicationData(self):
        r""" Get application data"""
        return _cbcpy.CbcModel_getApplicationData(self)

    def passInSolverCharacteristics(self, solverCharacteristics):
        r"""

        For advanced applications you may wish to modify the behavior of Cbc
        e.g. if the solver is a NLP solver then you may not have an exact
        optimum solution at each step.  Information could be built into
        OsiSolverInterface but this is an alternative so that that interface
        does not have to be changed.  If something similar is useful to
        enough solvers then it could be migrated
        You can also pass in by using solver->setAuxiliaryInfo.
        You should do that if solver is odd - if solver is normal simplex
        then use this.
        NOTE - characteristics are not cloned
        """
        return _cbcpy.CbcModel_passInSolverCharacteristics(self, solverCharacteristics)

    def solverCharacteristics(self):
        r""" Get solver characteristics"""
        return _cbcpy.CbcModel_solverCharacteristics(self)

    def passInMessageHandler(self, handler):
        r""" Pass in Message handler (not deleted at end)"""
        return _cbcpy.CbcModel_passInMessageHandler(self, handler)

    def newLanguage(self, language):
        r""" Set language"""
        return _cbcpy.CbcModel_newLanguage(self, language)

    def setLanguage(self, language):
        return _cbcpy.CbcModel_setLanguage(self, language)

    def messageHandler(self):
        r""" Return handler"""
        return _cbcpy.CbcModel_messageHandler(self)

    def messages(self):
        r""" Return messages"""
        return _cbcpy.CbcModel_messages(self)

    def messagesPointer(self):
        r""" Return pointer to messages"""
        return _cbcpy.CbcModel_messagesPointer(self)

    def setLogLevel(self, value):
        r""" Set log level"""
        return _cbcpy.CbcModel_setLogLevel(self, value)

    def logLevel(self):
        r""" Get log level"""
        return _cbcpy.CbcModel_logLevel(self)

    def setDefaultHandler(self, yesNo):
        r"""
        Set flag to say if handler_ is the default handler.

             The default handler is deleted when the model is deleted. Other
             handlers (supplied by the client) will not be deleted.
        """
        return _cbcpy.CbcModel_setDefaultHandler(self, yesNo)

    def defaultHandler(self):
        r""" Check default handler"""
        return _cbcpy.CbcModel_defaultHandler(self)

    def setSpecialOptions(self, value):
        r"""

               Set special options
               0 bit (1) - check if cuts valid (if on debugger list)
               1 bit (2) - use current basis to check integer solution (rather than all slack)
               2 bit (4) - don't check integer solution (by solving LP)
               3 bit (8) - fast analyze
               4 bit (16) - non-linear model - so no well defined CoinPackedMatrix
               5 bit (32) - keep names
               6 bit (64) - try for dominated columns
               7 bit (128) - SOS type 1 but all declared integer
               8 bit (256) - Set to say solution just found, unset by doing cuts
               9 bit (512) - Try reduced model after 100 nodes
               10 bit (1024) - Switch on some heuristics even if seems unlikely
               11 bit (2048) - Mark as in small branch and bound
               12 bit (4096) - Funny cuts so do slow way (in some places)
               13 bit (8192) - Funny cuts so do slow way (in other places)
               14 bit (16384) - Use Cplex! for fathoming
               15 bit (32768) - Try reduced model after 0 nodes
               16 bit (65536) - Original model had integer bounds
               17 bit (131072) - Perturbation switched off
               18 bit (262144) - donor CbcModel
               19 bit (524288) - recipient CbcModel
               20 bit (1048576) - waiting for sub model to return
        22 bit (4194304) - do not initialize random seed in solver (user has)
        23 bit (8388608) - leave solver_ with cuts
        24 bit (16777216) - just get feasible if no cutoff
        25 bit (33554432) - feasibility pump after root cuts
        26 bit (67108864) - child model but going for complete search
        """
        return _cbcpy.CbcModel_setSpecialOptions(self, value)

    def specialOptions(self):
        r""" Get special options"""
        return _cbcpy.CbcModel_specialOptions(self)

    def setRandomSeed(self, value):
        r""" Set random seed"""
        return _cbcpy.CbcModel_setRandomSeed(self, value)

    def getRandomSeed(self):
        r""" Get random seed"""
        return _cbcpy.CbcModel_getRandomSeed(self)

    def setMultipleRootTries(self, value):
        r""" Set multiple root tries"""
        return _cbcpy.CbcModel_setMultipleRootTries(self, value)

    def getMultipleRootTries(self):
        r""" Get multiple root tries"""
        return _cbcpy.CbcModel_getMultipleRootTries(self)

    def sayEventHappened(self):
        r""" Tell model to stop on event"""
        return _cbcpy.CbcModel_sayEventHappened(self)

    def normalSolver(self):
        r""" Says if normal solver i.e. has well defined CoinPackedMatrix"""
        return _cbcpy.CbcModel_normalSolver(self)

    def waitingForMiniBranchAndBound(self):
        r"""
        Says if model is sitting there waiting for mini branch and bound to finish
        This is because an event handler may only have access to parent model in
        mini branch and bound
        """
        return _cbcpy.CbcModel_waitingForMiniBranchAndBound(self)

    def setMoreSpecialOptions(self, value):
        r"""
        Set more special options
               at present bottom 6 bits used for shadow price mode
               1024 for experimental hotstart
               2048,4096 breaking out of cuts
               8192 slowly increase minimum drop
               16384 gomory
        32768 more heuristics in sub trees
        65536 no cuts in preprocessing
               131072 Time limits elapsed
               18 bit (262144) - Perturb fathom nodes
               19 bit (524288) - No limit on fathom nodes
               20 bit (1048576) - Reduce sum of infeasibilities before cuts
               21 bit (2097152) - Reduce sum of infeasibilities after cuts
        22 bit (4194304) - Conflict analysis
        23 bit (8388608) - Conflict analysis - temporary bit
        24 bit (16777216) - Add cutoff as LP constraint (out)
        25 bit (33554432) - diving/reordering
        26 bit (67108864) - load global cuts from file
        27 bit (134217728) - append binding global cuts to file
        28 bit (268435456) - idiot branching
               29 bit (536870912) - don't make fake objective
        30 bit (1073741824) - Funny SOS or similar - be careful
        """
        return _cbcpy.CbcModel_setMoreSpecialOptions(self, value)

    def moreSpecialOptions(self):
        r""" Get more special options"""
        return _cbcpy.CbcModel_moreSpecialOptions(self)

    def setMoreSpecialOptions2(self, value):
        r"""
        Set more more special options
        0 bit (1) - find switching variables
        1 bit (2) - using fake objective until solution
        2 bit (4) - switching variables exist
        3 bit (8) - skip most of setBestSolution checks
        4 bit (16) - very lightweight preprocessing in smallB&B
        5 bit (32) - event handler needs to be cloned when parallel
        6 bit (64) - testing - use probing to make cliques
        7/8 bit (128) - try orbital branching (if nauty)
        9 bit (512) - branching on objective (later)
        10 bit (1024) - branching on constraints (later)
        11/12 bit 2048 - intermittent cuts
        13/14 bit 8192 - go to bitter end in strong branching (first time)
        15 bit 32768 - take care of very very small values for Integer/SOS variables
        """
        return _cbcpy.CbcModel_setMoreSpecialOptions2(self, value)

    def moreSpecialOptions2(self):
        r""" Get more special options2"""
        return _cbcpy.CbcModel_moreSpecialOptions2(self)

    def setCutoffAsConstraint(self, yesNo):
        r""" Set cutoff as constraint"""
        return _cbcpy.CbcModel_setCutoffAsConstraint(self, yesNo)

    def setUseElapsedTime(self, yesNo):
        r""" Set time method"""
        return _cbcpy.CbcModel_setUseElapsedTime(self, yesNo)

    def useElapsedTime(self):
        r""" Get time method"""
        return _cbcpy.CbcModel_useElapsedTime(self)

    def temporaryPointer(self):
        r""" Get useful temporary pointer"""
        return _cbcpy.CbcModel_temporaryPointer(self)

    def setTemporaryPointer(self, pointer):
        r""" Set useful temporary pointer"""
        return _cbcpy.CbcModel_setTemporaryPointer(self, pointer)

    def goToDantzig(self, numberNodes, savePivotMethod):
        r""" Go to dantzig pivot selection if easy problem (clp only)"""
        return _cbcpy.CbcModel_goToDantzig(self, numberNodes, savePivotMethod)

    def ownObjects(self):
        r""" Now we may not own objects - just point to solver's objects"""
        return _cbcpy.CbcModel_ownObjects(self)

    def checkModel(self):
        r""" Check original model before it gets messed up"""
        return _cbcpy.CbcModel_checkModel(self)

    def assignSolver(self, solver, deleteSolver=True):
        r"""
        Assign a solver to the model (model assumes ownership)

             On return, solver will be NULL.
             If deleteSolver then current solver deleted (if model owned)

             Notes: Parameter settings in the outgoing solver are not inherited by
               the incoming solver.
        """
        return _cbcpy.CbcModel_assignSolver(self, solver, deleteSolver)

    def setModelOwnsSolver(self, ourSolver):
        r"""
        Set ownership of solver

             A parameter of false tells CbcModel it does not own the solver and
             should not delete it. Once you claim ownership of the solver, you're
             responsible for eventually deleting it. Note that CbcModel clones
             solvers with abandon.  Unless you have a deep understanding of the
             workings of CbcModel, the only time you want to claim ownership is when
             you're about to delete the CbcModel object but want the solver to
             continue to exist (as, for example, when branchAndBound has finished
             and you want to hang on to the answer).
        """
        return _cbcpy.CbcModel_setModelOwnsSolver(self, ourSolver)

    def modelOwnsSolver(self):
        r"""
        Get ownership of solver

             A return value of true means that CbcModel owns the solver and will
             take responsibility for deleting it when that becomes necessary.
        """
        return _cbcpy.CbcModel_modelOwnsSolver(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default Constructor

        |

        *Overload 2:*
        Constructor from solver

        |

        *Overload 3:*
        Copy constructor .
             If cloneHandler is true then message handler is cloned

        |

        *Overload 4:*
        Copy constructor .
             If cloneHandler is true then message handler is cloned
        """
        _cbcpy.CbcModel_swiginit(self, _cbcpy.new_CbcModel(*args))

    def clone(self, cloneHandler):
        r""" Clone"""
        return _cbcpy.CbcModel_clone(self, cloneHandler)
    __swig_destroy__ = _cbcpy.delete_CbcModel

    def solver(self):
        r""" Returns solver - has current state"""
        return _cbcpy.CbcModel_solver(self)

    def swapSolver(self, solver):
        r""" Returns current solver - sets new one"""
        return _cbcpy.CbcModel_swapSolver(self, solver)

    def continuousSolver(self):
        r""" Returns solver with continuous state"""
        return _cbcpy.CbcModel_continuousSolver(self)

    def createContinuousSolver(self):
        r""" Create solver with continuous state"""
        return _cbcpy.CbcModel_createContinuousSolver(self)

    def clearContinuousSolver(self):
        r""" Clear solver with continuous state"""
        return _cbcpy.CbcModel_clearContinuousSolver(self)

    def referenceSolver(self):
        r""" A copy of the solver, taken at constructor or by saveReferenceSolver"""
        return _cbcpy.CbcModel_referenceSolver(self)

    def saveReferenceSolver(self):
        r""" Save a copy of the current solver so can be reset to"""
        return _cbcpy.CbcModel_saveReferenceSolver(self)

    def resetToReferenceSolver(self):
        r"""
        Uses a copy of reference solver to be current solver.
               Because of possible mismatches all exotic integer information is loat
               (apart from normal information in OsiSolverInterface)
               so SOS etc and priorities will have to be redone
        """
        return _cbcpy.CbcModel_resetToReferenceSolver(self)

    def gutsOfDestructor(self):
        r""" Clears out as much as possible (except solver)"""
        return _cbcpy.CbcModel_gutsOfDestructor(self)

    def gutsOfDestructor2(self):
        r""" Clears out enough to reset CbcModel as if no branch and bound done"""
        return _cbcpy.CbcModel_gutsOfDestructor2(self)

    def resetModel(self):
        r""" Clears out enough to reset CbcModel cutoff etc"""
        return _cbcpy.CbcModel_resetModel(self)

    def gutsOfCopy(self, rhs, mode=0):
        r"""
        Most of copy constructor
               mode - 0 copy but don't delete before
                      1 copy and delete before
                  2 copy and delete before (but use virgin generators)
        """
        return _cbcpy.CbcModel_gutsOfCopy(self, rhs, mode)

    def moveInfo(self, rhs):
        r""" Move status, nodes etc etc across"""
        return _cbcpy.CbcModel_moveInfo(self, rhs)

    @staticmethod
    def haveMultiThreadSupport():
        r""" Indicates whether Cbc library has been compiled with multithreading support"""
        return _cbcpy.CbcModel_haveMultiThreadSupport()

    def masterThread(self):
        r""" Get pointer to masterthread"""
        return _cbcpy.CbcModel_masterThread(self)

    def walkback(self):
        r""" Get pointer to walkback"""
        return _cbcpy.CbcModel_walkback(self)

    def getNumberThreads(self):
        r""" Get number of threads"""
        return _cbcpy.CbcModel_getNumberThreads(self)

    def setNumberThreads(self, value):
        r""" Set number of threads"""
        return _cbcpy.CbcModel_setNumberThreads(self, value)

    def getThreadMode(self):
        r""" Get thread mode"""
        return _cbcpy.CbcModel_getThreadMode(self)

    def setThreadMode(self, value):
        r"""
        Set thread mode
               always use numberThreads for branching
               1 set then deterministic
               2 set then use numberThreads for root cuts
               4 set then use numberThreads in root mini branch and bound
               8 set and numberThreads - do heuristics numberThreads at a time
               8 set and numberThreads==0 do all heuristics at once
               default is 0
        """
        return _cbcpy.CbcModel_setThreadMode(self, value)

    def parallelMode(self):
        r"""
        Return
               -2 if deterministic threaded and main thread
               -1 if deterministic threaded and serial thread
               0 if serial
               1 if opportunistic threaded
        """
        return _cbcpy.CbcModel_parallelMode(self)

    def master(self):
        r""" Thread stuff for master"""
        return _cbcpy.CbcModel_master(self)

    def getNodeCount2(self):
        r""" Get how many Nodes it took to solve the problem."""
        return _cbcpy.CbcModel_getNodeCount2(self)

    def setPointers(self, solver):
        r""" Set pointers for speed"""
        return _cbcpy.CbcModel_setPointers(self, solver)

    def reducedCostFix(self):
        r"""
        Perform reduced cost fixing

             Fixes integer variables at their current value based on reduced cost
             penalties.  Returns number fixed
        """
        return _cbcpy.CbcModel_reducedCostFix(self)

    def synchronizeHandlers(self, makeDefault):
        r"""
        Makes all handlers same.  If makeDefault 1 then makes top level
               default and rest point to that.  If 2 then each is copy
        """
        return _cbcpy.CbcModel_synchronizeHandlers(self, makeDefault)

    def saveExtraSolution(self, solution, objectiveValue):
        r""" Save a solution to saved list"""
        return _cbcpy.CbcModel_saveExtraSolution(self, solution, objectiveValue)

    def saveBestSolution(self, solution, objectiveValue):
        r""" Save a solution to best and move current to saved"""
        return _cbcpy.CbcModel_saveBestSolution(self, solution, objectiveValue)

    def deleteSolutions(self):
        r""" Delete best and saved solutions"""
        return _cbcpy.CbcModel_deleteSolutions(self)

    def resolve(self, *args):
        r"""
        *Overload 1:*
        Reoptimise an LP relaxation

             Invoke the solver's %resolve() method.
             whereFrom -
             0 - initial continuous
             1 - resolve on branch (before new cuts)
             2 - after new cuts
             3  - obsolete code or something modified problem in unexpected way
             10 - after strong branching has fixed variables at root
             11 - after strong branching has fixed variables in tree

             returns 1 feasible, 0 infeasible, -1 feasible but skip cuts

        |

        *Overload 2:*
        Encapsulates solver resolve
        """
        return _cbcpy.CbcModel_resolve(self, *args)

    def chooseBranch(self, newNode, numberPassesLeft, oldNode, cuts, resolved, lastws, lowerBefore, upperBefore, branches):
        r"""
        Encapsulates choosing a variable -
               anyAction -2, infeasible (-1 round again), 0 done
        """
        return _cbcpy.CbcModel_chooseBranch(self, newNode, numberPassesLeft, oldNode, cuts, resolved, lastws, lowerBefore, upperBefore, branches)

    def getEmptyBasis(self, ns=0, na=0):
        r"""
        Return an empty basis object of the specified size

             A useful utility when constructing a basis for a subproblem from scratch.
             The object returned will be of the requested capacity and appropriate for
             the solver attached to the model.
        """
        return _cbcpy.CbcModel_getEmptyBasis(self, ns, na)

    def takeOffCuts(self, cuts, allowResolve, saveCuts, numberNewCuts=0, newCuts=None):
        r"""
        Remove inactive cuts from the model

             An OsiSolverInterface is expected to maintain a valid basis, but not a
             valid solution, when loose cuts are deleted. Restoring a valid solution
             requires calling the solver to reoptimise. If it's certain the solution
             will not be required, set allowResolve to false to suppress
             reoptimisation.
             If saveCuts then slack cuts will be saved
             On input current cuts are cuts and newCuts
             on exit current cuts will be correct.  Returns number dropped
        """
        return _cbcpy.CbcModel_takeOffCuts(self, cuts, allowResolve, saveCuts, numberNewCuts, newCuts)

    def addCuts(self, node, lastws):
        r"""
        Determine and install the active cuts that need to be added for
             the current subproblem

             The whole truth is a bit more complicated. The first action is a call to
             addCuts1(). addCuts() then sorts through the list, installs the tight
             cuts in the model, and does bookkeeping (adjusts reference counts).
             The basis returned from addCuts1() is adjusted accordingly.

             If it turns out that the node should really be fathomed by bound,
             addCuts() simply treats all the cuts as loose as it does the bookkeeping.

        """
        return _cbcpy.CbcModel_addCuts(self, node, lastws)

    def addCuts1(self, node, lastws):
        r"""
        Traverse the tree from node to root and prep the model

             addCuts1() begins the job of prepping the model to match the current
             subproblem. The model is stripped of all cuts, and the search tree is
             traversed from node to root to determine the changes required. Appropriate
             bounds changes are installed, a list of cuts is collected but not
             installed, and an appropriate basis (minus the cuts, but big enough to
             accommodate them) is constructed.

             Returns true if new problem similar to old

             TODO: addCuts1() is called in contexts where it's known in advance that
               all that's desired is to determine a list of cuts and do the
               bookkeeping (adjust the reference counts). The work of installing
               bounds and building a basis goes to waste.
        """
        return _cbcpy.CbcModel_addCuts1(self, node, lastws)

    def previousBounds(self, node, where, iColumn, lower, upper, force):
        r"""
        Returns bounds just before where - initially original bounds.
               Also sets downstream nodes (lower if force 1, upper if 2)
        """
        return _cbcpy.CbcModel_previousBounds(self, node, where, iColumn, lower, upper, force)

    def setObjectiveValue(self, thisNode, parentNode):
        r"""
        Set objective value in a node.  This is separated out so that
              odd solvers can use.  It may look at extra information in
              solverCharacteriscs_ and will also use bound from parent node
        """
        return _cbcpy.CbcModel_setObjectiveValue(self, thisNode, parentNode)

    def convertToDynamic(self):
        r"""
        If numberBeforeTrust >0 then we are going to use CbcBranchDynamic.
               Scan and convert CbcSimpleInteger objects
        """
        return _cbcpy.CbcModel_convertToDynamic(self)

    def synchronizeNumberBeforeTrust(self, type=0):
        r""" Set numberBeforeTrust in all objects"""
        return _cbcpy.CbcModel_synchronizeNumberBeforeTrust(self, type)

    def zapIntegerInformation(self, leaveObjects=True):
        r""" Zap integer information in problem (may leave object info)"""
        return _cbcpy.CbcModel_zapIntegerInformation(self, leaveObjects)

    def pseudoShadow(self, type):
        r""" Fill in useful estimates"""
        return _cbcpy.CbcModel_pseudoShadow(self, type)

    def fillPseudoCosts(self, downCosts, upCosts, priority=None, numberDown=None, numberUp=None, numberDownInfeasible=None, numberUpInfeasible=None):
        r"""
        Return pseudo costs
               If not all integers or not pseudo costs - returns all zero
               Length of arrays are numberIntegers() and entries
               correspond to integerVariable()[i]
               User must allocate arrays before call
        """
        return _cbcpy.CbcModel_fillPseudoCosts(self, downCosts, upCosts, priority, numberDown, numberUp, numberDownInfeasible, numberUpInfeasible)

    def doHeuristicsAtRoot(self, deleteHeuristicsAfterwards=0):
        r"""
        Do heuristics at root.
               0 - don't delete
               1 - delete
               2 - just delete - don't even use
        """
        return _cbcpy.CbcModel_doHeuristicsAtRoot(self, deleteHeuristicsAfterwards)

    def adjustHeuristics(self):
        r""" Adjust heuristics based on model"""
        return _cbcpy.CbcModel_adjustHeuristics(self)

    def hotstartSolution(self):
        r""" Get the hotstart solution"""
        return _cbcpy.CbcModel_hotstartSolution(self)

    def hotstartPriorities(self):
        r""" Get the hotstart priorities"""
        return _cbcpy.CbcModel_hotstartPriorities(self)

    def addedCuts(self):
        r""" Return the list of cuts initially collected for this subproblem"""
        return _cbcpy.CbcModel_addedCuts(self)

    def currentNumberCuts(self):
        r""" Number of entries in the list returned by #addedCuts()"""
        return _cbcpy.CbcModel_currentNumberCuts(self)

    def globalCuts(self):
        r""" Global cuts"""
        return _cbcpy.CbcModel_globalCuts(self)

    def zapGlobalCuts(self):
        r""" Get rid of global cuts"""
        return _cbcpy.CbcModel_zapGlobalCuts(self)

    def setNextRowCut(self, cut):
        r""" Copy and set a pointer to a row cut which will be added instead of normal branching."""
        return _cbcpy.CbcModel_setNextRowCut(self, cut)

    def currentNode(self):
        r""" Get a pointer to current node (be careful)"""
        return _cbcpy.CbcModel_currentNode(self)

    def deleteNode(self, node):
        r""" Delete a node and possibly null out currentNode_"""
        return _cbcpy.CbcModel_deleteNode(self, node)

    def probingInfo(self):
        r""" Get a pointer to probing info"""
        return _cbcpy.CbcModel_probingInfo(self)

    def randomNumberGenerator(self):
        r""" Thread specific random number generator"""
        return _cbcpy.CbcModel_randomNumberGenerator(self)

    def setNumberStrongIterations(self, number):
        r""" Set the number of iterations done in strong branching."""
        return _cbcpy.CbcModel_setNumberStrongIterations(self, number)

    def numberStrongIterations(self):
        r""" Get the number of iterations done in strong branching."""
        return _cbcpy.CbcModel_numberStrongIterations(self)

    def maximumNumberIterations(self):
        r""" Get maximum number of iterations (designed to be used in heuristics)"""
        return _cbcpy.CbcModel_maximumNumberIterations(self)

    def setMaximumNumberIterations(self, value):
        r""" Set maximum number of iterations (designed to be used in heuristics)"""
        return _cbcpy.CbcModel_setMaximumNumberIterations(self, value)

    def setFastNodeDepth(self, value):
        r""" Set depth for fast nodes"""
        return _cbcpy.CbcModel_setFastNodeDepth(self, value)

    def fastNodeDepth(self):
        r""" Get depth for fast nodes"""
        return _cbcpy.CbcModel_fastNodeDepth(self)

    def continuousPriority(self):
        r""" Get anything with priority >= this can be treated as continuous"""
        return _cbcpy.CbcModel_continuousPriority(self)

    def setContinuousPriority(self, value):
        r""" Set anything with priority >= this can be treated as continuous"""
        return _cbcpy.CbcModel_setContinuousPriority(self, value)

    def incrementExtra(self, nodes, iterations, fathoms=1):
        return _cbcpy.CbcModel_incrementExtra(self, nodes, iterations, fathoms)

    def zeroExtra(self):
        r""" Zero extra"""
        return _cbcpy.CbcModel_zeroExtra(self)

    def numberExtraIterations(self):
        r""" Number of extra iterations"""
        return _cbcpy.CbcModel_numberExtraIterations(self)

    def incrementStrongInfo(self, numberTimes, numberIterations, numberFixed, ifInfeasible):
        r""" Increment strong info"""
        return _cbcpy.CbcModel_incrementStrongInfo(self, numberTimes, numberIterations, numberFixed, ifInfeasible)

    def strongInfo(self):
        r""" Return strong info"""
        return _cbcpy.CbcModel_strongInfo(self)

    def mutableStrongInfo(self):
        r""" Return mutable strong info"""
        return _cbcpy.CbcModel_mutableStrongInfo(self)

    def storedRowCuts(self):
        r""" Get stored row cuts for donor/recipient CbcModel"""
        return _cbcpy.CbcModel_storedRowCuts(self)

    def setStoredRowCuts(self, cuts):
        r""" Set stored row cuts for donor/recipient CbcModel"""
        return _cbcpy.CbcModel_setStoredRowCuts(self, cuts)

    def allDynamic(self):
        r""" Says whether all dynamic integers"""
        return _cbcpy.CbcModel_allDynamic(self)

    def generateCpp(self, fp, options):
        r""" Create C++ lines to get to current state"""
        return _cbcpy.CbcModel_generateCpp(self, fp, options)

    def usefulInformation(self):
        r""" Generate an OsiBranchingInformation object"""
        return _cbcpy.CbcModel_usefulInformation(self)

    def setBestSolutionBasis(self, bestSolutionBasis):
        r"""
        Warm start object produced by heuristic or strong branching

               If get a valid integer solution outside branch and bound then it can take
               a reasonable time to solve LP which produces clean solution.  If this object has
               any size then it will be used in solve.
        """
        return _cbcpy.CbcModel_setBestSolutionBasis(self, bestSolutionBasis)

    def redoWalkBack(self):
        r""" Redo walkback arrays"""
        return _cbcpy.CbcModel_redoWalkBack(self)

    def setKeepNamesPreproc(self, _keep):
        r""" if original column names will be preserved in preprocessed problem"""
        return _cbcpy.CbcModel_setKeepNamesPreproc(self, _keep)

    def getKeepNamesPreproc(self):
        return _cbcpy.CbcModel_getKeepNamesPreproc(self)

    def setMIPStart(self, *args):
        r"""
         may be safer to use this overload method: c++ string libraries
        implementation may not be binary compatible
        """
        return _cbcpy.CbcModel_setMIPStart(self, *args)

    def getMIPStart(self):
        return _cbcpy.CbcModel_getMIPStart(self)

# Register CbcModel in _cbcpy:
_cbcpy.CbcModel_swigregister(CbcModel)

def CbcModel_haveMultiThreadSupport():
    r""" Indicates whether Cbc library has been compiled with multithreading support"""
    return _cbcpy.CbcModel_haveMultiThreadSupport()


def getIntegerInformation(object, originalLower, originalUpper):
    r""" So we can use osiObject or CbcObject during transition"""
    return _cbcpy.getIntegerInformation(object, originalLower, originalUpper)

def CbcMain(argc, argv, babSolver):
    return _cbcpy.CbcMain(argc, argv, babSolver)

def CbcMain0(babSolver):
    return _cbcpy.CbcMain0(babSolver)

def callCbc(*args):
    return _cbcpy.callCbc(*args)

def callCbc1(input2, babSolver, arg3):
    return _cbcpy.callCbc1(input2, babSolver, arg3)

def CbcMain1(*args):
    return _cbcpy.CbcMain1(*args)

def setCutAndHeuristicOptions(model):
    return _cbcpy.setCutAndHeuristicOptions(model)
class CbcStrategy(object):
    r""" Strategy base class"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _cbcpy.delete_CbcStrategy

    def clone(self):
        r""" Clone"""
        return _cbcpy.CbcStrategy_clone(self)

    def setupCutGenerators(self, model):
        r""" Setup cut generators"""
        return _cbcpy.CbcStrategy_setupCutGenerators(self, model)

    def setupHeuristics(self, model):
        r""" Setup heuristics"""
        return _cbcpy.CbcStrategy_setupHeuristics(self, model)

    def setupPrinting(self, model, modelLogLevel):
        r""" Do printing stuff"""
        return _cbcpy.CbcStrategy_setupPrinting(self, model, modelLogLevel)

    def setupOther(self, model):
        r""" Other stuff e.g. strong branching and preprocessing"""
        return _cbcpy.CbcStrategy_setupOther(self, model)

    def setNested(self, depth):
        r""" Set model depth (i.e. how nested)"""
        return _cbcpy.CbcStrategy_setNested(self, depth)

    def getNested(self):
        r""" Get model depth (i.e. how nested)"""
        return _cbcpy.CbcStrategy_getNested(self)

    def setPreProcessState(self, state):
        r""" Say preProcessing done"""
        return _cbcpy.CbcStrategy_setPreProcessState(self, state)

    def preProcessState(self):
        r""" See what sort of preprocessing was done"""
        return _cbcpy.CbcStrategy_preProcessState(self)

    def process(self):
        r""" Pre-processing object"""
        return _cbcpy.CbcStrategy_process(self)

    def deletePreProcess(self):
        r""" Delete pre-processing object to save memory"""
        return _cbcpy.CbcStrategy_deletePreProcess(self)

    def fullNodeInfo(self, model, numberRowsAtContinuous):
        r""" Return a new Full node information pointer (descendant of CbcFullNodeInfo)"""
        return _cbcpy.CbcStrategy_fullNodeInfo(self, model, numberRowsAtContinuous)

    def partialNodeInfo(self, model, parent, owner, numberChangedBounds, variables, boundChanges, basisDiff):
        r""" Return a new Partial node information pointer (descendant of CbcPartialNodeInfo)"""
        return _cbcpy.CbcStrategy_partialNodeInfo(self, model, parent, owner, numberChangedBounds, variables, boundChanges, basisDiff)

    def generateCpp(self, arg2):
        r""" Create C++ lines to get to current state"""
        return _cbcpy.CbcStrategy_generateCpp(self, arg2)

    def status(self, model, parent, whereFrom):
        r"""
        After a CbcModel::resolve this can return a status
               -1 no effect
               0 treat as optimal
               1 as 0 but do not do any more resolves (i.e. no more cuts)
               2 treat as infeasible
        """
        return _cbcpy.CbcStrategy_status(self, model, parent, whereFrom)

# Register CbcStrategy in _cbcpy:
_cbcpy.CbcStrategy_swigregister(CbcStrategy)

class CbcStrategyNull(CbcStrategy):
    r""" Null class"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _cbcpy.CbcStrategyNull_swiginit(self, _cbcpy.new_CbcStrategyNull(*args))
    __swig_destroy__ = _cbcpy.delete_CbcStrategyNull

    def clone(self):
        r""" Clone"""
        return _cbcpy.CbcStrategyNull_clone(self)

    def setupCutGenerators(self, arg2):
        r""" Setup cut generators"""
        return _cbcpy.CbcStrategyNull_setupCutGenerators(self, arg2)

    def setupHeuristics(self, arg2):
        r""" Setup heuristics"""
        return _cbcpy.CbcStrategyNull_setupHeuristics(self, arg2)

    def setupPrinting(self, arg2, arg3):
        r""" Do printing stuff"""
        return _cbcpy.CbcStrategyNull_setupPrinting(self, arg2, arg3)

    def setupOther(self, arg2):
        r""" Other stuff e.g. strong branching"""
        return _cbcpy.CbcStrategyNull_setupOther(self, arg2)

# Register CbcStrategyNull in _cbcpy:
_cbcpy.CbcStrategyNull_swigregister(CbcStrategyNull)

class CbcStrategyDefault(CbcStrategy):
    r""" Default class"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _cbcpy.CbcStrategyDefault_swiginit(self, _cbcpy.new_CbcStrategyDefault(*args))
    __swig_destroy__ = _cbcpy.delete_CbcStrategyDefault

    def clone(self):
        r""" Clone"""
        return _cbcpy.CbcStrategyDefault_clone(self)

    def setupCutGenerators(self, model):
        r""" Setup cut generators"""
        return _cbcpy.CbcStrategyDefault_setupCutGenerators(self, model)

    def setupHeuristics(self, model):
        r""" Setup heuristics"""
        return _cbcpy.CbcStrategyDefault_setupHeuristics(self, model)

    def setupPrinting(self, model, modelLogLevel):
        r""" Do printing stuff"""
        return _cbcpy.CbcStrategyDefault_setupPrinting(self, model, modelLogLevel)

    def setupOther(self, model):
        r""" Other stuff e.g. strong branching"""
        return _cbcpy.CbcStrategyDefault_setupOther(self, model)

    def setupPreProcessing(self, desired=1, passes=10):
        r""" Set up preProcessing - see below"""
        return _cbcpy.CbcStrategyDefault_setupPreProcessing(self, desired, passes)

    def desiredPreProcess(self):
        r""" See what sort of preprocessing wanted"""
        return _cbcpy.CbcStrategyDefault_desiredPreProcess(self)

    def preProcessPasses(self):
        r""" See how many passes wanted"""
        return _cbcpy.CbcStrategyDefault_preProcessPasses(self)

    def generateCpp(self, fp):
        r""" Create C++ lines to get to current state"""
        return _cbcpy.CbcStrategyDefault_generateCpp(self, fp)

# Register CbcStrategyDefault in _cbcpy:
_cbcpy.CbcStrategyDefault_swigregister(CbcStrategyDefault)

class CbcStrategyDefaultSubTree(CbcStrategy):
    r""" Default class for sub trees"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _cbcpy.CbcStrategyDefaultSubTree_swiginit(self, _cbcpy.new_CbcStrategyDefaultSubTree(*args))
    __swig_destroy__ = _cbcpy.delete_CbcStrategyDefaultSubTree

    def clone(self):
        r""" Clone"""
        return _cbcpy.CbcStrategyDefaultSubTree_clone(self)

    def setupCutGenerators(self, model):
        r""" Setup cut generators"""
        return _cbcpy.CbcStrategyDefaultSubTree_setupCutGenerators(self, model)

    def setupHeuristics(self, model):
        r""" Setup heuristics"""
        return _cbcpy.CbcStrategyDefaultSubTree_setupHeuristics(self, model)

    def setupPrinting(self, model, modelLogLevel):
        r""" Do printing stuff"""
        return _cbcpy.CbcStrategyDefaultSubTree_setupPrinting(self, model, modelLogLevel)

    def setupOther(self, model):
        r""" Other stuff e.g. strong branching"""
        return _cbcpy.CbcStrategyDefaultSubTree_setupOther(self, model)

# Register CbcStrategyDefaultSubTree in _cbcpy:
_cbcpy.CbcStrategyDefaultSubTree_swigregister(CbcStrategyDefaultSubTree)

class OsiSolverInterface(object):
    r"""
    Abstract Base Class for describing an interface to a solver.

     Many OsiSolverInterface query methods return a const pointer to the
     requested read-only data. If the model data is changed or the solver
     is called, these pointers may no longer be valid and should be
     refreshed by invoking the member function to obtain an updated copy
     of the pointer.
     For example:

     .. code-block:: c++


               OsiSolverInterface solverInterfacePtr ;
               const double * ruBnds = solverInterfacePtr-getRowUpper();
               solverInterfacePtr-applyCuts(someSetOfCuts);
         ruBnds is no longer a valid pointer and must be refreshed
               ruBnds = solverInterfacePtr-getRowUpper();


     Querying a problem that has no data associated with it will result in
     zeros for the number of rows and columns, and NULL pointers from
     the methods that return vectors.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def initialSolve(self):
        r""" Solve initial LP relaxation"""
        return _cbcpy.OsiSolverInterface_initialSolve(self)

    def resolve(self):
        r"""
        Resolve an LP relaxation after problem modification

             Note the `re-' in `resolve'. initialSolve() should be used to solve the
             problem for the first time.
        """
        return _cbcpy.OsiSolverInterface_resolve(self)

    def branchAndBound(self):
        r""" Invoke solver's built-in enumeration algorithm"""
        return _cbcpy.OsiSolverInterface_branchAndBound(self)

    def setIntParam(self, key, value):
        r"""

             The set methods return true if the parameter was set to the given value,
             false otherwise. When a set method returns false, the original value (if
             any) should be unchanged.  There can be various reasons for failure: the
             given parameter is not applicable for the solver (e.g., refactorization
             frequency for the volume algorithm), the parameter is not yet
             implemented for the solver or simply the value of the parameter is out
             of the range the solver accepts. If a parameter setting call returns
             false check the details of your solver.

             The get methods return true if the given parameter is applicable for the
             solver and is implemented. In this case the value of the parameter is
             returned in the second argument. Otherwise they return false.

             Notes: 
             There is a default implementation of the set/get
             methods, namely to store/retrieve the given value using an array in the
             base class. A specific solver implementation can use this feature, for
             example, to store parameters that should be used later on. Implementors
             of a solver interface should overload these functions to provide the
             proper interface to and accurately reflect the capabilities of a
             specific solver.

             The format for hints is slightly different in that a boolean specifies
             the sense of the hint and an enum specifies the strength of the hint.
             Hints should be initialised when a solver is instantiated.
             (See OsiSolverParameters.hpp for defined hint parameters and strength.)
             When specifying the sense of the hint, a value of true means to work with
             the hint, false to work against it.  For example,

               *
        .. code-block:: c++

             setHintParam(OsiDoScale,true,OsiHintTry)

        	    is a mild suggestion to the solver to scale the constraint
        	    system.
               *
        .. code-block:: c++

             setHintParam(OsiDoScale,false,OsiForceDo)

        	    tells the solver to disable scaling, or throw an exception if
        	    it cannot comply.

             As another example, a solver interface could use the value and strength
             of the ``OsiDoReducePrint`` hint to adjust the amount of information
             printed by the interface and/or solver.  The extent to which a solver
             obeys hints is left to the solver.  The value and strength returned by
             ``getHintParam`` will match the most recent call to ``setHintParam``,
             and will not necessarily reflect the solver's ability to comply with the
             hint.  If the hint strength is ``OsiForceDo``, the solver is required to
             throw an exception if it cannot perform the specified action.


             As with the other set/get methods, there is a default implementation
             which maintains arrays in the base class for hint sense and strength.
             The default implementation does not store the ``otherInformation``
             pointer, and always throws an exception for strength ``OsiForceDo``.
             Implementors of a solver interface should override these functions to
             provide the proper interface to and accurately reflect the capabilities
             of a specific solver.
           Set an integer parameter
        """
        return _cbcpy.OsiSolverInterface_setIntParam(self, key, value)

    def setDblParam(self, key, value):
        r""" Set a double parameter"""
        return _cbcpy.OsiSolverInterface_setDblParam(self, key, value)

    def setStrParam(self, key, value):
        r""" Set a string parameter"""
        return _cbcpy.OsiSolverInterface_setStrParam(self, key, value)

    def setHintParam(self, *args):
        r"""
        Set a hint parameter

             The ``otherInformation`` parameter can be used to pass in an arbitrary
             block of information which is interpreted by the OSI and the underlying
             solver.  Users are cautioned that this hook is solver-specific.

             Implementors:
             The default implementation completely ignores ``otherInformation`` and
             always throws an exception for OsiForceDo. This is almost certainly not
             the behaviour you want; you really should override this method.
        """
        return _cbcpy.OsiSolverInterface_setHintParam(self, *args)

    def getIntParam(self, key, value):
        r""" Get an integer parameter"""
        return _cbcpy.OsiSolverInterface_getIntParam(self, key, value)

    def getDblParam(self, key, value):
        r""" Get a double parameter"""
        return _cbcpy.OsiSolverInterface_getDblParam(self, key, value)

    def getStrParam(self, key, value):
        r""" Get a string parameter"""
        return _cbcpy.OsiSolverInterface_getStrParam(self, key, value)

    def getHintParam(self, *args):
        r"""
        *Overload 1:*
         Get a hint parameter (all information)

        	Return all available information for the hint: sense, strength,
        	and any extra information associated with the hint.

        	Implementors: The default implementation will always set
        	``otherInformation`` to NULL. This is almost certainly not the
        	behaviour you want; you really should override this method.

        |

        *Overload 2:*
         Get a hint parameter (sense and strength only)

        	Return only the sense and strength of the hint.

        |

        *Overload 3:*
         Get a hint parameter (sense only)

        	Return only the sense (true/false) of the hint.
        """
        return _cbcpy.OsiSolverInterface_getHintParam(self, *args)

    def copyParameters(self, rhs):
        r"""
        Copy all parameters in this section from one solver to another

             Note that the current implementation also copies the appData block,
             message handler, and rowCutDebugger. Arguably these should have
             independent copy methods.
        """
        return _cbcpy.OsiSolverInterface_copyParameters(self, rhs)

    def getIntegerTolerance(self):
        r"""
        Return the integrality tolerance of the underlying solver.

        We should be able to get an integrality tolerance, but
               until that time just use the primal tolerance

        TODO: 
        This method should be replaced; it's architecturally wrong.  This
        should be an honest dblParam with a keyword. Underlying solvers
        that do not support integer variables should return false for set and
        get on this parameter.  Underlying solvers that support integrality
        should add this to the parameters they support, using whatever
        tolerance is appropriate.  -lh, 091021-
        """
        return _cbcpy.OsiSolverInterface_getIntegerTolerance(self)

    def isAbandoned(self):
        r""" Are there numerical difficulties?"""
        return _cbcpy.OsiSolverInterface_isAbandoned(self)

    def isProvenOptimal(self):
        r""" Is optimality proven?"""
        return _cbcpy.OsiSolverInterface_isProvenOptimal(self)

    def isProvenPrimalInfeasible(self):
        r""" Is primal infeasibility proven?"""
        return _cbcpy.OsiSolverInterface_isProvenPrimalInfeasible(self)

    def isProvenDualInfeasible(self):
        r""" Is dual infeasibility proven?"""
        return _cbcpy.OsiSolverInterface_isProvenDualInfeasible(self)

    def isPrimalObjectiveLimitReached(self):
        r""" Is the given primal objective limit reached?"""
        return _cbcpy.OsiSolverInterface_isPrimalObjectiveLimitReached(self)

    def isDualObjectiveLimitReached(self):
        r""" Is the given dual objective limit reached?"""
        return _cbcpy.OsiSolverInterface_isDualObjectiveLimitReached(self)

    def isIterationLimitReached(self):
        r""" Iteration limit reached?"""
        return _cbcpy.OsiSolverInterface_isIterationLimitReached(self)

    def getEmptyWarmStart(self):
        r"""
        Get an empty warm start object

             This routine returns an empty warm start object. Its purpose is
             to provide a way for a client to acquire a warm start object of the
             appropriate type for the solver, which can then be resized and modified
             as desired.
        """
        return _cbcpy.OsiSolverInterface_getEmptyWarmStart(self)

    def getWarmStart(self):
        r"""
        Get warm start information.

             Return warm start information for the current state of the solver
             interface. If there is no valid warm start information, an empty warm
             start object wil be returned.
        """
        return _cbcpy.OsiSolverInterface_getWarmStart(self)

    def getPointerToWarmStart(self, mustDelete):
        r"""
        Get warm start information.

             Return warm start information for the current state of the solver
             interface. If there is no valid warm start information, an empty warm
             start object wil be returned.  This does not necessarily create an
             object - may just point to one.  must Delete set true if user
             should delete returned object.
        """
        return _cbcpy.OsiSolverInterface_getPointerToWarmStart(self, mustDelete)

    def setWarmStart(self, warmstart):
        r"""
        Set warm start information.

             Return true or false depending on whether the warm start information was
             accepted or not.
             By definition, a call to setWarmStart with a null parameter should
             cause the solver interface to refresh its warm start information
             from the underlying solver.
        """
        return _cbcpy.OsiSolverInterface_setWarmStart(self, warmstart)

    def markHotStart(self):
        r"""

          Primarily used in strong branching. The user can create a hot start
          object --- a snapshot of the optimization process --- then reoptimize
          over and over again, starting from the same point.

          Notes: 

          *  Between hot started optimizations only bound changes are allowed.
          *  The copy constructor and assignment operator should NOT copy any
               hot start information.
          *  The default implementation simply extracts a warm start object in
               ``markHotStart``, resets to the warm start object in
        ``solveFromHotStart``, and deletes the warm start object in
        ``unmarkHotStart``.
        **Actual solver implementations are encouraged to do better.**


        Create a hot start snapshot of the optimization process.
        """
        return _cbcpy.OsiSolverInterface_markHotStart(self)

    def solveFromHotStart(self):
        r""" Optimize starting from the hot start snapshot."""
        return _cbcpy.OsiSolverInterface_solveFromHotStart(self)

    def unmarkHotStart(self):
        r""" Delete the hot start snapshot."""
        return _cbcpy.OsiSolverInterface_unmarkHotStart(self)

    def getNumCols(self):
        r""" Get the number of columns"""
        return _cbcpy.OsiSolverInterface_getNumCols(self)

    def getNumRows(self):
        r""" Get the number of rows"""
        return _cbcpy.OsiSolverInterface_getNumRows(self)

    def getNumElements(self):
        r""" Get the number of nonzero elements"""
        return _cbcpy.OsiSolverInterface_getNumElements(self)

    def getNumIntegers(self):
        r""" Get the number of integer variables"""
        return _cbcpy.OsiSolverInterface_getNumIntegers(self)

    def getColLower(self):
        r""" Get a pointer to an array[getNumCols()] of column lower bounds"""
        return _cbcpy.OsiSolverInterface_getColLower(self)

    def getColUpper(self):
        r""" Get a pointer to an array[getNumCols()] of column upper bounds"""
        return _cbcpy.OsiSolverInterface_getColUpper(self)

    def getRowSense(self):
        r"""
        Get a pointer to an array[getNumRows()] of row constraint senses.


             * 'L': <= constraint
             * 'E': =  constraint
             * 'G': >= constraint
             * 'R': ranged constraint
             * 'N': free constraint

        """
        return _cbcpy.OsiSolverInterface_getRowSense(self)

    def getRightHandSide(self):
        r"""
        Get a pointer to an array[getNumRows()] of row right-hand sides


        *  if getRowSense()[i] == 'L' then
             getRightHandSide()[i] == getRowUpper()[i]
        *  if getRowSense()[i] == 'G' then
             getRightHandSide()[i] == getRowLower()[i]
        *  if getRowSense()[i] == 'R' then
             getRightHandSide()[i] == getRowUpper()[i]
        *  if getRowSense()[i] == 'N' then
             getRightHandSide()[i] == 0.0

        """
        return _cbcpy.OsiSolverInterface_getRightHandSide(self)

    def getRowRange(self):
        r"""
        Get a pointer to an array[getNumRows()] of row ranges.


          *  if getRowSense()[i] == 'R' then
        	  getRowRange()[i] == getRowUpper()[i] - getRowLower()[i]
          *  if getRowSense()[i] != 'R' then
        	  getRowRange()[i] is 0.0

        """
        return _cbcpy.OsiSolverInterface_getRowRange(self)

    def getRowLower(self):
        r""" Get a pointer to an array[getNumRows()] of row lower bounds"""
        return _cbcpy.OsiSolverInterface_getRowLower(self)

    def getRowUpper(self):
        r""" Get a pointer to an array[getNumRows()] of row upper bounds"""
        return _cbcpy.OsiSolverInterface_getRowUpper(self)

    def getObjCoefficients(self):
        r"""
        Get a pointer to an array[getNumCols()] of objective
               function coefficients.
        """
        return _cbcpy.OsiSolverInterface_getObjCoefficients(self)

    def getObjSense(self):
        r"""
        Get the objective function sense

             -  1 for minimisation (default)
             - -1 for maximisation
        """
        return _cbcpy.OsiSolverInterface_getObjSense(self)

    def isContinuous(self, colIndex):
        r""" Return true if the variable is continuous"""
        return _cbcpy.OsiSolverInterface_isContinuous(self, colIndex)

    def isBinary(self, colIndex):
        r""" Return true if the variable is binary"""
        return _cbcpy.OsiSolverInterface_isBinary(self, colIndex)

    def isInteger(self, colIndex):
        r"""
        Return true if the variable is integer.

             This method returns true if the variable is binary or general integer.
        """
        return _cbcpy.OsiSolverInterface_isInteger(self, colIndex)

    def isIntegerNonBinary(self, colIndex):
        r""" Return true if the variable is general integer"""
        return _cbcpy.OsiSolverInterface_isIntegerNonBinary(self, colIndex)

    def isFreeBinary(self, colIndex):
        r""" Return true if the variable is binary and not fixed"""
        return _cbcpy.OsiSolverInterface_isFreeBinary(self, colIndex)

    def columnType(self, refresh=False):
        r"""
        Return an array[getNumCols()] of column types

             Deprecated: See #getColType
        """
        return _cbcpy.OsiSolverInterface_columnType(self, refresh)

    def setColumnType(self, iColumn, type):
        r""" Set column type"""
        return _cbcpy.OsiSolverInterface_setColumnType(self, iColumn, type)

    def getColType(self, refresh=False):
        r"""
        Return an array[getNumCols()] of column types

              - 0 - continuous
              - 1 - binary
              - 2 - general integer
              - 3 - if supported - semi-continuous
              - 4 - if supported - semi-continuous integer

             If refresh is true, the classification of integer variables as
             binary or general integer will be reevaluated. If the current bounds
             are [0,1], or if the variable is fixed at 0 or 1, it will be classified
             as binary, otherwise it will be classified as general integer.
        """
        return _cbcpy.OsiSolverInterface_getColType(self, refresh)

    def getMatrixByRow(self):
        r""" Get a pointer to a row-wise copy of the matrix"""
        return _cbcpy.OsiSolverInterface_getMatrixByRow(self)

    def getMatrixByCol(self):
        r""" Get a pointer to a column-wise copy of the matrix"""
        return _cbcpy.OsiSolverInterface_getMatrixByCol(self)

    def getMutableMatrixByRow(self):
        r"""
        Get a pointer to a mutable row-wise copy of the matrix.

             Returns NULL if the request is not meaningful (i.e., the OSI will not
             recognise any modifications to the matrix).
        """
        return _cbcpy.OsiSolverInterface_getMutableMatrixByRow(self)

    def getMutableMatrixByCol(self):
        r"""
        Get a pointer to a mutable column-wise copy of the matrix

             Returns NULL if the request is not meaningful (i.e., the OSI will not
             recognise any modifications to the matrix).
        """
        return _cbcpy.OsiSolverInterface_getMutableMatrixByCol(self)

    def getInfinity(self):
        r""" Get the solver's value for infinity"""
        return _cbcpy.OsiSolverInterface_getInfinity(self)

    def getColSolution(self):
        r""" Get a pointer to an array[getNumCols()] of primal variable values"""
        return _cbcpy.OsiSolverInterface_getColSolution(self)

    def getStrictColSolution(self):
        r"""
        Get a pointer to an array[getNumCols()] of primal variable values
        guaranteed to be between the column lower and upper bounds.
        """
        return _cbcpy.OsiSolverInterface_getStrictColSolution(self)

    def getRowPrice(self):
        r""" Get pointer to array[getNumRows()] of dual variable values"""
        return _cbcpy.OsiSolverInterface_getRowPrice(self)

    def getReducedCost(self):
        r""" Get a pointer to an array[getNumCols()] of reduced costs"""
        return _cbcpy.OsiSolverInterface_getReducedCost(self)

    def getRowActivity(self):
        r"""
        Get a pointer to array[getNumRows()] of row activity levels.

             The row activity for a row is the left-hand side evaluated at the
             current solution.
        """
        return _cbcpy.OsiSolverInterface_getRowActivity(self)

    def getObjValue(self):
        r""" Get the objective function value."""
        return _cbcpy.OsiSolverInterface_getObjValue(self)

    def getIterationCount(self):
        r"""
        Get the number of iterations it took to solve the problem (whatever
        `iteration' means to the solver).
        """
        return _cbcpy.OsiSolverInterface_getIterationCount(self)

    def getDualRays(self, maxNumRays, fullRay=False):
        r"""
        Get as many dual rays as the solver can provide. In case of proven
        primal infeasibility there should (with high probability) be at least
        one.

        The first getNumRows() ray components will always be associated with
        the row duals (as returned by getRowPrice()). If ``fullRay`` is true,
        the final getNumCols() entries will correspond to the ray components
        associated with the nonbasic variables. If the full ray is requested
        and the method cannot provide it, it will throw an exception.

        Notes: 
        Implementors of solver interfaces note that the double pointers in
        the vector should point to arrays of length getNumRows() (fullRay =
        false) or (getNumRows()+getNumCols()) (fullRay = true) and they should
        be allocated with new[].


        Clients of solver interfaces note that it is the client's
        responsibility to free the double pointers in the vector using
        delete[]. Clients are reminded that a problem can be dual and primal
        infeasible.
        """
        return _cbcpy.OsiSolverInterface_getDualRays(self, maxNumRays, fullRay)

    def getPrimalRays(self, maxNumRays):
        r"""
        Get as many primal rays as the solver can provide. In case of proven
        dual infeasibility there should (with high probability) be at least
        one.

        Notes: 
        Implementors of solver interfaces note that the double pointers in
        the vector should point to arrays of length getNumCols() and they
        should be allocated with new[].


        Clients of solver interfaces note that it is the client's
        responsibility to free the double pointers in the vector using
        delete[]. Clients are reminded that a problem can be dual and primal
        infeasible.
        """
        return _cbcpy.OsiSolverInterface_getPrimalRays(self, maxNumRays)

    def getFractionalIndices(self, etol=1.e-05):
        r"""
        Get vector of indices of primal variables which are integer variables
        but have fractional values in the current solution.
        """
        return _cbcpy.OsiSolverInterface_getFractionalIndices(self, etol)

    def setObjCoeff(self, elementIndex, elementValue):
        r"""

          For functions which take a set of indices as parameters
          (``setObjCoeffSet()``, ``setColSetBounds()``, ``setRowSetBounds()``,
          ``setRowSetTypes())``, the parameters follow the C++ STL iterator
          convention: ``indexFirst`` points to the first index in the
          set, and ``indexLast`` points to a position one past the last index
          in the set.

        Set an objective function coefficient
        """
        return _cbcpy.OsiSolverInterface_setObjCoeff(self, elementIndex, elementValue)

    def setObjCoeffSet(self, indexFirst, indexLast, coeffList):
        r""" Set a set of objective function coefficients"""
        return _cbcpy.OsiSolverInterface_setObjCoeffSet(self, indexFirst, indexLast, coeffList)

    def setObjective(self, array):
        r"""
        Set the objective coefficients for all columns.

        array [getNumCols()] is an array of values for the objective.
        This defaults to a series of set operations and is here for speed.
        """
        return _cbcpy.OsiSolverInterface_setObjective(self, array)

    def setObjSense(self, s):
        r"""
        Set the objective function sense.

               Use 1 for minimisation (default), -1 for maximisation.

        Notes: 
        Implementors note that objective function sense is a parameter of
        the OSI, not a property of the problem. Objective sense can be
        set prior to problem load and should not be affected by loading a
        new problem.
        """
        return _cbcpy.OsiSolverInterface_setObjSense(self, s)

    def setColLower(self, *args):
        r"""
        *Overload 1:*
         Set a single column lower bound.
        	Use -getInfinity() for -infinity.

        |

        *Overload 2:*
         Set the lower bounds for all columns.

        	array [getNumCols()] is an array of values for the lower bounds.
        	This defaults to a series of set operations and is here for speed.
        """
        return _cbcpy.OsiSolverInterface_setColLower(self, *args)

    def setColUpper(self, *args):
        r"""
        *Overload 1:*
         Set a single column upper bound.
        	Use getInfinity() for infinity.

        |

        *Overload 2:*
         Set the upper bounds for all columns.

        	array [getNumCols()] is an array of values for the upper bounds.
        	This defaults to a series of set operations and is here for speed.
        """
        return _cbcpy.OsiSolverInterface_setColUpper(self, *args)

    def setColBounds(self, elementIndex, lower, upper):
        r"""
        Set a single column lower and upper bound.
        The default implementation just invokes setColLower() and
        setColUpper()
        """
        return _cbcpy.OsiSolverInterface_setColBounds(self, elementIndex, lower, upper)

    def setColSetBounds(self, indexFirst, indexLast, boundList):
        r"""
        Set the upper and lower bounds of a set of columns.

        The default implementation just invokes setColBounds() over and over
        again.  For each column, boundList must contain both a lower and
        upper bound, in that order.
        """
        return _cbcpy.OsiSolverInterface_setColSetBounds(self, indexFirst, indexLast, boundList)

    def setRowLower(self, elementIndex, elementValue):
        r"""
        Set a single row lower bound.
        Use -getInfinity() for -infinity.
        """
        return _cbcpy.OsiSolverInterface_setRowLower(self, elementIndex, elementValue)

    def setRowUpper(self, elementIndex, elementValue):
        r"""
        Set a single row upper bound.
        Use getInfinity() for infinity.
        """
        return _cbcpy.OsiSolverInterface_setRowUpper(self, elementIndex, elementValue)

    def setRowBounds(self, elementIndex, lower, upper):
        r"""
        Set a single row lower and upper bound.
        The default implementation just invokes setRowLower() and
        setRowUpper()
        """
        return _cbcpy.OsiSolverInterface_setRowBounds(self, elementIndex, lower, upper)

    def setRowSetBounds(self, indexFirst, indexLast, boundList):
        r"""
        Set the bounds on a set of rows.

        The default implementation just invokes setRowBounds() over and over
        again.  For each row, boundList must contain both a lower and
        upper bound, in that order.
        """
        return _cbcpy.OsiSolverInterface_setRowSetBounds(self, indexFirst, indexLast, boundList)

    def setRowType(self, index, sense, rightHandSide, range):
        r""" Set the type of a single row"""
        return _cbcpy.OsiSolverInterface_setRowType(self, index, sense, rightHandSide, range)

    def setRowSetTypes(self, indexFirst, indexLast, senseList, rhsList, rangeList):
        r"""
        Set the type of a set of rows.
        The default implementation just invokes setRowType()
        over and over again.
        """
        return _cbcpy.OsiSolverInterface_setRowSetTypes(self, indexFirst, indexLast, senseList, rhsList, rangeList)

    def setColSolution(self, colsol):
        r"""
        Set the primal solution variable values

        colsol[getNumCols()] is an array of values for the primal variables.
        These values are copied to memory owned by the solver interface
        object or the solver.  They will be returned as the result of
        getColSolution() until changed by another call to setColSolution() or
        by a call to any solver routine.  Whether the solver makes use of the
        solution in any way is solver-dependent.
        """
        return _cbcpy.OsiSolverInterface_setColSolution(self, colsol)

    def setRowPrice(self, rowprice):
        r"""
        Set dual solution variable values

        rowprice[getNumRows()] is an array of values for the dual variables.
        These values are copied to memory owned by the solver interface
        object or the solver.  They will be returned as the result of
        getRowPrice() until changed by another call to setRowPrice() or by a
        call to any solver routine.  Whether the solver makes use of the
        solution in any way is solver-dependent.
        """
        return _cbcpy.OsiSolverInterface_setRowPrice(self, rowprice)

    def reducedCostFix(self, gap, justInteger=True):
        r"""
        Fix variables at bound based on reduced cost

        For variables currently at bound, fix the variable at bound if the
        reduced cost exceeds the gap. Return the number of variables fixed.

        If justInteger is set to false, the routine will also fix continuous
        variables, but the test still assumes a delta of 1.0.
        """
        return _cbcpy.OsiSolverInterface_reducedCostFix(self, gap, justInteger)

    def setContinuous(self, *args):
        r"""
        *Overload 1:*
         Set the index-th variable to be a continuous variable

        |

        *Overload 2:*
         Set the variables listed in indices (which is of length len) to be
        	continuous variables
        """
        return _cbcpy.OsiSolverInterface_setContinuous(self, *args)

    def setInteger(self, *args):
        r"""
        *Overload 1:*
         Set the index-th variable to be an integer variable

        |

        *Overload 2:*
         Set the variables listed in indices (which is of length len) to be
        	integer variables
        """
        return _cbcpy.OsiSolverInterface_setInteger(self, *args)

    def dfltRowColName(self, rc, ndx, digits=7):
        r"""
        Generate a standard name of the form Rnnnnnnn or Cnnnnnnn

             Set rc to 'r' for a row name, 'c' for a column name.
             The `nnnnnnn' part is generated from ndx and will contain 7 digits
             by default, padded with zeros if necessary. As a special case,
             ndx = getNumRows() is interpreted as a request for the name of the
             objective function. OBJECTIVE is returned, truncated to digits+1
             characters to match the row and column names.
        """
        return _cbcpy.OsiSolverInterface_dfltRowColName(self, rc, ndx, digits)

    def getObjName(self, *args):
        r""" Return the name of the objective function"""
        return _cbcpy.OsiSolverInterface_getObjName(self, *args)

    def setObjName(self, name):
        r""" Set the name of the objective function"""
        return _cbcpy.OsiSolverInterface_setObjName(self, name)

    def getRowName(self, *args):
        r"""
        Return the name of the row.

             The routine will *always* return some name, regardless of the name
             discipline or the level of support by an OsiXXX derived class. Use
             maxLen to limit the length.
        """
        return _cbcpy.OsiSolverInterface_getRowName(self, *args)

    def getRowNames(self):
        r"""
        Return a pointer to a vector of row names

             If the name discipline (#OsiNameDiscipline) is auto, the return value
             will be a vector of length zero. If the name discipline is lazy, the
             vector will contain only names supplied by the client and will be no
             larger than needed to hold those names; entries not supplied will be
             null strings. In particular, the objective name is *not*
             included in the vector for lazy names. If the name discipline is
             full, the vector will have getNumRows() names, either supplied or
             generated, plus one additional entry for the objective name.
        """
        return _cbcpy.OsiSolverInterface_getRowNames(self)

    def setRowName(self, ndx, name):
        r"""
        Set a row name

             Quietly does nothing if the name discipline (#OsiNameDiscipline) is
             auto. Quietly fails if the row index is invalid.
        """
        return _cbcpy.OsiSolverInterface_setRowName(self, ndx, name)

    def setRowNames(self, srcNames, srcStart, len, tgtStart):
        r"""
        Set multiple row names

             The run of len entries starting at srcNames[srcStart] are installed as
             row names starting at row index tgtStart. The base class implementation
             makes repeated calls to setRowName.
        """
        return _cbcpy.OsiSolverInterface_setRowNames(self, srcNames, srcStart, len, tgtStart)

    def deleteRowNames(self, tgtStart, len):
        r"""
        Delete len row names starting at index tgtStart

             The specified row names are removed and the remaining row names are
             copied down to close the gap.
        """
        return _cbcpy.OsiSolverInterface_deleteRowNames(self, tgtStart, len)

    def getColName(self, *args):
        r"""
        Return the name of the column

             The routine will *always* return some name, regardless of the name
             discipline or the level of support by an OsiXXX derived class. Use
             maxLen to limit the length.
        """
        return _cbcpy.OsiSolverInterface_getColName(self, *args)

    def getColNames(self):
        r"""
        Return a pointer to a vector of column names

             If the name discipline (#OsiNameDiscipline) is auto, the return value
             will be a vector of length zero. If the name discipline is lazy, the
             vector will contain only names supplied by the client and will be no
             larger than needed to hold those names; entries not supplied will be
             null strings. If the name discipline is full, the vector will have
             getNumCols() names, either supplied or generated.
        """
        return _cbcpy.OsiSolverInterface_getColNames(self)

    def setColName(self, ndx, name):
        r"""
        Set a column name

             Quietly does nothing if the name discipline (#OsiNameDiscipline) is
             auto. Quietly fails if the column index is invalid.
        """
        return _cbcpy.OsiSolverInterface_setColName(self, ndx, name)

    def setColNames(self, srcNames, srcStart, len, tgtStart):
        r"""
        Set multiple column names

             The run of len entries starting at srcNames[srcStart] are installed as
             column names starting at column index tgtStart. The base class
             implementation makes repeated calls to setColName.
        """
        return _cbcpy.OsiSolverInterface_setColNames(self, srcNames, srcStart, len, tgtStart)

    def deleteColNames(self, tgtStart, len):
        r"""
        Delete len column names starting at index tgtStart

             The specified column names are removed and the remaining column names
             are copied down to close the gap.
        """
        return _cbcpy.OsiSolverInterface_deleteColNames(self, tgtStart, len)

    def setRowColNames(self, *args):
        r"""
        *Overload 1:*
        Set row and column names from a CoinMpsIO object.

             Also sets the name of the objective function. If the name discipline
             is auto, you get what you asked for. This routine does not use
             setRowName or setColName.

        |

        *Overload 2:*
        Set row and column names from a CoinModel object.

             If the name discipline is auto, you get what you asked for.
             This routine does not use setRowName or setColName.

        |

        *Overload 3:*
        Set row and column names from a CoinLpIO object.

             Also sets the name of the objective function. If the name discipline is
             auto, you get what you asked for. This routine does not use setRowName
             or setColName.
        """
        return _cbcpy.OsiSolverInterface_setRowColNames(self, *args)

    def addCol(self, *args):
        r"""
        *Overload 1:*
        Add a column (primal variable) to the problem.

        |

        *Overload 2:*
        Add a named column (primal variable) to the problem.

             The default implementation adds the column, then changes the name. This
             can surely be made more efficient within an OsiXXX class.

        |

        *Overload 3:*
        Add a column (primal variable) to the problem.

        |

        *Overload 4:*
        Add a named column (primal variable) to the problem.

             The default implementation adds the column, then changes the name. This
             can surely be made more efficient within an OsiXXX class.
        """
        return _cbcpy.OsiSolverInterface_addCol(self, *args)

    def addCols(self, *args):
        r"""
        *Overload 1:*
        Add a set of columns (primal variables) to the problem.

             The default implementation simply makes repeated calls to
             addCol().

        |

        *Overload 2:*
        Add a set of columns (primal variables) to the problem.

             The default implementation simply makes repeated calls to
             addCol().

        |

        *Overload 3:*
        Add columns using a CoinBuild object

        |

        *Overload 4:*
        Add columns from a model object.  returns
              -1 if object in bad state (i.e. has row information)
              otherwise number of errors
              modelObject non const as can be regularized as part of build
        """
        return _cbcpy.OsiSolverInterface_addCols(self, *args)

    def deleteCols(self, num, colIndices):
        r"""
        Remove a set of columns (primal variables) from the
               problem.

             The solver interface for a basis-oriented solver will maintain valid
             warm start information if all deleted variables are nonbasic.
        """
        return _cbcpy.OsiSolverInterface_deleteCols(self, num, colIndices)

    def addRow(self, *args):
        r"""
        *Overload 1:*
        Add a row (constraint) to the problem.

        |

        *Overload 2:*
        Add a named row (constraint) to the problem.

             The default implementation adds the row, then changes the name. This
             can surely be made more efficient within an OsiXXX class.

        |

        *Overload 3:*
        Add a row (constraint) to the problem.

        |

        *Overload 4:*
        Add a named row (constraint) to the problem.

             The default implementation adds the row, then changes the name. This
             can surely be made more efficient within an OsiXXX class.

        |

        *Overload 5:*
        Add a row (constraint) to the problem.

             Converts to addRow(CoinPackedVectorBase&,const double,const double).
        """
        return _cbcpy.OsiSolverInterface_addRow(self, *args)

    def addRows(self, *args):
        r"""
        *Overload 1:*
        Add a set of rows (constraints) to the problem.

             The default implementation simply makes repeated calls to
             addRow().

        |

        *Overload 2:*
        Add a set of rows (constraints) to the problem.

             The default implementation simply makes repeated calls to
             addRow().

        |

        *Overload 3:*
        Add a set of rows (constraints) to the problem.

             The default implementation simply makes repeated calls to
             addRow().

        |

        *Overload 4:*
        Add rows using a CoinBuild object

        |

        *Overload 5:*
        Add rows from a CoinModel object.

             Returns -1 if the object is in the wrong state (*i.e.*, has
             column-major information), otherwise the number of errors.

             The modelObject is not const as it can be regularized as part of
             the build.
        """
        return _cbcpy.OsiSolverInterface_addRows(self, *args)

    def deleteRows(self, num, rowIndices):
        r"""
        Delete a set of rows (constraints) from the problem.

             The solver interface for a basis-oriented solver will maintain valid
             warm start information if all deleted rows are loose.
        """
        return _cbcpy.OsiSolverInterface_deleteRows(self, num, rowIndices)

    def replaceMatrixOptional(self, arg2):
        r"""
        Replace the constraint matrix

             I (JJF) am getting annoyed because I can't just replace a matrix.
             The default behavior of this is do nothing so only use where that would
             not matter, e.g. strengthening a matrix for MIP.
        """
        return _cbcpy.OsiSolverInterface_replaceMatrixOptional(self, arg2)

    def replaceMatrix(self, arg2):
        r"""
        Replace the constraint matrix

             And if it does matter (not used at present)
        """
        return _cbcpy.OsiSolverInterface_replaceMatrix(self, arg2)

    def saveBaseModel(self):
        r"""
        Save a copy of the base model

             If solver wants it can save a copy of "base" (continuous) model here.
        """
        return _cbcpy.OsiSolverInterface_saveBaseModel(self)

    def restoreBaseModel(self, numberRows):
        r"""
        Reduce the constraint system to the specified number of
           	       constraints.

              If solver wants it can restore a copy of "base" (continuous) model
              here.

              Notes: 
              The name is somewhat misleading. Implementors should consider
              the opportunity to optimise behaviour in the common case where
              numberRows is exactly the number of original constraints. Do not,
              however, neglect the possibility that numberRows does not equal
              the number of original constraints.
        """
        return _cbcpy.OsiSolverInterface_restoreBaseModel(self, numberRows)

    def applyCuts(self, cs, effectivenessLb=0.0):
        r"""
        Apply a collection of cuts.

        Only cuts which have an ``effectiveness >= effectivenessLb``
        are applied.

          *  ReturnCode.getNumineffective() -- number of cuts which were
               not applied because they had an
               ``effectiveness < effectivenessLb``
          *  ReturnCode.getNuminconsistent() -- number of invalid cuts
          *  ReturnCode.getNuminconsistentWrtIntegerModel() -- number of
               cuts that are invalid with respect to this integer model
          *  ReturnCode.getNuminfeasible() -- number of cuts that would
               make this integer model infeasible
          *  ReturnCode.getNumApplied() -- number of integer cuts which
               were applied to the integer model
          *  cs.size() == getNumineffective() +
        		    getNuminconsistent() +
        		    getNuminconsistentWrtIntegerModel() +
        		    getNuminfeasible() +
        		    getNumApplied()

        """
        return _cbcpy.OsiSolverInterface_applyCuts(self, cs, effectivenessLb)

    def applyRowCuts(self, *args):
        r"""
        *Overload 1:*
         Apply a collection of row cuts which are all effective.
        	applyCuts seems to do one at a time which seems inefficient.
        	Would be even more efficient to pass an array of pointers.

        |

        *Overload 2:*
         Apply a collection of row cuts which are all effective.
        	This is passed in as an array of pointers.
        """
        return _cbcpy.OsiSolverInterface_applyRowCuts(self, *args)

    def deleteBranchingInfo(self, numberDeleted, which):
        r""" Deletes branching information before columns deleted"""
        return _cbcpy.OsiSolverInterface_deleteBranchingInfo(self, numberDeleted, which)

    def assignProblem(self, *args):
        r"""
        *Overload 1:*
         Load in a problem by assuming ownership of the arguments.
        	    The constraints on the rows are given by lower and upper bounds.

        	For default argument values see the matching loadProblem method.

        	Warning: 
        	The arguments passed to this method will be freed using the
        	C++ ``delete`` and ``delete[]`` functions.

        |

        *Overload 2:*
         Load in a problem by assuming ownership of the arguments.
        	    The constraints on the rows are given by sense/rhs/range triplets.

        	For default argument values see the matching loadProblem method.

        	Warning: 
        	The arguments passed to this method will be freed using the
        	C++ ``delete`` and ``delete[]`` functions.
        """
        return _cbcpy.OsiSolverInterface_assignProblem(self, *args)

    def loadProblem(self, *args):
        r"""
        *Overload 1:*
         Load in a problem by copying the arguments. The constraints on
        	    the rows are given by lower and upper bounds.

        	If a pointer is 0 then the following values are the default:

                  *  ``colub``: all columns have upper bound infinity
                  *  ``collb``: all columns have lower bound 0
                  *  ``rowub``: all rows have upper bound infinity
                  *  ``rowlb``: all rows have lower bound -infinity
        	  *  ``obj``: all variables have 0 objective coefficient


        	Note that the default values for rowub and rowlb produce the
        	constraint -infty <= ax <= infty. This is probably not what you want.

        |

        *Overload 2:*
         Load in a problem by copying the arguments.
        	    The constraints on the rows are given by sense/rhs/range triplets.

        	If a pointer is 0 then the following values are the default:

                  *  ``colub``: all columns have upper bound infinity
                  *  ``collb``: all columns have lower bound 0
        	  *  ``obj``: all variables have 0 objective coefficient
                  *  ``rowsen``: all rows are >=
                  *  ``rowrhs``: all right hand sides are 0
                  *  ``rowrng``: 0 for the ranged rows


        	Note that the default values for rowsen, rowrhs, and rowrng produce the
        	constraint ax >= 0.

        |

        *Overload 3:*
         Load in a problem by copying the arguments. The constraint
        	    matrix is is specified with standard column-major
        	    column starts / row indices / coefficients vectors.
        	    The constraints on the rows are given by lower and upper bounds.

              The matrix vectors must be gap-free. Note that ``start`` must
              have ``numcols+1`` entries so that the length of the last column
              can be calculated as ``start[numcols]-start[numcols-1]``.

              See the previous loadProblem method using rowlb and rowub for default
              argument values.

        |

        *Overload 4:*
         Load in a problem by copying the arguments. The constraint
        	    matrix is is specified with standard column-major
        	    column starts / row indices / coefficients vectors.
        	    The constraints on the rows are given by sense/rhs/range triplets.

              The matrix vectors must be gap-free. Note that ``start`` must
              have ``numcols+1`` entries so that the length of the last column
              can be calculated as ``start[numcols]-start[numcols-1]``.

              See the previous loadProblem method using sense/rhs/range for default
              argument values.
        """
        return _cbcpy.OsiSolverInterface_loadProblem(self, *args)

    def loadFromCoinModel(self, modelObject, keepSolution=False):
        r"""
        Load a model from a CoinModel object. Return the number of
            errors encountered.

             The modelObject parameter cannot be const as it may be changed as part
             of process. If keepSolution is true will try and keep warmStart.
        """
        return _cbcpy.OsiSolverInterface_loadFromCoinModel(self, modelObject, keepSolution)

    def readMps(self, *args):
        r"""
        *Overload 1:*
        Read a problem in MPS format from the given filename.

             The default implementation uses CoinMpsIO::readMps() to read
             the MPS file and returns the number of errors encountered.

        |

        *Overload 2:*
        Read a problem in MPS format from the given full filename.

             This uses CoinMpsIO::readMps() to read the MPS file and returns the
             number of errors encountered. It also may return an array of set
             information
        """
        return _cbcpy.OsiSolverInterface_readMps(self, *args)

    def readGMPL(self, filename, dataname=None):
        r"""
        Read a problem in GMPL format from the given filenames.

             The default implementation uses CoinMpsIO::readGMPL(). This capability
             is available only if the third-party package Glpk is installed.
        """
        return _cbcpy.OsiSolverInterface_readGMPL(self, filename, dataname)

    def writeMps(self, *args):
        r"""
        Write the problem in MPS format to the specified file.

             If objSense is non-zero, a value of -1.0 causes the problem to be
             written with a maximization objective; +1.0 forces a minimization
             objective. If objSense is zero, the choice is left to the implementation.
        """
        return _cbcpy.OsiSolverInterface_writeMps(self, *args)

    def writeMpsNative(self, filename, rowNames, columnNames, formatType=0, numberAcross=2, objSense=0.0, numberSOS=0, setInfo=None):
        r"""
        Write the problem in MPS format to the specified file with
            more control over the output.

        Row and column names may be null.
        formatType is

          *  0 - normal
          *  1 - extra accuracy
          *  2 - IEEE hex


        Returns non-zero on I/O error
        """
        return _cbcpy.OsiSolverInterface_writeMpsNative(self, filename, rowNames, columnNames, formatType, numberAcross, objSense, numberSOS, setInfo)

    def writeLp(self, *args):
        r"""
        *Overload 1:*
        Write the problem into an Lp file of the given filename with the
             specified extension.
             Coefficients with value less than epsilon away from an integer value
             are written as integers.
             Write at most numberAcross monomials on a line.
             Write non integer numbers with decimals digits after the decimal point.

             The written problem is always a minimization problem.
             If the current problem is a maximization problem, the
             intended objective function for the written problem is the current
             objective function multiplied by -1. If the current problem is a
             minimization problem, the intended objective function for the
             written problem is the current objective function.
             If objSense < 0, the intended objective function is multiplied by -1
             before writing the problem. It is left unchanged otherwise.

             Write objective function name and constraint names if useRowNames is
             true. This version calls writeLpNative().

        |

        *Overload 2:*
        Write the problem into the file pointed to by the parameter fp.
             Other parameters are similar to
             those of writeLp() with first parameter filename.

        |

        *Overload 3:*
        Write the problem into the file pointed to by the parameter fp.
             Other parameters are similar to
             those of writeLp() with first parameter filename.

        |

        *Overload 4:*
        Write the problem into the file pointed to by the parameter fp.
             Other parameters are similar to
             those of writeLp() with first parameter filename.

        |

        *Overload 5:*
        Write the problem into the file pointed to by the parameter fp.
             Other parameters are similar to
             those of writeLp() with first parameter filename.

        |

        *Overload 6:*
        Write the problem into the file pointed to by the parameter fp.
             Other parameters are similar to
             those of writeLp() with first parameter filename.

        |

        *Overload 7:*
        Write the problem into the file pointed to by the parameter fp.
             Other parameters are similar to
             those of writeLp() with first parameter filename.
        """
        return _cbcpy.OsiSolverInterface_writeLp(self, *args)

    def writeLpNative(self, *args):
        r"""
        *Overload 1:*
        Write the problem into an Lp file. Parameters are similar to
             those of writeLp(), but in addition row names and column names
             may be given.

             Parameter rowNames may be NULL, in which case default row names
             are used. If rowNames is not NULL, it must have exactly one entry
             per row in the problem and one additional
             entry (rowNames[getNumRows()] with the objective function name.
             These getNumRows()+1 entries must be distinct. If this is not the
             case, default row names
             are used. In addition, format restrictions are imposed on names
             (see CoinLpIO::is_invalid_name() for details).

             Similar remarks can be made for the parameter columnNames which
             must either be NULL or have exactly getNumCols() distinct entries.

             Write objective function name and constraint names if
             useRowNames is true.

        |

        *Overload 2:*
        Write the problem into the file pointed to by the parameter fp.
             Other parameters are similar to
             those of writeLpNative() with first parameter filename.

        |

        *Overload 3:*
        Write the problem into the file pointed to by the parameter fp.
             Other parameters are similar to
             those of writeLpNative() with first parameter filename.

        |

        *Overload 4:*
        Write the problem into the file pointed to by the parameter fp.
             Other parameters are similar to
             those of writeLpNative() with first parameter filename.

        |

        *Overload 5:*
        Write the problem into the file pointed to by the parameter fp.
             Other parameters are similar to
             those of writeLpNative() with first parameter filename.

        |

        *Overload 6:*
        Write the problem into the file pointed to by the parameter fp.
             Other parameters are similar to
             those of writeLpNative() with first parameter filename.

        |

        *Overload 7:*
        Write the problem into the file pointed to by the parameter fp.
             Other parameters are similar to
             those of writeLpNative() with first parameter filename.
        """
        return _cbcpy.OsiSolverInterface_writeLpNative(self, *args)

    def readLp(self, *args):
        r"""
        *Overload 1:*
        Read file in LP format from file with name filename. See class CoinLpIO for description of this format.

        |

        *Overload 2:*
        Read file in LP format from the file pointed to by fp. See class CoinLpIO for description of this format.

        |

        *Overload 3:*
        Read file in LP format from the file pointed to by fp. See class CoinLpIO for description of this format.
        """
        return _cbcpy.OsiSolverInterface_readLp(self, *args)

    def differentModel(self, other, ignoreNames=True):
        r"""
        Check two models against each other.  Return nonzero if different.
             Ignore names if that set.
             (Note initial version does not check names)
             May modify both models by cleaning up
        """
        return _cbcpy.OsiSolverInterface_differentModel(self, other, ignoreNames)

    def statistics(self, minimumNegative, maximumNegative, minimumPositive, maximumPositive, type=3):
        r"""
        Get some statistics about model - min/max always computed
             type 0->4 , larger gives more information
             0 - Just set min and max values of coefficients
        """
        return _cbcpy.OsiSolverInterface_statistics(self, minimumNegative, maximumNegative, minimumPositive, maximumPositive, type)

    def setApplicationData(self, appData):
        r"""
        Set application data.

        This is a pointer that the application can store into and
        retrieve from the solver interface.
        This field is available for the application to optionally
        define and use.
        """
        return _cbcpy.OsiSolverInterface_setApplicationData(self, appData)

    def setAuxiliaryInfo(self, auxiliaryInfo):
        r"""
        Create a clone of an Auxiliary Information object.
               The base class just stores an application data pointer
               but can be more general.  Application data pointer is
               designed for one user while this can be extended to cope
               with more general extensions.
        """
        return _cbcpy.OsiSolverInterface_setAuxiliaryInfo(self, auxiliaryInfo)

    def getApplicationData(self):
        r""" Get application data"""
        return _cbcpy.OsiSolverInterface_getApplicationData(self)

    def getAuxiliaryInfo(self):
        r""" Get pointer to auxiliary info object"""
        return _cbcpy.OsiSolverInterface_getAuxiliaryInfo(self)

    def passInMessageHandler(self, handler):
        r"""
        Pass in a message handler

           It is the client's responsibility to destroy a message handler installed
           by this routine; it will not be destroyed when the solver interface is
           destroyed.
        """
        return _cbcpy.OsiSolverInterface_passInMessageHandler(self, handler)

    def newLanguage(self, language):
        r""" Set language"""
        return _cbcpy.OsiSolverInterface_newLanguage(self, language)

    def setLanguage(self, language):
        return _cbcpy.OsiSolverInterface_setLanguage(self, language)

    def messageHandler(self):
        r""" Return a pointer to the current message handler"""
        return _cbcpy.OsiSolverInterface_messageHandler(self)

    def messages(self):
        r""" Return the current set of messages"""
        return _cbcpy.OsiSolverInterface_messages(self)

    def messagesPointer(self):
        r""" Return a pointer to the current set of messages"""
        return _cbcpy.OsiSolverInterface_messagesPointer(self)

    def defaultHandler(self):
        r""" Return true if default handler"""
        return _cbcpy.OsiSolverInterface_defaultHandler(self)

    def findIntegers(self, justCount):
        r"""
        Identify integer variables and create corresponding objects.

             Record integer variables and create an OsiSimpleInteger object for each
             one.  All existing OsiSimpleInteger objects will be destroyed.
             If justCount then no objects created and we just store numberIntegers_
        """
        return _cbcpy.OsiSolverInterface_findIntegers(self, justCount)

    def findIntegersAndSOS(self, justCount):
        r"""
        Identify integer variables and SOS and create corresponding objects.

             Record integer variables and create an OsiSimpleInteger object for each
             one.  All existing OsiSimpleInteger objects will be destroyed.
             If the solver supports SOS then do the same for SOS.

             If justCount then no objects created and we just store numberIntegers_
             Returns number of SOS
        """
        return _cbcpy.OsiSolverInterface_findIntegersAndSOS(self, justCount)

    def numberObjects(self):
        r""" Get the number of objects"""
        return _cbcpy.OsiSolverInterface_numberObjects(self)

    def setNumberObjects(self, number):
        r""" Set the number of objects"""
        return _cbcpy.OsiSolverInterface_setNumberObjects(self, number)

    def objects(self):
        r""" Get the array of objects"""
        return _cbcpy.OsiSolverInterface_objects(self)

    def object(self, which):
        r""" Get the specified object"""
        return _cbcpy.OsiSolverInterface_object(self, which)

    def modifiableObject(self, which):
        r""" Get the specified object"""
        return _cbcpy.OsiSolverInterface_modifiableObject(self, which)

    def deleteObjects(self):
        r""" Delete all object information"""
        return _cbcpy.OsiSolverInterface_deleteObjects(self)

    def addObjects(self, numberObjects, objects):
        r"""
        Add in object information.

             Objects are cloned; the owner can delete the originals.
        """
        return _cbcpy.OsiSolverInterface_addObjects(self, numberObjects, objects)

    def forceFeasible(self):
        r"""
        Use current solution to set bounds so current integer feasible solution will stay feasible.
               Only feasible bounds will be used, even if current solution outside bounds.  The amount of
               such violation will be returned (and if small can be ignored)
        """
        return _cbcpy.OsiSolverInterface_forceFeasible(self)

    def activateRowCutDebugger(self, *args):
        r"""
        *Overload 1:*
        Activate the row cut debugger.

             If modelName is in the set of known models then all cuts are
             checked to see that they do NOT cut off the optimal solution known
             to the debugger.

        |

        *Overload 2:*
        Activate the row cut debugger using a full solution array.


             Activate the debugger for a model not included in the debugger's
             internal database.  Cuts will be checked to see that they do NOT
             cut off the given solution.

             solution must be a full solution vector, but only the integer
             variables need to be correct. The debugger will fill in the continuous
             variables by solving an lp relaxation with the integer variables
             fixed as specified. If the given values for the continuous variables
             should be preserved, set keepContinuous to true.

        |

        *Overload 3:*
        Activate the row cut debugger using a full solution array.


             Activate the debugger for a model not included in the debugger's
             internal database.  Cuts will be checked to see that they do NOT
             cut off the given solution.

             solution must be a full solution vector, but only the integer
             variables need to be correct. The debugger will fill in the continuous
             variables by solving an lp relaxation with the integer variables
             fixed as specified. If the given values for the continuous variables
             should be preserved, set keepContinuous to true.
        """
        return _cbcpy.OsiSolverInterface_activateRowCutDebugger(self, *args)

    def getRowCutDebugger(self):
        r"""
        Get the row cut debugger provided the solution known to the
           	       debugger is within the feasible region held in the solver.

             If there is a row cut debugger object associated with model AND if
             the solution known to the debugger is within the solver's current
             feasible region (i.e., the column bounds held in the solver are
             compatible with the known solution) then a pointer to the debugger
             is returned which may be used to test validity of cuts.

             Otherwise NULL is returned
        """
        return _cbcpy.OsiSolverInterface_getRowCutDebugger(self)

    def getRowCutDebuggerAlways(self):
        r"""
        Get the row cut debugger object

             Return the row cut debugger object if it exists. One common usage of
             this method is to obtain a debugger object in order to execute
             OsiRowCutDebugger::redoSolution (so that the stored solution is again
             compatible with the problem held in the solver).
        """
        return _cbcpy.OsiSolverInterface_getRowCutDebuggerAlways(self)

    def canDoSimplexInterface(self):
        r"""
        Return the simplex implementation level.

             The return codes are:
             - 0: the simplex interface is not implemented.
             - 1: the Group 1 (tableau access) methods are implemented.
             - 2: the Group 2 (pivoting) methods are implemented

             The codes are cumulative - a solver which implements Group 2 also
             implements Group 1.
        """
        return _cbcpy.OsiSolverInterface_canDoSimplexInterface(self)

    def enableFactorization(self):
        r"""
        Prepare the solver for the use of tableau access methods.

           Prepares the solver for the use of the tableau access methods, if
           any such preparation is required.

           The ``const`` attribute is required due to the places this method
           may be called (e.g., within CglCutGenerator::generateCuts()).
        """
        return _cbcpy.OsiSolverInterface_enableFactorization(self)

    def disableFactorization(self):
        r""" Undo the effects of #enableFactorization."""
        return _cbcpy.OsiSolverInterface_disableFactorization(self)

    def basisIsAvailable(self):
        r"""
        Check if an optimal basis is available.

           Returns true if the problem has been solved to optimality and a
           basis is available. This should be used to see if the tableau access
           operations are possible and meaningful.

           Notes: 
           Implementors please note that this method may be called
           before #enableFactorization.
        """
        return _cbcpy.OsiSolverInterface_basisIsAvailable(self)

    def optimalBasisIsAvailable(self):
        r""" Synonym for #basisIsAvailable"""
        return _cbcpy.OsiSolverInterface_optimalBasisIsAvailable(self)

    def getBasisStatus(self, cstat, rstat):
        r"""
        Retrieve status information for column and row variables.

           This method returns status as integer codes:

             *  0: free
             *  1: basic
             *  2: nonbasic at upper bound
             *  3: nonbasic at lower bound


           The #getWarmStart method provides essentially the same functionality
           for a simplex-oriented solver, but the implementation details are very
           different.

           Notes: 
           Logical variables associated with rows are all assumed to have +1
           coefficients, so for a <= constraint the logical will be at lower
           bound if the constraint is tight.


           Implementors may choose to implement this method as a wrapper which
           converts a CoinWarmStartBasis to the requested representation.
        """
        return _cbcpy.OsiSolverInterface_getBasisStatus(self, cstat, rstat)

    def setBasisStatus(self, cstat, rstat):
        r"""
        Set the status of column and row variables and update
                    the basis factorization and solution.

           Status information should be coded as documented for #getBasisStatus.
           Returns 0 if all goes well, 1 if something goes wrong.

           This method differs from #setWarmStart in the format of the input
           and in its immediate effect. Think of it as #setWarmStart immediately
           followed by #resolve, but no pivots are allowed.

           Notes: 
           Implementors may choose to implement this method as a wrapper that calls
           #setWarmStart and #resolve if the no pivot requirement can be satisfied.
        """
        return _cbcpy.OsiSolverInterface_setBasisStatus(self, cstat, rstat)

    def getReducedGradient(self, columnReducedCosts, duals, c):
        r"""
        Calculate duals and reduced costs for the given objective
             coefficients.

           The solver's objective coefficient vector is not changed.
        """
        return _cbcpy.OsiSolverInterface_getReducedGradient(self, columnReducedCosts, duals, c)

    def getBInvARow(self, row, z, slack=None):
        r"""
        Get a row of the tableau

           If slack is not null, it will be loaded with the coefficients for
           the artificial (logical) variables (i.e., the row of the basis inverse).
        """
        return _cbcpy.OsiSolverInterface_getBInvARow(self, row, z, slack)

    def getBInvRow(self, row, z):
        r""" Get a row of the basis inverse"""
        return _cbcpy.OsiSolverInterface_getBInvRow(self, row, z)

    def getBInvACol(self, col, vec):
        r""" Get a column of the tableau"""
        return _cbcpy.OsiSolverInterface_getBInvACol(self, col, vec)

    def getBInvCol(self, col, vec):
        r""" Get a column of the basis inverse"""
        return _cbcpy.OsiSolverInterface_getBInvCol(self, col, vec)

    def getBasics(self, index):
        r"""
        Get indices of basic variables

           If the logical (artificial) for row i is basic, the index should be coded
           as (#getNumCols + i).
           The order of indices must match the order of elements in the vectors
           returned by #getBInvACol and #getBInvCol.
        """
        return _cbcpy.OsiSolverInterface_getBasics(self, index)

    def enableSimplexInterface(self, doingPrimal):
        r"""
        Enables normal operation of subsequent functions.
             This method is supposed to ensure that all typical things (like
             reduced costs, etc.) are updated when individual pivots are executed
             and can be queried by other methods.  says whether will be
             doing primal or dual
        """
        return _cbcpy.OsiSolverInterface_enableSimplexInterface(self, doingPrimal)

    def disableSimplexInterface(self):
        r"""Undo whatever setting changes the above method had to make"""
        return _cbcpy.OsiSolverInterface_disableSimplexInterface(self)

    def pivot(self, colIn, colOut, outStatus):
        r"""
        Perform a pivot by substituting a colIn for colOut in the basis.
            The status of the leaving variable is given in outStatus. Where
            1 is to upper bound, -1 to lower bound
            Return code was undefined - now for OsiClp is 0 for okay,
            1 if inaccuracy forced re-factorization (should be okay) and
            -1 for singular factorization
        """
        return _cbcpy.OsiSolverInterface_pivot(self, colIn, colOut, outStatus)

    def primalPivotResult(self, colIn, sign, colOut, outStatus, t, dx):
        r"""
        Obtain a result of the primal pivot
             Outputs: colOut -- leaving column, outStatus -- its status,
             t -- step size, and, if dx!=NULL, *dx -- primal ray direction.
             Inputs: colIn -- entering column, sign -- direction of its change (+/-1).
             Both for colIn and colOut, artificial variables are index by
             the negative of the row index minus 1.
             Return code (for now): 0 -- leaving variable found,
             -1 -- everything else?
             Clearly, more informative set of return values is required
             Primal and dual solutions are updated
        """
        return _cbcpy.OsiSolverInterface_primalPivotResult(self, colIn, sign, colOut, outStatus, t, dx)

    def dualPivotResult(self, colIn, sign, colOut, outStatus, t, dx):
        r"""
        Obtain a result of the dual pivot (similar to the previous method)
             Differences: entering variable and a sign of its change are now
             the outputs, the leaving variable and its statuts -- the inputs
             If dx!=NULL, then *dx contains dual ray
             Return code: same
        """
        return _cbcpy.OsiSolverInterface_dualPivotResult(self, colIn, sign, colOut, outStatus, t, dx)

    def clone(self, copyData=True):
        r"""
        Clone

             The result of calling clone(false) is defined to be equivalent to
             calling the default constructor OsiSolverInterface().
        """
        return _cbcpy.OsiSolverInterface_clone(self, copyData)
    __swig_destroy__ = _cbcpy.delete_OsiSolverInterface

    def reset(self):
        r"""
        Reset the solver interface.

           A call to reset() returns the solver interface to the same state as
           it would have if it had just been constructed by calling the default
           constructor OsiSolverInterface().
        """
        return _cbcpy.OsiSolverInterface_reset(self)

# Register OsiSolverInterface in _cbcpy:
_cbcpy.OsiSolverInterface_swigregister(OsiSolverInterface)

class OsiClpSolverInterface(OsiSolverInterface):
    r"""
     Clp Solver Interface

    Instantiation of OsiClpSolverInterface for the Model Algorithm.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def initialSolve(self):
        r""" Solve initial LP relaxation"""
        return _cbcpy.OsiClpSolverInterface_initialSolve(self)

    def resolve(self):
        r""" Resolve an LP relaxation after problem modification"""
        return _cbcpy.OsiClpSolverInterface_resolve(self)

    def resolveGub(self, needed):
        r""" Resolve an LP relaxation after problem modification (try GUB)"""
        return _cbcpy.OsiClpSolverInterface_resolveGub(self, needed)

    def branchAndBound(self):
        r""" Invoke solver's built-in enumeration algorithm"""
        return _cbcpy.OsiClpSolverInterface_branchAndBound(self)

    def crossover(self, options, basis):
        r"""
        Solve when primal column and dual row solutions are near-optimal
             options - 0 no presolve (use primal and dual)
                       1 presolve (just use primal)
        	2 no presolve (just use primal)
             basis -   0 use all slack basis
                       1 try and put some in basis
        """
        return _cbcpy.OsiClpSolverInterface_crossover(self, options, basis)

    def canDoSimplexInterface(self):
        r"""
            Methods for the Osi Simplex API.

         The current implementation should work for both minimisation and
         maximisation in mode 1 (tableau access). In mode 2 (single pivot), only
         minimisation is supported as of 100907.
        Simplex API capability.

         Returns
          - 0 if no simplex API
          - 1 if can just do getBInv etc
          - 2 if has all OsiSimplex methods
        """
        return _cbcpy.OsiClpSolverInterface_canDoSimplexInterface(self)

    def enableFactorization(self):
        r"""
        Enables simplex mode 1 (tableau access)

           Tells solver that calls to getBInv etc are about to take place.
           Underlying code may need mutable as this may be called from
           CglCut::generateCuts which is const.  If that is too horrific then
           each solver e.g. BCP or CBC will have to do something outside
           main loop.
        """
        return _cbcpy.OsiClpSolverInterface_enableFactorization(self)

    def disableFactorization(self):
        r""" Undo any setting changes made by #enableFactorization"""
        return _cbcpy.OsiClpSolverInterface_disableFactorization(self)

    def basisIsAvailable(self):
        r"""
        Returns true if a basis is available
             AND problem is optimal.  This should be used to see if
             the BInvARow type operations are possible and meaningful.
        """
        return _cbcpy.OsiClpSolverInterface_basisIsAvailable(self)

    def getBasisStatus(self, cstat, rstat):
        r"""
        The following two methods may be replaced by the
             methods of OsiSolverInterface using OsiWarmStartBasis if:
             1. OsiWarmStartBasis resize operation is implemented
             more efficiently and
             2. It is ensured that effects on the solver are the same

             Returns a basis status of the structural/artificial variables
             At present as warm start i.e 0 free, 1 basic, 2 upper, 3 lower

             NOTE  artificials are treated as +1 elements so for <= rhs
             artificial will be at lower bound if constraint is tight

             This means that Clpsimplex flips artificials as it works
             in terms of row activities
        """
        return _cbcpy.OsiClpSolverInterface_getBasisStatus(self, cstat, rstat)

    def setBasisStatus(self, cstat, rstat):
        r"""
        Set the status of structural/artificial variables and
             factorize, update solution etc

             NOTE  artificials are treated as +1 elements so for <= rhs
             artificial will be at lower bound if constraint is tight

             This means that Clpsimplex flips artificials as it works
             in terms of row activities
             Returns 0 if OK, 1 if problem is bad e.g. duplicate elements, too large ...
        """
        return _cbcpy.OsiClpSolverInterface_setBasisStatus(self, cstat, rstat)

    def getReducedGradient(self, columnReducedCosts, duals, c):
        r"""Get the reduced gradient for the cost vector c"""
        return _cbcpy.OsiClpSolverInterface_getReducedGradient(self, columnReducedCosts, duals, c)

    def getBInvARow(self, *args):
        r"""
        *Overload 1:*
        Get a row of the tableau (slack part in slack if not NULL)

        |

        *Overload 2:*
         Get a row of the tableau (slack part in slack if not NULL)
              If keepScaled is true then scale factors not applied after so
              user has to use coding similar to what is in this method

        |

        *Overload 3:*
         Get a row of the tableau (slack part in slack if not NULL)
              If keepScaled is true then scale factors not applied after so
              user has to use coding similar to what is in this method

        |

        *Overload 4:*
         Get a row of the tableau (slack part in slack if not NULL)
              If keepScaled is true then scale factors not applied after so
              user has to use coding similar to what is in this method
        """
        return _cbcpy.OsiClpSolverInterface_getBInvARow(self, *args)

    def getBInvRow(self, row, z):
        r"""Get a row of the basis inverse"""
        return _cbcpy.OsiClpSolverInterface_getBInvRow(self, row, z)

    def getBInvACol(self, *args):
        r"""
        *Overload 1:*
        Get a column of the tableau

        |

        *Overload 2:*
        Get a column of the tableau

        |

        *Overload 3:*
         Update (i.e. ftran) the vector passed in.
              Unscaling is applied after - can't be applied before
        """
        return _cbcpy.OsiClpSolverInterface_getBInvACol(self, *args)

    def getBInvCol(self, col, vec):
        r"""Get a column of the basis inverse"""
        return _cbcpy.OsiClpSolverInterface_getBInvCol(self, col, vec)

    def getBasics(self, index):
        r"""
        Get basic indices (order of indices corresponds to the
             order of elements in a vector retured by getBInvACol() and
             getBInvCol()).
        """
        return _cbcpy.OsiClpSolverInterface_getBasics(self, index)

    def enableSimplexInterface(self, doingPrimal):
        r"""
        Enables simplex mode 2 (individual pivot control)

            This method is supposed to ensure that all typical things (like
            reduced costs, etc.) are updated when individual pivots are executed
            and can be queried by other methods.
        """
        return _cbcpy.OsiClpSolverInterface_enableSimplexInterface(self, doingPrimal)

    def disableSimplexInterface(self):
        r""" Undo setting changes made by #enableSimplexInterface"""
        return _cbcpy.OsiClpSolverInterface_disableSimplexInterface(self)

    def pivot(self, colIn, colOut, outStatus):
        r"""
        Perform a pivot by substituting a colIn for colOut in the basis.
             The status of the leaving variable is given in statOut. Where
             1 is to upper bound, -1 to lower bound
             Return code is 0 for okay,
             1 if inaccuracy forced re-factorization (should be okay) and
             -1 for singular factorization
        """
        return _cbcpy.OsiClpSolverInterface_pivot(self, colIn, colOut, outStatus)

    def primalPivotResult(self, colIn, sign, colOut, outStatus, t, dx):
        r"""
        Obtain a result of the primal pivot
             Outputs: colOut -- leaving column, outStatus -- its status,
             t -- step size, and, if dx!=NULL, *dx -- primal ray direction.
             Inputs: colIn -- entering column, sign -- direction of its change (+/-1).
             Both for colIn and colOut, artificial variables are index by
             the negative of the row index minus 1.
             Return code (for now): 0 -- leaving variable found,
             -1 -- everything else?
             Clearly, more informative set of return values is required
             Primal and dual solutions are updated
        """
        return _cbcpy.OsiClpSolverInterface_primalPivotResult(self, colIn, sign, colOut, outStatus, t, dx)

    def dualPivotResult(self, colIn, sign, colOut, outStatus, t, dx):
        r"""
        Obtain a result of the dual pivot (similar to the previous method)
             Differences: entering variable and a sign of its change are now
             the outputs, the leaving variable and its statuts -- the inputs
             If dx!=NULL, then *dx contains dual ray
             Return code: same
        """
        return _cbcpy.OsiClpSolverInterface_dualPivotResult(self, colIn, sign, colOut, outStatus, t, dx)

    def setIntParam(self, key, value):
        return _cbcpy.OsiClpSolverInterface_setIntParam(self, key, value)

    def setDblParam(self, key, value):
        return _cbcpy.OsiClpSolverInterface_setDblParam(self, key, value)

    def setStrParam(self, key, value):
        return _cbcpy.OsiClpSolverInterface_setStrParam(self, key, value)

    def getIntParam(self, key, value):
        return _cbcpy.OsiClpSolverInterface_getIntParam(self, key, value)

    def getDblParam(self, key, value):
        return _cbcpy.OsiClpSolverInterface_getDblParam(self, key, value)

    def getStrParam(self, key, value):
        return _cbcpy.OsiClpSolverInterface_getStrParam(self, key, value)

    def setHintParam(self, *args):
        return _cbcpy.OsiClpSolverInterface_setHintParam(self, *args)

    def isAbandoned(self):
        r""" Are there a numerical difficulties?"""
        return _cbcpy.OsiClpSolverInterface_isAbandoned(self)

    def isProvenOptimal(self):
        r""" Is optimality proven?"""
        return _cbcpy.OsiClpSolverInterface_isProvenOptimal(self)

    def isProvenPrimalInfeasible(self):
        r""" Is primal infeasiblity proven?"""
        return _cbcpy.OsiClpSolverInterface_isProvenPrimalInfeasible(self)

    def isProvenDualInfeasible(self):
        r""" Is dual infeasiblity proven?"""
        return _cbcpy.OsiClpSolverInterface_isProvenDualInfeasible(self)

    def isPrimalObjectiveLimitReached(self):
        r""" Is the given primal objective limit reached?"""
        return _cbcpy.OsiClpSolverInterface_isPrimalObjectiveLimitReached(self)

    def isDualObjectiveLimitReached(self):
        r""" Is the given dual objective limit reached?"""
        return _cbcpy.OsiClpSolverInterface_isDualObjectiveLimitReached(self)

    def isIterationLimitReached(self):
        r""" Iteration limit reached?"""
        return _cbcpy.OsiClpSolverInterface_isIterationLimitReached(self)

    def getEmptyWarmStart(self):
        r"""
        Get an empty warm start object

         This routine returns an empty CoinWarmStartBasis object. Its purpose is
         to provide a way to give a client a warm start basis object of the
         appropriate type, which can resized and modified as desired.
        """
        return _cbcpy.OsiClpSolverInterface_getEmptyWarmStart(self)

    def getWarmStart(self):
        r""" Get warmstarting information"""
        return _cbcpy.OsiClpSolverInterface_getWarmStart(self)

    def getConstPointerToWarmStart(self):
        r""" Get warmstarting information"""
        return _cbcpy.OsiClpSolverInterface_getConstPointerToWarmStart(self)

    def setWarmStart(self, warmstart):
        r"""
        Set warmstarting information. Return true/false depending on whether
             the warmstart information was accepted or not.
        """
        return _cbcpy.OsiClpSolverInterface_setWarmStart(self, warmstart)

    def getPointerToWarmStart(self, *args):
        r"""
        *Overload 1:*
        Get warmstarting information

        |

        *Overload 2:*
        Get warm start information.

             Return warm start information for the current state of the solver
             interface. If there is no valid warm start information, an empty warm
             start object wil be returned.  This does not necessarily create an
             object - may just point to one.  must Delete set true if user
             should delete returned object.
             OsiClp version always returns pointer and false.
        """
        return _cbcpy.OsiClpSolverInterface_getPointerToWarmStart(self, *args)

    def setColumnStatus(self, iColumn, status):
        r""" Set column status in ClpSimplex and warmStart"""
        return _cbcpy.OsiClpSolverInterface_setColumnStatus(self, iColumn, status)

    def markHotStart(self):
        r""" Create a hotstart point of the optimization process"""
        return _cbcpy.OsiClpSolverInterface_markHotStart(self)

    def solveFromHotStart(self):
        r""" Optimize starting from the hotstart"""
        return _cbcpy.OsiClpSolverInterface_solveFromHotStart(self)

    def unmarkHotStart(self):
        r""" Delete the snapshot"""
        return _cbcpy.OsiClpSolverInterface_unmarkHotStart(self)

    def startFastDual(self, options):
        r"""
        Start faster dual - returns negative if problems 1 if infeasible,
             Options to pass to solver
             1 - create external reduced costs for columns
             2 - create external reduced costs for rows
             4 - create external row activity (columns always done)
             Above only done if feasible
             When set resolve does less work
        """
        return _cbcpy.OsiClpSolverInterface_startFastDual(self, options)

    def stopFastDual(self):
        r""" Stop fast dual"""
        return _cbcpy.OsiClpSolverInterface_stopFastDual(self)

    def setStuff(self, tolerance, increment):
        r""" Sets integer tolerance and increment"""
        return _cbcpy.OsiClpSolverInterface_setStuff(self, tolerance, increment)

    def getNumCols(self):
        r""" Get number of columns"""
        return _cbcpy.OsiClpSolverInterface_getNumCols(self)

    def getNumRows(self):
        r""" Get number of rows"""
        return _cbcpy.OsiClpSolverInterface_getNumRows(self)

    def getNumElements(self):
        r""" Get number of nonzero elements"""
        return _cbcpy.OsiClpSolverInterface_getNumElements(self)

    def getRowName(self, *args):
        r""" Return name of row if one exists or Rnnnnnnn maxLen is currently ignored and only there to match the signature from the base class!"""
        return _cbcpy.OsiClpSolverInterface_getRowName(self, *args)

    def getColName(self, *args):
        r""" Return name of column if one exists or Cnnnnnnn maxLen is currently ignored and only there to match the signature from the base class!"""
        return _cbcpy.OsiClpSolverInterface_getColName(self, *args)

    def getColLower(self):
        r""" Get pointer to array[getNumCols()] of column lower bounds"""
        return _cbcpy.OsiClpSolverInterface_getColLower(self)

    def getColUpper(self):
        r""" Get pointer to array[getNumCols()] of column upper bounds"""
        return _cbcpy.OsiClpSolverInterface_getColUpper(self)

    def getRowSense(self):
        r"""
        Get pointer to array[getNumRows()] of row constraint senses.

             * 'L' <= constraint
             * 'E' =  constraint
             * 'G' >= constraint
             * 'R' ranged constraint
             * 'N' free constraint

        """
        return _cbcpy.OsiClpSolverInterface_getRowSense(self)

    def getRightHandSide(self):
        r"""
        Get pointer to array[getNumRows()] of rows right-hand sides

             *  if rowsense()[i] == 'L' then rhs()[i] == rowupper()[i]
             *  if rowsense()[i] == 'G' then rhs()[i] == rowlower()[i]
             *  if rowsense()[i] == 'R' then rhs()[i] == rowupper()[i]
             *  if rowsense()[i] == 'N' then rhs()[i] == 0.0

        """
        return _cbcpy.OsiClpSolverInterface_getRightHandSide(self)

    def getRowRange(self):
        r"""
        Get pointer to array[getNumRows()] of row ranges.

             *  if rowsense()[i] == 'R' then
             rowrange()[i] == rowupper()[i] - rowlower()[i]
             *  if rowsense()[i] != 'R' then
             rowrange()[i] is undefined

        """
        return _cbcpy.OsiClpSolverInterface_getRowRange(self)

    def getRowLower(self):
        r""" Get pointer to array[getNumRows()] of row lower bounds"""
        return _cbcpy.OsiClpSolverInterface_getRowLower(self)

    def getRowUpper(self):
        r""" Get pointer to array[getNumRows()] of row upper bounds"""
        return _cbcpy.OsiClpSolverInterface_getRowUpper(self)

    def getObjCoefficients(self):
        r""" Get pointer to array[getNumCols()] of objective function coefficients"""
        return _cbcpy.OsiClpSolverInterface_getObjCoefficients(self)

    def getObjSense(self):
        r""" Get objective function sense (1 for min (default), -1 for max)"""
        return _cbcpy.OsiClpSolverInterface_getObjSense(self)

    def isContinuous(self, colNumber):
        r""" Return true if column is continuous"""
        return _cbcpy.OsiClpSolverInterface_isContinuous(self, colNumber)

    def isBinary(self, colIndex):
        r""" Return true if variable is binary"""
        return _cbcpy.OsiClpSolverInterface_isBinary(self, colIndex)

    def isInteger(self, colIndex):
        r"""
        Return true if column is integer.
             Note: This function returns true if the the column
             is binary or a general integer.
        """
        return _cbcpy.OsiClpSolverInterface_isInteger(self, colIndex)

    def isIntegerNonBinary(self, colIndex):
        r""" Return true if variable is general integer"""
        return _cbcpy.OsiClpSolverInterface_isIntegerNonBinary(self, colIndex)

    def isFreeBinary(self, colIndex):
        r""" Return true if variable is binary and not fixed at either bound"""
        return _cbcpy.OsiClpSolverInterface_isFreeBinary(self, colIndex)

    def getColType(self, refresh=False):
        r"""
        Return array of column length
             0 - continuous
             1 - binary (may get fixed later)
             2 - general integer (may get fixed later)
        """
        return _cbcpy.OsiClpSolverInterface_getColType(self, refresh)

    def isOptionalInteger(self, colIndex):
        r"""
        Return true if column is integer but does not have to
             be declared as such.
             Note: This function returns true if the the column
             is binary or a general integer.
        """
        return _cbcpy.OsiClpSolverInterface_isOptionalInteger(self, colIndex)

    def setOptionalInteger(self, index):
        r""" Set the index-th variable to be an optional integer variable"""
        return _cbcpy.OsiClpSolverInterface_setOptionalInteger(self, index)

    def isHeuristicInteger(self, colIndex):
        r""" Return true only if integer and not optional"""
        return _cbcpy.OsiClpSolverInterface_isHeuristicInteger(self, colIndex)

    def integerType(self, colIndex):
        r""" Return integer type (0,1,2=optional,3=sc,4=scint)"""
        return _cbcpy.OsiClpSolverInterface_integerType(self, colIndex)

    def setIntegerType(self, colIndex, value):
        r""" Set integer type (0,1,2=optional,3=sc,4=scint)"""
        return _cbcpy.OsiClpSolverInterface_setIntegerType(self, colIndex, value)

    def getMatrixByRow(self):
        r""" Get pointer to row-wise copy of matrix"""
        return _cbcpy.OsiClpSolverInterface_getMatrixByRow(self)

    def getMatrixByCol(self):
        r""" Get pointer to column-wise copy of matrix"""
        return _cbcpy.OsiClpSolverInterface_getMatrixByCol(self)

    def getMutableMatrixByCol(self):
        r""" Get pointer to mutable column-wise copy of matrix"""
        return _cbcpy.OsiClpSolverInterface_getMutableMatrixByCol(self)

    def getInfinity(self):
        r""" Get solver's value for infinity"""
        return _cbcpy.OsiClpSolverInterface_getInfinity(self)

    def getColSolution(self):
        r""" Get pointer to array[getNumCols()] of primal solution vector"""
        return _cbcpy.OsiClpSolverInterface_getColSolution(self)

    def getRowPrice(self):
        r""" Get pointer to array[getNumRows()] of dual prices"""
        return _cbcpy.OsiClpSolverInterface_getRowPrice(self)

    def getReducedCost(self):
        r""" Get a pointer to array[getNumCols()] of reduced costs"""
        return _cbcpy.OsiClpSolverInterface_getReducedCost(self)

    def getRowActivity(self):
        r"""
        Get pointer to array[getNumRows()] of row activity levels (constraint
             matrix times the solution vector
        """
        return _cbcpy.OsiClpSolverInterface_getRowActivity(self)

    def getObjValue(self):
        r""" Get objective function value"""
        return _cbcpy.OsiClpSolverInterface_getObjValue(self)

    def getIterationCount(self):
        r"""
        Get how many iterations it took to solve the problem (whatever
             "iteration" mean to the solver.
        """
        return _cbcpy.OsiClpSolverInterface_getIterationCount(self)

    def getDualRays(self, maxNumRays, fullRay=False):
        r"""
        Get as many dual rays as the solver can provide. (In case of proven
             primal infeasibility there should be at least one.)

             The first getNumRows() ray components will always be associated with
             the row duals (as returned by getRowPrice()). If ``fullRay`` is true,
             the final getNumCols() entries will correspond to the ray components
             associated with the nonbasic variables. If the full ray is requested
             and the method cannot provide it, it will throw an exception.

             **NOTE for implementers of solver interfaces:** 

             The double pointers in the vector should point to arrays of length
             getNumRows() and they should be allocated via new[]. 


             **NOTE for users of solver interfaces:** 

             It is the user's responsibility to free the double pointers in the
             vector using delete[].
        """
        return _cbcpy.OsiClpSolverInterface_getDualRays(self, maxNumRays, fullRay)

    def getPrimalRays(self, maxNumRays):
        r"""
        Get as many primal rays as the solver can provide. (In case of proven
             dual infeasibility there should be at least one.)

             **NOTE for implementers of solver interfaces:** 

             The double pointers in the vector should point to arrays of length
             getNumCols() and they should be allocated via new[]. 


             **NOTE for users of solver interfaces:** 

             It is the user's responsibility to free the double pointers in the
             vector using delete[].
        """
        return _cbcpy.OsiClpSolverInterface_getPrimalRays(self, maxNumRays)

    def setObjCoeff(self, elementIndex, elementValue):
        r""" Set an objective function coefficient"""
        return _cbcpy.OsiClpSolverInterface_setObjCoeff(self, elementIndex, elementValue)

    def setColBounds(self, elementIndex, lower, upper):
        r""" Set a single column lower and upper bound"""
        return _cbcpy.OsiClpSolverInterface_setColBounds(self, elementIndex, lower, upper)

    def setColSetBounds(self, indexFirst, indexLast, boundList):
        r"""
        Set the bounds on a number of columns simultaneously

             The default implementation just invokes setColLower() and
             setColUpper() over and over again.
             :param indexFirst,indexLast: pointers to the beginning and after the
                 end of the array of the indices of the variables whose
                 **either** bound changes
             :type boundList: float
             :param boundList: the new lower/upper bound pairs for the variables
        """
        return _cbcpy.OsiClpSolverInterface_setColSetBounds(self, indexFirst, indexLast, boundList)

    def setRowLower(self, elementIndex, elementValue):
        r"""
        Set a single row lower bound

             Use -DBL_MAX for -infinity.
        """
        return _cbcpy.OsiClpSolverInterface_setRowLower(self, elementIndex, elementValue)

    def setRowUpper(self, elementIndex, elementValue):
        r"""
        Set a single row upper bound

             Use DBL_MAX for infinity.
        """
        return _cbcpy.OsiClpSolverInterface_setRowUpper(self, elementIndex, elementValue)

    def setRowBounds(self, elementIndex, lower, upper):
        r""" Set a single row lower and upper bound"""
        return _cbcpy.OsiClpSolverInterface_setRowBounds(self, elementIndex, lower, upper)

    def setRowType(self, index, sense, rightHandSide, range):
        r"""
        Set the type of a single row

        """
        return _cbcpy.OsiClpSolverInterface_setRowType(self, index, sense, rightHandSide, range)

    def setRowSetBounds(self, indexFirst, indexLast, boundList):
        r"""
        Set the bounds on a number of rows simultaneously

             The default implementation just invokes setRowLower() and
             setRowUpper() over and over again.
             :param indexFirst,indexLast: pointers to the beginning and after the
                 end of the array of the indices of the constraints whose
                 **either** bound changes
             :type boundList: float
             :param boundList: the new lower/upper bound pairs for the constraints
        """
        return _cbcpy.OsiClpSolverInterface_setRowSetBounds(self, indexFirst, indexLast, boundList)

    def setRowSetTypes(self, indexFirst, indexLast, senseList, rhsList, rangeList):
        r"""
        Set the type of a number of rows simultaneously

             The default implementation just invokes setRowType()
             over and over again.
             :param indexFirst,indexLast: pointers to the beginning and after the
                 end of the array of the indices of the constraints whose
                 **any** characteristics changes
             :type senseList: string
             :param senseList: the new senses
             :type rhsList: float
             :param rhsList:   the new right hand sides
             :type rangeList: float
             :param rangeList: the new ranges
        """
        return _cbcpy.OsiClpSolverInterface_setRowSetTypes(self, indexFirst, indexLast, senseList, rhsList, rangeList)

    def setObjective(self, array):
        r"""
        Set the objective coefficients for all columns
        array [getNumCols()] is an array of values for the objective.
               This defaults to a series of set operations and is here for speed.
        """
        return _cbcpy.OsiClpSolverInterface_setObjective(self, array)

    def setColLower(self, *args):
        r"""
        *Overload 1:*
         Set a single column lower bound

              Use -DBL_MAX for -infinity.

        |

        *Overload 2:*
         Set the lower bounds for all columns
        	array [getNumCols()] is an array of values for the objective.
                This defaults to a series of set operations and is here for speed.
        """
        return _cbcpy.OsiClpSolverInterface_setColLower(self, *args)

    def setColUpper(self, *args):
        r"""
        *Overload 1:*
         Set a single column upper bound

              Use DBL_MAX for infinity.

        |

        *Overload 2:*
         Set the upper bounds for all columns
        	array [getNumCols()] is an array of values for the objective.
                This defaults to a series of set operations and is here for speed.
        """
        return _cbcpy.OsiClpSolverInterface_setColUpper(self, *args)

    def setRowName(self, rowIndex, name):
        r""" Set name of row"""
        return _cbcpy.OsiClpSolverInterface_setRowName(self, rowIndex, name)

    def setColName(self, colIndex, name):
        r""" Set name of column"""
        return _cbcpy.OsiClpSolverInterface_setColName(self, colIndex, name)

    def setContinuous(self, *args):
        r"""
        *Overload 1:*
        Set the index-th variable to be a continuous variable

        |

        *Overload 2:*
        Set the variables listed in indices (which is of length len) to be
             continuous variables
        """
        return _cbcpy.OsiClpSolverInterface_setContinuous(self, *args)

    def setInteger(self, *args):
        r"""
        *Overload 1:*
        Set the index-th variable to be an integer variable

        |

        *Overload 2:*
        Set the variables listed in indices (which is of length len) to be
             integer variables
        """
        return _cbcpy.OsiClpSolverInterface_setInteger(self, *args)

    def numberSOS(self):
        r""" Number of SOS sets"""
        return _cbcpy.OsiClpSolverInterface_numberSOS(self)

    def setInfo(self):
        r""" SOS set info"""
        return _cbcpy.OsiClpSolverInterface_setInfo(self)

    def replaceSetInfo(self, numberSOS, setInfo):
        r""" Replace setInfo (takes over ownership)"""
        return _cbcpy.OsiClpSolverInterface_replaceSetInfo(self, numberSOS, setInfo)

    def findIntegersAndSOS(self, justCount):
        r"""
        Identify integer variables and SOS and create corresponding objects.

           Record integer variables and create an OsiSimpleInteger object for each
           one.  All existing OsiSimpleInteger objects will be destroyed.
           If the solver supports SOS then do the same for SOS.
            If justCount then no objects created and we just store numberIntegers_
           Returns number of SOS
        """
        return _cbcpy.OsiClpSolverInterface_findIntegersAndSOS(self, justCount)

    def setObjSense(self, s):
        r""" Set objective function sense (1 for min (default), -1 for max,)"""
        return _cbcpy.OsiClpSolverInterface_setObjSense(self, s)

    def setColSolution(self, colsol):
        r"""
        Set the primal solution column values

         colsol[numcols()] is an array of values of the problem column
         variables. These values are copied to memory owned by the
         solver object or the solver.  They will be returned as the
         result of colsol() until changed by another call to
         setColsol() or by a call to any solver routine.  Whether the
         solver makes use of the solution in any way is
         solver-dependent.
        """
        return _cbcpy.OsiClpSolverInterface_setColSolution(self, colsol)

    def setRowPrice(self, rowprice):
        r"""
        Set dual solution vector

         rowprice[numrows()] is an array of values of the problem row
         dual variables. These values are copied to memory owned by the
         solver object or the solver.  They will be returned as the
         result of rowprice() until changed by another call to
         setRowprice() or by a call to any solver routine.  Whether the
         solver makes use of the solution in any way is
         solver-dependent.
        """
        return _cbcpy.OsiClpSolverInterface_setRowPrice(self, rowprice)

    def addCol(self, *args):
        r"""
        *Overload 1:*

        |

        *Overload 2:*
        Add a named column (primal variable) to the problem.

        |

        *Overload 3:*
        Add a column (primal variable) to the problem.

        |

        *Overload 4:*
        Add a named column (primal variable) to the problem.
        """
        return _cbcpy.OsiClpSolverInterface_addCol(self, *args)

    def addCols(self, *args):
        r"""
        *Overload 1:*

        |

        *Overload 2:*
        """
        return _cbcpy.OsiClpSolverInterface_addCols(self, *args)

    def deleteCols(self, num, colIndices):
        
        return _cbcpy.OsiClpSolverInterface_deleteCols(self, num, colIndices)

    def addRow(self, *args):
        r"""
        *Overload 1:*

        |

        *Overload 2:*
         Add a named row (constraint) to the problem.

             The default implementation adds the row, then changes the name. This
             can surely be made more efficient within an OsiXXX class.

        |

        *Overload 3:*
        Add a row (constraint) to the problem.

        |

        *Overload 4:*
        Add a named row (constraint) to the problem.
        """
        return _cbcpy.OsiClpSolverInterface_addRow(self, *args)

    def addRows(self, *args):
        r"""
        *Overload 1:*

        |

        *Overload 2:*

        |

        *Overload 3:*
        """
        return _cbcpy.OsiClpSolverInterface_addRows(self, *args)

    def modifyCoefficient(self, row, column, newElement, keepZero=False):
        return _cbcpy.OsiClpSolverInterface_modifyCoefficient(self, row, column, newElement, keepZero)

    def deleteRows(self, num, rowIndices):
        
        return _cbcpy.OsiClpSolverInterface_deleteRows(self, num, rowIndices)

    def saveBaseModel(self):
        r"""  If solver wants it can save a copy of "base" (continuous) model here"""
        return _cbcpy.OsiClpSolverInterface_saveBaseModel(self)

    def restoreBaseModel(self, numberRows):
        r"""
        Strip off rows to get to this number of rows.
             If solver wants it can restore a copy of "base" (continuous) model here
        """
        return _cbcpy.OsiClpSolverInterface_restoreBaseModel(self, numberRows)

    def applyRowCuts(self, *args):
        r"""
        *Overload 1:*
        Apply a collection of row cuts which are all effective.
             applyCuts seems to do one at a time which seems inefficient.

        |

        *Overload 2:*
        Apply a collection of row cuts which are all effective.
             applyCuts seems to do one at a time which seems inefficient.
             This uses array of pointers
        """
        return _cbcpy.OsiClpSolverInterface_applyRowCuts(self, *args)

    def applyCuts(self, cs, effectivenessLb=0.0):
        r"""
        Apply a collection of cuts.

        Only cuts which have an ``effectiveness >= effectivenessLb``
        are applied.

          *  ReturnCode.getNumineffective() -- number of cuts which were
               not applied because they had an
               ``effectiveness < effectivenessLb``
          *  ReturnCode.getNuminconsistent() -- number of invalid cuts
          *  ReturnCode.getNuminconsistentWrtIntegerModel() -- number of
               cuts that are invalid with respect to this integer model
          *  ReturnCode.getNuminfeasible() -- number of cuts that would
               make this integer model infeasible
          *  ReturnCode.getNumApplied() -- number of integer cuts which
               were applied to the integer model
          *  cs.size() == getNumineffective() +
        		    getNuminconsistent() +
        		    getNuminconsistentWrtIntegerModel() +
        		    getNuminfeasible() +
        		    getNumApplied()

        """
        return _cbcpy.OsiClpSolverInterface_applyCuts(self, cs, effectivenessLb)

    def assignProblem(self, *args):
        r"""
        *Overload 1:*
        Load in an problem by assuming ownership of the arguments (the
             constraints on the rows are given by lower and upper bounds). For
             default values see the previous method.  

             **WARNING**: The arguments passed to this method will be
             freed using the C++ ``delete`` and ``delete[]``
             functions.

        |

        *Overload 2:*
        Load in an problem by assuming ownership of the arguments (the
             constraints on the rows are given by sense/rhs/range triplets). For
             default values see the previous method. 

             **WARNING**: The arguments passed to this method will be
             freed using the C++ ``delete`` and ``delete[]``
             functions.
        """
        return _cbcpy.OsiClpSolverInterface_assignProblem(self, *args)

    def loadProblem(self, *args):
        r"""
        *Overload 1:*
        Load in an problem by copying the arguments (the constraints on the
             rows are given by lower and upper bounds). If a pointer is NULL then the
             following values are the default:

             *  ``colub``: all columns have upper bound infinity
             *  ``collb``: all columns have lower bound 0
             *  ``rowub``: all rows have upper bound infinity
             *  ``rowlb``: all rows have lower bound -infinity
             *  ``obj``: all variables have 0 objective coefficient


        |

        *Overload 2:*
        Load in an problem by copying the arguments (the constraints on the
             rows are given by sense/rhs/range triplets). If a pointer is NULL then the
             following values are the default:

             *  ``colub``: all columns have upper bound infinity
             *  ``collb``: all columns have lower bound 0
             *  ``obj``: all variables have 0 objective coefficient
             *  ``rowsen``: all rows are >=
             *  ``rowrhs``: all right hand sides are 0
             *  ``rowrng``: 0 for the ranged rows


        |

        *Overload 3:*
        Just like the other loadProblem() methods except that the matrix is
             given as a ClpMatrixBase.

        |

        *Overload 4:*
        Just like the other loadProblem() methods except that the matrix is
             given in a standard column major ordered format (without gaps).

        |

        *Overload 5:*
        Just like the other loadProblem() methods except that the matrix is
             given in a standard column major ordered format (without gaps).
        """
        return _cbcpy.OsiClpSolverInterface_loadProblem(self, *args)

    def loadFromCoinModel(self, modelObject, keepSolution=False):
        r""" This loads a model from a coinModel object - returns number of errors"""
        return _cbcpy.OsiClpSolverInterface_loadFromCoinModel(self, modelObject, keepSolution)

    def readMps(self, *args):
        r"""
        *Overload 1:*
        Read an mps file from the given filename (defaults to Osi reader) - returns
             number of errors (see OsiMpsReader class)

        |

        *Overload 2:*
        Read an mps file from the given filename returns
             number of errors (see OsiMpsReader class)

        |

        *Overload 3:*
        Read an mps file
        """
        return _cbcpy.OsiClpSolverInterface_readMps(self, *args)

    def writeMps(self, *args):
        r"""
        Write the problem into an mps file of the given filename.
             If objSense is non zero then -1.0 forces the code to write a
             maximization objective and +1.0 to write a minimization one.
             If 0.0 then solver can do what it wants
        """
        return _cbcpy.OsiClpSolverInterface_writeMps(self, *args)

    def writeMpsNative(self, filename, rowNames, columnNames, formatType=0, numberAcross=2, objSense=0.0):
        r"""
        Write the problem into an mps file of the given filename,
             names may be null.  formatType is
             0 - normal
             1 - extra accuracy
             2 - IEEE hex (later)

             Returns non-zero on I/O error
        """
        return _cbcpy.OsiClpSolverInterface_writeMpsNative(self, filename, rowNames, columnNames, formatType, numberAcross, objSense)

    def readLp(self, filename, epsilon=1e-5):
        r""" Read file in LP format (with names)"""
        return _cbcpy.OsiClpSolverInterface_readLp(self, filename, epsilon)

    def writeLp(self, *args):
        r"""
        *Overload 1:*
        Write the problem into an Lp file of the given filename.
             If objSense is non zero then -1.0 forces the code to write a
             maximization objective and +1.0 to write a minimization one.
             If 0.0 then solver can do what it wants.
             This version calls writeLpNative with names

        |

        *Overload 2:*
        Write the problem into the file pointed to by the parameter fp.
             Other parameters are similar to
             those of writeLp() with first parameter filename.

        |

        *Overload 3:*
        Write the problem into the file pointed to by the parameter fp.
             Other parameters are similar to
             those of writeLp() with first parameter filename.

        |

        *Overload 4:*
        Write the problem into the file pointed to by the parameter fp.
             Other parameters are similar to
             those of writeLp() with first parameter filename.

        |

        *Overload 5:*
        Write the problem into the file pointed to by the parameter fp.
             Other parameters are similar to
             those of writeLp() with first parameter filename.

        |

        *Overload 6:*
        Write the problem into the file pointed to by the parameter fp.
             Other parameters are similar to
             those of writeLp() with first parameter filename.

        |

        *Overload 7:*
        Write the problem into the file pointed to by the parameter fp.
             Other parameters are similar to
             those of writeLp() with first parameter filename.
        """
        return _cbcpy.OsiClpSolverInterface_writeLp(self, *args)

    def replaceMatrixOptional(self, matrix):
        r"""

        I (JJF) am getting annoyed because I can't just replace a matrix.
        The default behavior of this is do nothing so only use where that would not matter
        e.g. strengthening a matrix for MIP
        """
        return _cbcpy.OsiClpSolverInterface_replaceMatrixOptional(self, matrix)

    def replaceMatrix(self, matrix):
        r""" And if it does matter (not used at present)"""
        return _cbcpy.OsiClpSolverInterface_replaceMatrix(self, matrix)

    def passInMessageHandler(self, handler):
        r"""
        Pass in a message handler

             It is the client's responsibility to destroy a message handler installed
             by this routine; it will not be destroyed when the solver interface is
             destroyed.
        """
        return _cbcpy.OsiClpSolverInterface_passInMessageHandler(self, handler)

    def newLanguage(self, language):
        r""" Set language"""
        return _cbcpy.OsiClpSolverInterface_newLanguage(self, language)

    def setLanguage(self, language):
        return _cbcpy.OsiClpSolverInterface_setLanguage(self, language)

    def setLogLevel(self, value):
        r""" Set log level (will also set underlying solver's log level)"""
        return _cbcpy.OsiClpSolverInterface_setLogLevel(self, value)

    def generateCpp(self, fp):
        r""" Create C++ lines to get to current state"""
        return _cbcpy.OsiClpSolverInterface_generateCpp(self, fp)

    def getModelPtr(self):
        r""" Get pointer to Clp model"""
        return _cbcpy.OsiClpSolverInterface_getModelPtr(self)

    def swapModelPtr(self, newModel):
        r""" Set pointer to Clp model and return old"""
        return _cbcpy.OsiClpSolverInterface_swapModelPtr(self, newModel)

    def specialOptions(self):
        r""" Get special options"""
        return _cbcpy.OsiClpSolverInterface_specialOptions(self)

    def setSpecialOptions(self, value):
        return _cbcpy.OsiClpSolverInterface_setSpecialOptions(self, value)

    def lastAlgorithm(self):
        r""" Last algorithm used , 1 = primal, 2 = dual other unknown"""
        return _cbcpy.OsiClpSolverInterface_lastAlgorithm(self)

    def setLastAlgorithm(self, value):
        r""" Set last algorithm used , 1 = primal, 2 = dual other unknown"""
        return _cbcpy.OsiClpSolverInterface_setLastAlgorithm(self, value)

    def cleanupScaling(self):
        r""" Get scaling action option"""
        return _cbcpy.OsiClpSolverInterface_cleanupScaling(self)

    def setCleanupScaling(self, value):
        r"""
        Set Scaling option
             When scaling is on it is possible that the scaled problem
             is feasible but the unscaled is not.  Clp returns a secondary
             status code to that effect.  This option allows for a cleanup.
             If you use it I would suggest 1.
             This only affects actions when scaled optimal
             0 - no action
             1 - clean up using dual if primal infeasibility
             2 - clean up using dual if dual infeasibility
             3 - clean up using dual if primal or dual infeasibility
             11,12,13 - as 1,2,3 but use primal
        """
        return _cbcpy.OsiClpSolverInterface_setCleanupScaling(self, value)

    def smallestElementInCut(self):
        r"""
        Get smallest allowed element in cut.
             If smaller than this then ignored
        """
        return _cbcpy.OsiClpSolverInterface_smallestElementInCut(self)

    def setSmallestElementInCut(self, value):
        r"""
        Set smallest allowed element in cut.
             If smaller than this then ignored
        """
        return _cbcpy.OsiClpSolverInterface_setSmallestElementInCut(self, value)

    def smallestChangeInCut(self):
        r"""
        Get smallest change in cut.
             If (upper-lower)*element < this then element is
             taken out and cut relaxed.
             (upper-lower) is taken to be at least 1.0 and
             this is assumed >= smallestElementInCut_
        """
        return _cbcpy.OsiClpSolverInterface_smallestChangeInCut(self)

    def setSmallestChangeInCut(self, value):
        r"""
        Set smallest change in cut.
             If (upper-lower)*element < this then element is
             taken out and cut relaxed.
             (upper-lower) is taken to be at least 1.0 and
             this is assumed >= smallestElementInCut_
        """
        return _cbcpy.OsiClpSolverInterface_setSmallestChangeInCut(self, value)

    def setSolveOptions(self, options):
        r""" Pass in initial solve options"""
        return _cbcpy.OsiClpSolverInterface_setSolveOptions(self, options)

    def tightenBounds(self, lightweight=0):
        r"""
        Tighten bounds - lightweight or very lightweight
             0 - normal, 1 lightweight but just integers, 2 lightweight and all
        """
        return _cbcpy.OsiClpSolverInterface_tightenBounds(self, lightweight)

    def infeasibleOtherWay(self, whichWay):
        r""" See if any integer variables make infeasible other way"""
        return _cbcpy.OsiClpSolverInterface_infeasibleOtherWay(self, whichWay)

    def getSizeL(self):
        r""" Return number of entries in L part of current factorization"""
        return _cbcpy.OsiClpSolverInterface_getSizeL(self)

    def getSizeU(self):
        r""" Return number of entries in U part of current factorization"""
        return _cbcpy.OsiClpSolverInterface_getSizeU(self)

    def disasterHandler(self):
        r""" Get disaster handler"""
        return _cbcpy.OsiClpSolverInterface_disasterHandler(self)

    def passInDisasterHandler(self, handler):
        r""" Pass in disaster handler"""
        return _cbcpy.OsiClpSolverInterface_passInDisasterHandler(self, handler)

    def fakeObjective(self):
        r""" Get fake objective"""
        return _cbcpy.OsiClpSolverInterface_fakeObjective(self)

    def setFakeObjective(self, *args):
        r"""
        *Overload 1:*
        Set fake objective (and take ownership)

        |

        *Overload 2:*
        Set fake objective
        """
        return _cbcpy.OsiClpSolverInterface_setFakeObjective(self, *args)

    def setupForRepeatedUse(self, senseOfAdventure=0, printOut=0):
        r"""
        Set up solver for repeated use by Osi interface.

           The normal usage does things like keeping factorization around so can be
           used.  Will also do things like keep scaling and row copy of matrix if
           matrix does not change.

           senseOfAdventure:
           - 0 - safe stuff as above
           - 1 - will take more risks - if it does not work then bug which will be
                 fixed
           - 2 - don't bother doing most extreme termination checks e.g. don't bother
          re-factorizing if less than 20 iterations.
           - 3 - Actually safer than 1 (mainly just keeps factorization)

           printOut
           - -1 always skip round common messages instead of doing some work
           -  0 skip if normal defaults
           -  1 leaves
        """
        return _cbcpy.OsiClpSolverInterface_setupForRepeatedUse(self, senseOfAdventure, printOut)

    def synchronizeModel(self):
        r""" Synchronize model (really if no cuts in tree)"""
        return _cbcpy.OsiClpSolverInterface_synchronizeModel(self)

    def setSpecialOptionsMutable(self, value):
        r"""
        Set special options in underlying clp solver.

           Safe as const because #modelPtr_ is mutable.
        """
        return _cbcpy.OsiClpSolverInterface_setSpecialOptionsMutable(self, value)

    def clone(self, copyData=True):
        r""" Clone"""
        return _cbcpy.OsiClpSolverInterface_clone(self, copyData)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default Constructor

        |

        *Overload 2:*
        Copy constructor

        |

        *Overload 3:*
        Borrow constructor - only delete one copy

        |

        *Overload 4:*
        Borrow constructor - only delete one copy
        """
        _cbcpy.OsiClpSolverInterface_swiginit(self, _cbcpy.new_OsiClpSolverInterface(*args))

    def releaseClp(self):
        r""" Releases so won't error"""
        return _cbcpy.OsiClpSolverInterface_releaseClp(self)
    __swig_destroy__ = _cbcpy.delete_OsiClpSolverInterface

    def reset(self):
        r""" Resets as if default constructor"""
        return _cbcpy.OsiClpSolverInterface_reset(self)

    def setBasis(self, *args):
        r"""
        *Overload 1:*
        Sets up working basis as a copy of input and puts in as basis

        |

        *Overload 2:*
        Just puts current basis_ into ClpSimplex model
        """
        return _cbcpy.OsiClpSolverInterface_setBasis(self, *args)

    def getBasisDiff(self, statusArray):
        r""" Warm start difference from basis_ to statusArray"""
        return _cbcpy.OsiClpSolverInterface_getBasisDiff(self, statusArray)

    def getBasis(self, statusArray):
        r""" Warm start from statusArray"""
        return _cbcpy.OsiClpSolverInterface_getBasis(self, statusArray)

    def deleteScaleFactors(self):
        r""" Delete all scale factor stuff and reset option"""
        return _cbcpy.OsiClpSolverInterface_deleteScaleFactors(self)

    def upRange(self):
        r""" If doing fast hot start then ranges are computed"""
        return _cbcpy.OsiClpSolverInterface_upRange(self)

    def downRange(self):
        return _cbcpy.OsiClpSolverInterface_downRange(self)

    def passInRanges(self, array):
        r""" Pass in range array"""
        return _cbcpy.OsiClpSolverInterface_passInRanges(self, array)

    def setSOSData(self, numberSOS, type, start, indices, weights=None):
        r""" Pass in sos stuff from AMPl"""
        return _cbcpy.OsiClpSolverInterface_setSOSData(self, numberSOS, type, start, indices, weights)

    def computeLargestAway(self):
        r""" Compute largest amount any at continuous away from bound"""
        return _cbcpy.OsiClpSolverInterface_computeLargestAway(self)

    def largestAway(self):
        r""" Get largest amount continuous away from bound"""
        return _cbcpy.OsiClpSolverInterface_largestAway(self)

    def setLargestAway(self, value):
        r""" Set largest amount continuous away from bound"""
        return _cbcpy.OsiClpSolverInterface_setLargestAway(self, value)

    def lexSolve(self):
        r""" Sort of lexicographic resolve"""
        return _cbcpy.OsiClpSolverInterface_lexSolve(self)

    def getContinuousModel(self):
        r""" Get continuous model"""
        return _cbcpy.OsiClpSolverInterface_getContinuousModel(self)

    def setContinuousModel(self, model):
        r""" Set continuous model"""
        return _cbcpy.OsiClpSolverInterface_setContinuousModel(self, model)

# Register OsiClpSolverInterface in _cbcpy:
_cbcpy.OsiClpSolverInterface_swigregister(OsiClpSolverInterface)
cvar = _cbcpy.cvar
OsiClpInfinity = cvar.OsiClpInfinity

class OsiClpDisasterHandler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def intoSimplex(self):
        r""" Into simplex"""
        return _cbcpy.OsiClpDisasterHandler_intoSimplex(self)

    def check(self):
        r""" Checks if disaster"""
        return _cbcpy.OsiClpDisasterHandler_check(self)

    def saveInfo(self):
        r""" saves information for next attempt"""
        return _cbcpy.OsiClpDisasterHandler_saveInfo(self)

    def typeOfDisaster(self):
        r""" Type of disaster 0 can fix, 1 abort"""
        return _cbcpy.OsiClpDisasterHandler_typeOfDisaster(self)
    __swig_destroy__ = _cbcpy.delete_OsiClpDisasterHandler

    def __init__(self, *args):
        _cbcpy.OsiClpDisasterHandler_swiginit(self, _cbcpy.new_OsiClpDisasterHandler(*args))

    def clone(self):
        r""" Clone"""
        return _cbcpy.OsiClpDisasterHandler_clone(self)

    def setOsiModel(self, model):
        r""" set model."""
        return _cbcpy.OsiClpDisasterHandler_setOsiModel(self, model)

    def osiModel(self):
        r""" Get model"""
        return _cbcpy.OsiClpDisasterHandler_osiModel(self)

    def setWhereFrom(self, value):
        r""" Set where from"""
        return _cbcpy.OsiClpDisasterHandler_setWhereFrom(self, value)

    def whereFrom(self):
        r""" Get where from"""
        return _cbcpy.OsiClpDisasterHandler_whereFrom(self)

    def setPhase(self, value):
        r""" Set phase"""
        return _cbcpy.OsiClpDisasterHandler_setPhase(self, value)

    def phase(self):
        r""" Get phase"""
        return _cbcpy.OsiClpDisasterHandler_phase(self)

    def inTrouble(self):
        r""" are we in trouble"""
        return _cbcpy.OsiClpDisasterHandler_inTrouble(self)

# Register OsiClpDisasterHandler in _cbcpy:
_cbcpy.OsiClpDisasterHandler_swigregister(OsiClpDisasterHandler)


def OsiClpHasNDEBUG():
    return _cbcpy.OsiClpHasNDEBUG()


