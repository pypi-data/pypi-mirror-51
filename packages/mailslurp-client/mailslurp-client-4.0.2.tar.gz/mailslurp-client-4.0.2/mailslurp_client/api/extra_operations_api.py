# coding: utf-8

"""
    MailSlurp API

    For documentation see [developer guide](https://www.mailslurp.com/developers). [Create an account](https://app.mailslurp.com) in the MailSlurp Dashboard to [view your API Key](https://app). For all bugs, feature requests, or help please [see support](https://www.mailslurp.com/support/).  # noqa: E501

    OpenAPI spec version: 0.0.1-alpha
    Contact: contact@mailslurp.dev
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from mailslurp_client.api_client import ApiClient


class ExtraOperationsApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def bulk_create_inboxes_using_post(self, count, **kwargs):  # noqa: E501
        """Bulk create Inboxes (email addresses)  # noqa: E501

        Enterprise Plan Required  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_create_inboxes_using_post(count, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int count: Number of inboxes to be created in bulk (required)
        :return: list[Inbox]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_create_inboxes_using_post_with_http_info(count, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_create_inboxes_using_post_with_http_info(count, **kwargs)  # noqa: E501
            return data

    def bulk_create_inboxes_using_post_with_http_info(self, count, **kwargs):  # noqa: E501
        """Bulk create Inboxes (email addresses)  # noqa: E501

        Enterprise Plan Required  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_create_inboxes_using_post_with_http_info(count, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int count: Number of inboxes to be created in bulk (required)
        :return: list[Inbox]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['count']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_create_inboxes_using_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'count' is set
        if ('count' not in local_var_params or
                local_var_params['count'] is None):
            raise ValueError("Missing the required parameter `count` when calling `bulk_create_inboxes_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'count' in local_var_params:
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['API_KEY']  # noqa: E501

        return self.api_client.call_api(
            '/bulk/inboxes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Inbox]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def bulk_delete_inboxes_using_delete(self, request_body, **kwargs):  # noqa: E501
        """Bulk Delete Inboxes  # noqa: E501

        Enterprise Plan Required  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_delete_inboxes_using_delete(request_body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] request_body: ids (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_delete_inboxes_using_delete_with_http_info(request_body, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_delete_inboxes_using_delete_with_http_info(request_body, **kwargs)  # noqa: E501
            return data

    def bulk_delete_inboxes_using_delete_with_http_info(self, request_body, **kwargs):  # noqa: E501
        """Bulk Delete Inboxes  # noqa: E501

        Enterprise Plan Required  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_delete_inboxes_using_delete_with_http_info(request_body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] request_body: ids (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['request_body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_delete_inboxes_using_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'request_body' is set
        if ('request_body' not in local_var_params or
                local_var_params['request_body'] is None):
            raise ValueError("Missing the required parameter `request_body` when calling `bulk_delete_inboxes_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request_body' in local_var_params:
            body_params = local_var_params['request_body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['API_KEY']  # noqa: E501

        return self.api_client.call_api(
            '/bulk/inboxes', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def bulk_send_emails_using_post(self, bulk_send_email_options, **kwargs):  # noqa: E501
        """Bulk Send Emails  # noqa: E501

        Enterprise Plan Required  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_send_emails_using_post(bulk_send_email_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BulkSendEmailOptions bulk_send_email_options: bulkSendEmailOptions (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_send_emails_using_post_with_http_info(bulk_send_email_options, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_send_emails_using_post_with_http_info(bulk_send_email_options, **kwargs)  # noqa: E501
            return data

    def bulk_send_emails_using_post_with_http_info(self, bulk_send_email_options, **kwargs):  # noqa: E501
        """Bulk Send Emails  # noqa: E501

        Enterprise Plan Required  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_send_emails_using_post_with_http_info(bulk_send_email_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BulkSendEmailOptions bulk_send_email_options: bulkSendEmailOptions (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['bulk_send_email_options']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_send_emails_using_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'bulk_send_email_options' is set
        if ('bulk_send_email_options' not in local_var_params or
                local_var_params['bulk_send_email_options'] is None):
            raise ValueError("Missing the required parameter `bulk_send_email_options` when calling `bulk_send_emails_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'bulk_send_email_options' in local_var_params:
            body_params = local_var_params['bulk_send_email_options']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['API_KEY']  # noqa: E501

        return self.api_client.call_api(
            '/bulk/send', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_inbox_using_post(self, **kwargs):  # noqa: E501
        """Create an Inbox (email address)  # noqa: E501

        Create a new inbox and ephemeral email address to send and receive from. This is a necessary step before sending or receiving emails. The response contains the inbox's ID and its associated email address. It is recommended that you create a new inbox during each test method so that it is unique and empty  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_inbox_using_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Inbox
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_inbox_using_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_inbox_using_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_inbox_using_post_with_http_info(self, **kwargs):  # noqa: E501
        """Create an Inbox (email address)  # noqa: E501

        Create a new inbox and ephemeral email address to send and receive from. This is a necessary step before sending or receiving emails. The response contains the inbox's ID and its associated email address. It is recommended that you create a new inbox during each test method so that it is unique and empty  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_inbox_using_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Inbox
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_inbox_using_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['API_KEY']  # noqa: E501

        return self.api_client.call_api(
            '/inboxes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Inbox',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_email_using_delete(self, email_id, **kwargs):  # noqa: E501
        """Delete Email  # noqa: E501

        Deletes an email and removes it from the inbox  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_email_using_delete(email_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str email_id: emailId (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_email_using_delete_with_http_info(email_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_email_using_delete_with_http_info(email_id, **kwargs)  # noqa: E501
            return data

    def delete_email_using_delete_with_http_info(self, email_id, **kwargs):  # noqa: E501
        """Delete Email  # noqa: E501

        Deletes an email and removes it from the inbox  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_email_using_delete_with_http_info(email_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str email_id: emailId (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['email_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_email_using_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'email_id' is set
        if ('email_id' not in local_var_params or
                local_var_params['email_id'] is None):
            raise ValueError("Missing the required parameter `email_id` when calling `delete_email_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email_id' in local_var_params:
            path_params['emailId'] = local_var_params['email_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['API_KEY']  # noqa: E501

        return self.api_client.call_api(
            '/emails/{emailId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_inbox_using_delete(self, inbox_id, **kwargs):  # noqa: E501
        """Delete Inbox  # noqa: E501

        Permanently delete an inbox and associated email address  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_inbox_using_delete(inbox_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str inbox_id: inboxId (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_inbox_using_delete_with_http_info(inbox_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_inbox_using_delete_with_http_info(inbox_id, **kwargs)  # noqa: E501
            return data

    def delete_inbox_using_delete_with_http_info(self, inbox_id, **kwargs):  # noqa: E501
        """Delete Inbox  # noqa: E501

        Permanently delete an inbox and associated email address  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_inbox_using_delete_with_http_info(inbox_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str inbox_id: inboxId (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['inbox_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_inbox_using_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'inbox_id' is set
        if ('inbox_id' not in local_var_params or
                local_var_params['inbox_id'] is None):
            raise ValueError("Missing the required parameter `inbox_id` when calling `delete_inbox_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'inbox_id' in local_var_params:
            path_params['inboxId'] = local_var_params['inbox_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['API_KEY']  # noqa: E501

        return self.api_client.call_api(
            '/inboxes/{inboxId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_email_attachment_using_get(self, attachment_id, email_id, **kwargs):  # noqa: E501
        """Get email attachment  # noqa: E501

        Returns the specified attachment for a given email as a byte stream (file download). Get the attachmentId from the email response. Requires enterprise account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_email_attachment_using_get(attachment_id, email_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str attachment_id: attachmentId (required)
        :param str email_id: emailId (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_email_attachment_using_get_with_http_info(attachment_id, email_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_email_attachment_using_get_with_http_info(attachment_id, email_id, **kwargs)  # noqa: E501
            return data

    def get_email_attachment_using_get_with_http_info(self, attachment_id, email_id, **kwargs):  # noqa: E501
        """Get email attachment  # noqa: E501

        Returns the specified attachment for a given email as a byte stream (file download). Get the attachmentId from the email response. Requires enterprise account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_email_attachment_using_get_with_http_info(attachment_id, email_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str attachment_id: attachmentId (required)
        :param str email_id: emailId (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['attachment_id', 'email_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_email_attachment_using_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'attachment_id' is set
        if ('attachment_id' not in local_var_params or
                local_var_params['attachment_id'] is None):
            raise ValueError("Missing the required parameter `attachment_id` when calling `get_email_attachment_using_get`")  # noqa: E501
        # verify the required parameter 'email_id' is set
        if ('email_id' not in local_var_params or
                local_var_params['email_id'] is None):
            raise ValueError("Missing the required parameter `email_id` when calling `get_email_attachment_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'attachment_id' in local_var_params:
            path_params['attachmentId'] = local_var_params['attachment_id']  # noqa: E501
        if 'email_id' in local_var_params:
            path_params['emailId'] = local_var_params['email_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['API_KEY']  # noqa: E501

        return self.api_client.call_api(
            '/emails/{emailId}/attachments/{attachmentId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_email_using_get(self, email_id, **kwargs):  # noqa: E501
        """Get Email Content  # noqa: E501

        Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawMessage endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_email_using_get(email_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str email_id: emailId (required)
        :return: Email
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_email_using_get_with_http_info(email_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_email_using_get_with_http_info(email_id, **kwargs)  # noqa: E501
            return data

    def get_email_using_get_with_http_info(self, email_id, **kwargs):  # noqa: E501
        """Get Email Content  # noqa: E501

        Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawMessage endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_email_using_get_with_http_info(email_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str email_id: emailId (required)
        :return: Email
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['email_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_email_using_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'email_id' is set
        if ('email_id' not in local_var_params or
                local_var_params['email_id'] is None):
            raise ValueError("Missing the required parameter `email_id` when calling `get_email_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email_id' in local_var_params:
            path_params['emailId'] = local_var_params['email_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['API_KEY']  # noqa: E501

        return self.api_client.call_api(
            '/emails/{emailId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Email',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_emails_using_get(self, inbox_id, **kwargs):  # noqa: E501
        """List an Inbox's Emails  # noqa: E501

        List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_emails_using_get(inbox_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str inbox_id: Id of inbox that emails belongs to (required)
        :param int limit: Limit the result set, ordered by descending received date time
        :param int min_count: Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
        :param int retry_timeout: Maximum milliseconds to spend retrying inbox database until minCount emails are returned
        :param datetime since: Exclude emails received before this ISO 8601 date time
        :return: list[EmailPreview]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_emails_using_get_with_http_info(inbox_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_emails_using_get_with_http_info(inbox_id, **kwargs)  # noqa: E501
            return data

    def get_emails_using_get_with_http_info(self, inbox_id, **kwargs):  # noqa: E501
        """List an Inbox's Emails  # noqa: E501

        List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_emails_using_get_with_http_info(inbox_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str inbox_id: Id of inbox that emails belongs to (required)
        :param int limit: Limit the result set, ordered by descending received date time
        :param int min_count: Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
        :param int retry_timeout: Maximum milliseconds to spend retrying inbox database until minCount emails are returned
        :param datetime since: Exclude emails received before this ISO 8601 date time
        :return: list[EmailPreview]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['inbox_id', 'limit', 'min_count', 'retry_timeout', 'since']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_emails_using_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'inbox_id' is set
        if ('inbox_id' not in local_var_params or
                local_var_params['inbox_id'] is None):
            raise ValueError("Missing the required parameter `inbox_id` when calling `get_emails_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'inbox_id' in local_var_params:
            path_params['inboxId'] = local_var_params['inbox_id']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params:
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'min_count' in local_var_params:
            query_params.append(('minCount', local_var_params['min_count']))  # noqa: E501
        if 'retry_timeout' in local_var_params:
            query_params.append(('retryTimeout', local_var_params['retry_timeout']))  # noqa: E501
        if 'since' in local_var_params:
            query_params.append(('since', local_var_params['since']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['API_KEY']  # noqa: E501

        return self.api_client.call_api(
            '/inboxes/{inboxId}/emails', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EmailPreview]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_inbox_using_get(self, inbox_id, **kwargs):  # noqa: E501
        """Get Inbox  # noqa: E501

        Returns an inbox's properties, including its email address and ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_inbox_using_get(inbox_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str inbox_id: inboxId (required)
        :return: Inbox
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_inbox_using_get_with_http_info(inbox_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_inbox_using_get_with_http_info(inbox_id, **kwargs)  # noqa: E501
            return data

    def get_inbox_using_get_with_http_info(self, inbox_id, **kwargs):  # noqa: E501
        """Get Inbox  # noqa: E501

        Returns an inbox's properties, including its email address and ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_inbox_using_get_with_http_info(inbox_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str inbox_id: inboxId (required)
        :return: Inbox
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['inbox_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_inbox_using_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'inbox_id' is set
        if ('inbox_id' not in local_var_params or
                local_var_params['inbox_id'] is None):
            raise ValueError("Missing the required parameter `inbox_id` when calling `get_inbox_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'inbox_id' in local_var_params:
            path_params['inboxId'] = local_var_params['inbox_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['API_KEY']  # noqa: E501

        return self.api_client.call_api(
            '/inboxes/{inboxId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Inbox',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_inboxes_using_get(self, **kwargs):  # noqa: E501
        """List Inboxes  # noqa: E501

        List the inboxes you have created  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_inboxes_using_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Inbox]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_inboxes_using_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_inboxes_using_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_inboxes_using_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Inboxes  # noqa: E501

        List the inboxes you have created  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_inboxes_using_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Inbox]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_inboxes_using_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['API_KEY']  # noqa: E501

        return self.api_client.call_api(
            '/inboxes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Inbox]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_raw_email_using_get(self, email_id, **kwargs):  # noqa: E501
        """Get Raw Email Content  # noqa: E501

        Returns a raw, unparsed and unprocessed email  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_raw_email_using_get(email_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str email_id: emailId (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_raw_email_using_get_with_http_info(email_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_raw_email_using_get_with_http_info(email_id, **kwargs)  # noqa: E501
            return data

    def get_raw_email_using_get_with_http_info(self, email_id, **kwargs):  # noqa: E501
        """Get Raw Email Content  # noqa: E501

        Returns a raw, unparsed and unprocessed email  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_raw_email_using_get_with_http_info(email_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str email_id: emailId (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['email_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_raw_email_using_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'email_id' is set
        if ('email_id' not in local_var_params or
                local_var_params['email_id'] is None):
            raise ValueError("Missing the required parameter `email_id` when calling `get_raw_email_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email_id' in local_var_params:
            path_params['emailId'] = local_var_params['email_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['API_KEY']  # noqa: E501

        return self.api_client.call_api(
            '/emails/{emailId}/raw', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def send_email_using_post(self, inbox_id, send_email_options, **kwargs):  # noqa: E501
        """Send Email  # noqa: E501

        Send an email from the inbox's email address. Specify the email recipients and contents in the request body. See the `SendEmailOptions` for more information. Note the `inboxId` refers to the inbox's id NOT its email address  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.send_email_using_post(inbox_id, send_email_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str inbox_id: inboxId (required)
        :param SendEmailOptions send_email_options: sendEmailOptions (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.send_email_using_post_with_http_info(inbox_id, send_email_options, **kwargs)  # noqa: E501
        else:
            (data) = self.send_email_using_post_with_http_info(inbox_id, send_email_options, **kwargs)  # noqa: E501
            return data

    def send_email_using_post_with_http_info(self, inbox_id, send_email_options, **kwargs):  # noqa: E501
        """Send Email  # noqa: E501

        Send an email from the inbox's email address. Specify the email recipients and contents in the request body. See the `SendEmailOptions` for more information. Note the `inboxId` refers to the inbox's id NOT its email address  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.send_email_using_post_with_http_info(inbox_id, send_email_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str inbox_id: inboxId (required)
        :param SendEmailOptions send_email_options: sendEmailOptions (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['inbox_id', 'send_email_options']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method send_email_using_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'inbox_id' is set
        if ('inbox_id' not in local_var_params or
                local_var_params['inbox_id'] is None):
            raise ValueError("Missing the required parameter `inbox_id` when calling `send_email_using_post`")  # noqa: E501
        # verify the required parameter 'send_email_options' is set
        if ('send_email_options' not in local_var_params or
                local_var_params['send_email_options'] is None):
            raise ValueError("Missing the required parameter `send_email_options` when calling `send_email_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'inbox_id' in local_var_params:
            path_params['inboxId'] = local_var_params['inbox_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'send_email_options' in local_var_params:
            body_params = local_var_params['send_email_options']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['API_KEY']  # noqa: E501

        return self.api_client.call_api(
            '/inboxes/{inboxId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
