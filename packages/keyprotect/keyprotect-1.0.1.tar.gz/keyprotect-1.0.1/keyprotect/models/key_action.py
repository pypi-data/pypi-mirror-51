# coding: utf-8

"""
    IBM Key Protect API

    IBM Key Protect helps you provision encrypted keys for apps across IBM Cloud. As you manage the lifecycle of your keys, you can benefit from knowing that your keys are secured by cloud-based FIPS 140-2 Level 2 hardware security modules (HSMs) that protect against theft of information. You can use the Key Protect API to store, generate, and retrieve your key material. Keys within the service can protect any type of data in your symmetric key based encryption solution.  # noqa: E501

    The version of the OpenAPI document: 2.0.0
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six


class KeyAction(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'plaintext': 'str',
        'aad': 'list[str]',
        'ciphertext': 'str',
        'payload': 'str'
    }

    attribute_map = {
        'plaintext': 'plaintext',
        'aad': 'aad',
        'ciphertext': 'ciphertext',
        'payload': 'payload'
    }

    def __init__(self, plaintext=None, aad=None, ciphertext=None, payload=None):  # noqa: E501
        """KeyAction - a model defined in OpenAPI"""  # noqa: E501

        self._plaintext = None
        self._aad = None
        self._ciphertext = None
        self._payload = None
        self.discriminator = None

        if plaintext is not None:
            self.plaintext = plaintext
        if aad is not None:
            self.aad = aad
        if ciphertext is not None:
            self.ciphertext = ciphertext
        if payload is not None:
            self.payload = payload

    @property
    def plaintext(self):
        """Gets the plaintext of this KeyAction.  # noqa: E501

        The data encryption key (DEK) used in wrap actions when the query parameter is set to `wrap`. The system returns a base64 encoded plaintext in the response entity-body when you perform an `unwrap` action on a key.     To wrap an existing DEK, provide a base64 encoded plaintext during a `wrap` action. To generate a new DEK, omit the `plaintext` property. Key Protect generates a random plaintext (32 bytes) that is rooted in an HSM and then wraps that value.   # noqa: E501

        :return: The plaintext of this KeyAction.  # noqa: E501
        :rtype: str
        """
        return self._plaintext

    @plaintext.setter
    def plaintext(self, plaintext):
        """Sets the plaintext of this KeyAction.

        The data encryption key (DEK) used in wrap actions when the query parameter is set to `wrap`. The system returns a base64 encoded plaintext in the response entity-body when you perform an `unwrap` action on a key.     To wrap an existing DEK, provide a base64 encoded plaintext during a `wrap` action. To generate a new DEK, omit the `plaintext` property. Key Protect generates a random plaintext (32 bytes) that is rooted in an HSM and then wraps that value.   # noqa: E501

        :param plaintext: The plaintext of this KeyAction.  # noqa: E501
        :type: str
        """
        if plaintext is not None and len(plaintext) > 4096:
            raise ValueError("Invalid value for `plaintext`, length must be less than or equal to `4096`")  # noqa: E501

        self._plaintext = plaintext

    @property
    def aad(self):
        """Gets the aad of this KeyAction.  # noqa: E501

        The additional authentication data (AAD) used to further secure the key.     If you supply AAD when you make a `wrap` call, you must specify the same AAD during a subsequent `unwrap` call.   # noqa: E501

        :return: The aad of this KeyAction.  # noqa: E501
        :rtype: list[str]
        """
        return self._aad

    @aad.setter
    def aad(self, aad):
        """Sets the aad of this KeyAction.

        The additional authentication data (AAD) used to further secure the key.     If you supply AAD when you make a `wrap` call, you must specify the same AAD during a subsequent `unwrap` call.   # noqa: E501

        :param aad: The aad of this KeyAction.  # noqa: E501
        :type: list[str]
        """

        self._aad = aad

    @property
    def ciphertext(self):
        """Gets the ciphertext of this KeyAction.  # noqa: E501

        The wrapped data encryption key (DEK) used in wrap actions when the query parameter is set to `unwrap`. The system requires a base64 encoded ciphertext and returns a base64 encoded plaintext in the response entity-body when you perform an `unwrap` action on a key.       **Note:** When you unwrap a wrapped data encryption key (WDEK) by using a rotated root key, the service returns a new ciphertext in the response entity-body. Each ciphertext remains available for `unwrap` actions. If you unwrap a DEK with a previous ciphertext, the service also returns the latest ciphertext in the response.  Use the latest ciphertext for future unwrap operations.    # noqa: E501

        :return: The ciphertext of this KeyAction.  # noqa: E501
        :rtype: str
        """
        return self._ciphertext

    @ciphertext.setter
    def ciphertext(self, ciphertext):
        """Sets the ciphertext of this KeyAction.

        The wrapped data encryption key (DEK) used in wrap actions when the query parameter is set to `unwrap`. The system requires a base64 encoded ciphertext and returns a base64 encoded plaintext in the response entity-body when you perform an `unwrap` action on a key.       **Note:** When you unwrap a wrapped data encryption key (WDEK) by using a rotated root key, the service returns a new ciphertext in the response entity-body. Each ciphertext remains available for `unwrap` actions. If you unwrap a DEK with a previous ciphertext, the service also returns the latest ciphertext in the response.  Use the latest ciphertext for future unwrap operations.    # noqa: E501

        :param ciphertext: The ciphertext of this KeyAction.  # noqa: E501
        :type: str
        """

        self._ciphertext = ciphertext

    @property
    def payload(self):
        """Gets the payload of this KeyAction.  # noqa: E501

        The key material that you want to import into the service for rotating an existing root key. This value is  required for a `rotate` action if you initially imported the key material when you created the key.     To rotate an imported root key, provide a base64 encoded payload in the request entity-body. To rotate a root key that was initially generated by Key Protect, omit the `payload` property and pass in an empty request entity-body.  # noqa: E501

        :return: The payload of this KeyAction.  # noqa: E501
        :rtype: str
        """
        return self._payload

    @payload.setter
    def payload(self, payload):
        """Sets the payload of this KeyAction.

        The key material that you want to import into the service for rotating an existing root key. This value is  required for a `rotate` action if you initially imported the key material when you created the key.     To rotate an imported root key, provide a base64 encoded payload in the request entity-body. To rotate a root key that was initially generated by Key Protect, omit the `payload` property and pass in an empty request entity-body.  # noqa: E501

        :param payload: The payload of this KeyAction.  # noqa: E501
        :type: str
        """

        self._payload = payload

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, KeyAction):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
