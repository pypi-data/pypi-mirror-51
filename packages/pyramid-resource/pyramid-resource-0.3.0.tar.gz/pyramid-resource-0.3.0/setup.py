# -*- coding: utf-8 -*-
from distutils.core import setup

modules = \
['pyramid_resource']
install_requires = \
['pyramid>=1.7,<2.0']

setup_kwargs = {
    'name': 'pyramid-resource',
    'version': '0.3.0',
    'description': 'A simple base resource class for Pyramid traversal.',
    'long_description': '# pyramid-resource\n\nPyramid\'s URL traversal is a powerful tool and personally one of my favorite\nfeatures of the framework.  Unfortunately, Pyramid doesn\'t provide any\nframework or utilities for implementing resource trees.  This project aims to\nreduce the boilerplate necessary for creating feature-full resource trees.\n\n## Basic usage\n\nFirst, of course, you need to add `pyramid-resource` to your project using your\npackage manager of choice.  e.g.: `pip install pyramid-resource`\n\nMake sure you\'re familiar with Pyramid\'s\n[URL traversal](https://docs.pylonsproject.org/projects/pyramid/en/latest/narr/traversal.html).\n\nYou can create a new resource by subclassing `pyramid_resource.Resource`.  For\nexample, here\'s a simple application that has a resource tree with only a root\nresource.\n\n```python\nfrom wsgiref.simple_server import make_server\nfrom pyramid.config import Configurator\nfrom pyramid.response import Response\nfrom pyramid_resource import Resource\n\n\nclass Root(Resource):\n    pass\n\n\ndef hello_world(request):\n    return Response(\'Hello!\\n\')\n\n\nif __name__ == \'__main__\':\n    with Configurator() as config:\n        config.set_root_factory(Root)\n        config.add_view(hello_world, context=Root)\n        app = config.make_wsgi_app()\n    server = make_server(\'0.0.0.0\', 8080, app)\n    server.serve_forever()\n```\n\nYou can define child resources by setting the `__children__` property to a\ndictionary.  The key corresponds the URL segment and the value should be a\nresource subclass.  pyramid-resource will automatically make the resources\nlocation-aware.\n\n```python\nclass Child(Resource):\n    pass\n\n\nclass Root(Resource):\n    __children__ = {\n        \'child\': Child,\n    }\n```\n\nYou can see the full example\n[here](https://github.com/luhn/pyramid-resource/blob/master/examples/02_children.py).\n\n### Name Resolution\n\nFor convenience, you can reference children with dotted Python names.  This is\nmost useful for referencing child resources that may be defined further down\nthe document.  If you use this functionality, **you must run\n`Configurator.scan()` to trigger the resolution.**\n\n```python\nclass Root(Resource):\n    __children__ = {\n        \'child\': \'.Child\',\n    }\n\n\nclass Child(Resource):\n    pass\n```\n\n## Dynamic resource trees\n\nOne of the more interesting features of URL traversal is that trees can be\ncreated on the fly.  This allows for dynamic resource trees that can mirror the\napplication state, such as objects in a database.\n\nDynamic resource trees can be created by implementing a `get_child` method on\na resource class.  This method should accept a single argument of a URL\nsegment and will be called if no child is found in the `__children__` property.\nIf the URL segment corresponds to a valid child resource, `get_child` should\nreturn a resource class and the child resource will be instanciated from that.\nIf no corresponding child is found, `None` should be returned or `KeyError`\nraised, and traversal will be halted.\n\n```python\nclass Root(Resource):\n    def get_child(self, key):\n        if exists_in_db(key):\n            return Child\n        else:\n            return None\n\n\nclass Child(Resource):\n    pass\n```\n\nOf course, this isn\'t particularly useful if you can\'t attach information to\nthe child resource.  `get_child` can also return a two-tuple of a resource\nclass and a dictionary of attributes that will be attached to the resulting\nchild.\n\n```python\nclass Root(Resource):\n    def get_child(self, key):\n        if exists_in_db(key):\n            return Child, {\'id\': key}\n\n\nclass Child(Resource):\n    pass\n```\n\nThe object ID will now be accessible via `context.id` in views on the child\nresource.  **Resources will proxy the attributes of their parent**, so\n`context.id` will also be accessible in views further down the tree.\n\nIf you need to access the current request in your `get_child` implementations,\nit\'s available via `self.request`.\n\n## An example\n\nHere\'s an example that demonstrates how a real application might utilize\npyramid-resource.\n\n```python\nfrom wsgiref.simple_server import make_server\nfrom pyramid.decorator import reify\nfrom pyramid.config import Configurator\nfrom pyramid.view import view_config\nfrom pyramid_resource import Resource\n\n\nclass Root(Resource):\n    __children__ = {\n        \'widget\': \'.WidgetContainer\',\n    }\n\n\nclass WidgetContainer(Resource):\n    """\n    A resource containing the Widget resources.\n\n    """\n    def get_child(self, key):\n        """\n        Return a child resource if the widget exists in the database.\n\n        """\n        try:\n            id = int(key)\n        except ValueError:\n            raise KeyError\n\n        if self.request.widget_db.exists(id):\n            return Widget, {\'widget_id\': id}\n\n\nclass Widget(Resource):\n    """\n    A resource representing a widget in the mock database.\n\n    """\n    @reify\n    def widget(self):\n        """\n        Lookup the widget from the database.\n\n        """\n        return self.request.widget_db.find(self.widget_id)\n\n\n@view_config(context=WidgetContainer, renderer=\'string\')\ndef list_widgets(context, request):\n    """\n    GET /widget/\n\n    List the URLs of all widgets.\n\n    """\n    urls = []\n    for widget_id in request.widget_db:\n        urls.append(request.resource_path(context[widget_id]))\n    return \'\\n\'.join(urls) + \'\\n\'\n\n\n@view_config(context=Widget, renderer=\'string\')\ndef get_widget(context, request):\n    """\n    GET /widget/{id}/\n\n    Greet the current widget.\n\n    """\n    return \'Hello {}!\\n\'.format(context.widget)\n\n\nclass MockDatabase:\n    """\n    An imitation of a widget database.\n\n    """\n    DATA = {\n        1: \'Widget 1\',\n        2: \'Widget 2\',\n    }\n\n    def exists(self, id):\n        return id in self.DATA\n\n    def find(self, id):\n        return self.DATA[id]\n\n    def __iter__(self):\n        return iter(self.DATA.keys())\n\n\nif __name__ == \'__main__\':\n    with Configurator() as config:\n        config.set_root_factory(Root)\n        config.add_request_method(\n            lambda _: MockDatabase(),\n            \'widget_db\',\n            property=True,\n        )\n        config.scan()\n        app = config.make_wsgi_app()\n    server = make_server(\'0.0.0.0\', 8080, app)\n    server.serve_forever()\n```\n\nThe resulting application will behave like this:\n\n```\n>>> curl localhost:8080/widget/\n> /widget/1/\n> /widget/2/\n\n>>> curl localhost:8080/widget/1/\n> Hello Widget 1!\n\n>>> curl localhost:8080/widget/2/\n> Hello Widget 2!\n```\n\n## Hacking\n\nDeveloping against pyramid-resource is simple, thanks to Poetry:\n\n* [Install Poetry](https://poetry.eustace.io/docs/#installation) if you haven\'t\n  done so already\n* Clone the repository\n* Run `poetry install`\n* Run the test suite with `make test`\n\n## Prior art\n\nThe\n[pyramid_traversalwrapper](https://github.com/Pylons/pyramid_traversalwrapper)\nproject proxies a location-ignorant resource tree to make it location-aware.\n',
    'author': 'Theron Luhn',
    'author_email': 'theron@luhn.com',
    'url': 'https://github.com/luhn/pyramid-resource',
    'py_modules': modules,
    'install_requires': install_requires,
    'python_requires': '>=3.4,<4.0',
}


setup(**setup_kwargs)
