<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Retrieving metadata &#8212; pyatv 0.3.11 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.3.11',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="AirPlay Support" href="airplay.html" />
    <link rel="prev" title="Controlling a device" href="controlling.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="retrieving-metadata">
<span id="pyatv-metadata"></span><h1>Retrieving metadata<a class="headerlink" href="#retrieving-metadata" title="Permalink to this headline">¶</a></h1>
<p>It is possible to get metadata, i.e. what is playing, using two different
methods:</p>
<ul class="simple">
<li>Manually polling</li>
<li>Push updates</li>
</ul>
<p>Polling metadata from the device works very similar to the remote control
API, but one asynchronous call will return an object containing all metadata.
This is to lower the amount of device calls needed. Artwork is retrieved
separately.</p>
<p>When using push updates, new updates are <em>pushed</em> from the Apple TV when
someting of interest happens. The exact same data that is available when
polling, is passed to a callback provided by the API user. Please see the
example further down for more details.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Only what is currently playing is supported by the push API. Artwork
must still be polled.</p>
</div>
<div class="section" id="what-is-currently-playing">
<h2>What is currently playing<a class="headerlink" href="#what-is-currently-playing" title="Permalink to this headline">¶</a></h2>
<p>To retrieve what is currently playing, use the asynchronous playing method:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">playing</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">atv</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">playing</span><span class="p">()</span>
</pre></div>
</div>
<p>You can easily extract fields like title, album or media type. See
<a class="reference internal" href="api.html#pyatv.interface.Playing" title="pyatv.interface.Playing"><code class="xref py py-class docutils literal"><span class="pre">pyatv.interface.Playing</span></code></a> and <a class="reference internal" href="api.html#module-pyatv.const" title="pyatv.const"><code class="xref py py-mod docutils literal"><span class="pre">pyatv.const</span></code></a>.</p>
</div>
<div class="section" id="artwork">
<h2>Artwork<a class="headerlink" href="#artwork" title="Permalink to this headline">¶</a></h2>
<p>To retrieve the artwork, use the asynchronous artwork method:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">artwork</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">atv</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">artwork</span><span class="p">()</span>
</pre></div>
</div>
<p>Remember that the artwork (which is a PNG file) is relatively large, so you
should try to minimize this call. More information is available at
<a class="reference internal" href="api.html#pyatv.interface.Metadata.artwork" title="pyatv.interface.Metadata.artwork"><code class="xref py py-meth docutils literal"><span class="pre">pyatv.interface.Metadata.artwork()</span></code></a>.</p>
<p>It is also possible to get an artwork URL instead by using <code class="docutils literal"><span class="pre">artwork_url()</span></code>.
In this case, the same URL will always be returned as long as current
session is valid and no check is performed if artwork is available (user of
the library must handle this). An example:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">artwork</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">atv</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">artwork_url</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="device-id">
<h2>Device ID<a class="headerlink" href="#device-id" title="Permalink to this headline">¶</a></h2>
<p>A unique SHA256 identifier can be generated to separate devices from one another:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">device_id</span> <span class="o">=</span> <span class="n">atv</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">device_id</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This id is based on the device address solely. No domain name resolution is
performed, so different identifiers will be returned for the same device
depending on if an IP-address is specified or a domain name. This might change
in the future.</p>
</div>
</div>
<div class="section" id="hash">
<h2>Hash<a class="headerlink" href="#hash" title="Permalink to this headline">¶</a></h2>
<p>To simplify detection if content has changed between retrieval of what is
currently playing, a unique hash can be generated. It is a SHA256 hash based
on the following data:</p>
<ul class="simple">
<li>Title</li>
<li>Artist</li>
<li>Album</li>
<li>Total time</li>
</ul>
<p>These properties has been selected as they are in general unique for the same
content. No guarantee is however given that the same hash is not given for
different content nor the same content. It can be used as a fair guess.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">playing</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">atv</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">playing</span><span class="p">()</span>
<span class="o">...</span>  <span class="c1"># Some time later</span>
<span class="n">playing2</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">atv</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">playing</span><span class="p">()</span>
<span class="k">if</span> <span class="n">playing2</span><span class="o">.</span><span class="n">hash</span> <span class="o">!=</span> <span class="n">playing</span><span class="o">.</span><span class="n">hash</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Content has changed&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="push-updates">
<h2>Push updates<a class="headerlink" href="#push-updates" title="Permalink to this headline">¶</a></h2>
<p>The push update API is based on a regular callback interface. When playstatus
information is available, a method called <code class="docutils literal"><span class="pre">playstatus_update</span></code> is called.
Similarily, <code class="docutils literal"><span class="pre">playstatus_error</span></code> is called if an error occur. See the
following example:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PushListener</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">playstatus_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">updater</span><span class="p">,</span> <span class="n">playstatus</span><span class="p">):</span>
        <span class="c1"># Currently playing in playstatus</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">playstatus_error</span><span class="p">(</span><span class="n">updater</span><span class="p">,</span> <span class="n">exception</span><span class="p">):</span>
        <span class="c1"># Error in exception</span>
        <span class="n">updater</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">initial_delay</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>


<span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">listen_to_updates</span><span class="p">(</span><span class="bp">self</span><span class="p">);</span>
    <span class="n">listener</span> <span class="o">=</span> <span class="n">PushListener</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">atv</span><span class="o">.</span><span class="n">push_updater</span><span class="o">.</span><span class="n">listener</span> <span class="o">=</span> <span class="n">listener</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">atv</span><span class="o">.</span><span class="n">push_updater</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>A few things worth noting:</p>
<ul class="simple">
<li>Both callback methods must be part of a &#8220;listener&#8221; (class)</li>
<li>There can be only one listener</li>
<li>If an error occurs, push updates are stopped</li>
</ul>
<p>Think a bit extra about the last point. You must manually restart push updates
in case an error occur. The simplest way is to do like in the example above,
but make sure to provide an &#8220;initial delay&#8221; (in seconds). Otherwhise you
might end up in a loop where a push connection can never be established. This
might for instance happen if the device loses its IP-address.</p>
<p>When done, the async method <code class="docutils literal"><span class="pre">stop</span></code> must be called to not leak resources.
Unless push updates were stopped because an error occurred and never
restarted again.</p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Retrieving metadata</a><ul>
<li><a class="reference internal" href="#what-is-currently-playing">What is currently playing</a></li>
<li><a class="reference internal" href="#artwork">Artwork</a></li>
<li><a class="reference internal" href="#device-id">Device ID</a></li>
<li><a class="reference internal" href="#hash">Hash</a></li>
<li><a class="reference internal" href="#push-updates">Push updates</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="controlling.html" title="previous chapter">Controlling a device</a></li>
      <li>Next: <a href="airplay.html" title="next chapter">AirPlay Support</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/metadata.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Pierre Ståhl.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/metadata.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>