# auto generated by update_py.py

import csv
import json
import os

import tlclient.trader.message_common as message_common
import tlclient.trader.message_market as message_market
import tlclient.trader.message_trade as message_trade
from tlclient.linker.constant import FistType
from tlclient.linker.fist import Fist
from tlclient.linker.frame import Frame
from tlclient.linker.utility import get_today_date
from tlclient.trader.constant import MsgType


class CsvFileClient:

    def __init__(self, path):
        self.base_path = path
        self.file_clients = dict()

    def _write_header(self, msg_class_name, msg_obj_dict):
        self.file_clients[msg_class_name]['fwrite'].writeheader()

    def _write_content(self, msg_class_name, msg_obj_dict):
        # suppose dict is in order (python >= 3.6)
        self.file_clients[msg_class_name]['fwrite'].writerow(msg_obj_dict)

    def _add_file_client(self, msg_class_name, msg_obj_dict, today_date):
        file_path = os.path.join(self.base_path, msg_class_name + '_' + today_date + '.csv')
        file_exists = os.path.exists(file_path)
        self.file_clients[msg_class_name] = {
            'date': today_date,
            'file_client': open(file_path, 'a', buffering=1),
            'fwrite': None
        }
        fieldnames = msg_obj_dict.keys()
        self.file_clients[msg_class_name]['fwrite'] = csv.DictWriter(self.file_clients[msg_class_name]['file_client'], fieldnames=fieldnames)
        if not file_exists:
            self._write_header(msg_class_name, msg_obj_dict)

    def writes(self, msg_obj, f):
        msg_class_name = msg_obj.__class__.__name__
        msg_obj_dict = msg_obj.to_dict()
        print('[write_csv] (msg_obj){}'.format(msg_obj))

        today_date = get_today_date()
        if msg_class_name not in self.file_clients:
            self._add_file_client(msg_class_name, msg_obj_dict, today_date)
        elif self.file_clients[msg_class_name]['date'] != today_date:
            self.file_clients[msg_class_name]['file_client'].close()
            self._add_file_client(msg_class_name, msg_obj_dict, today_date)

        self._write_content(msg_class_name, msg_obj_dict)

    def stop(self):
        print("[stop csv_file_client] (base_path)'{}'".format(self.base_path))
        for msg_class_name in self.file_clients.keys():
            self.file_clients[msg_class_name]['file_client'].close()
        self.file_clients.clear()


class Recorder(Fist):

    def __init__(self, name, env_name, addr):
        Fist.__init__(self, name, FistType.RECORDER, env_name)
        self.set_master_addr(addr)
        self.create_fist()

        self.clients = []

    def sub_router(self, router_name):
        self.reg_sub(router_name)

    ######################
    # internal functions #
    ######################

    def stop_clients(self):
        print("[Recorder] stop clients (fist_name){}".format(self.fist_name))
        for client in self.clients:
            client.stop()
        self.clients = []

    def dump_frame_info_to_flux(self, flux_info, f):
        if isinstance(flux_info, list):
            return [self.dump_frame_info_to_flux(flux_item, f) for flux_item in flux_info]
        else:
            flux_info['tags'].update({
                'frame_source': f.get_source(),
                'frame_req_id': f.get_req_id(),
                'frame_err_id': f.get_err_id(),
                'frame_msg_type': f.get_msg_type()
            })
            flux_info['fields'].update({
                'frame_dt': f.get_nano()
            })
            return flux_info

    def on_pub_frame(self, f):
        msg_type = f.get_msg_type()
        msg_obj = None
        if MsgType.is_market_data_type(msg_type):
            if msg_type == MsgType.MKT_SNAP:
                msg_obj = f.get_obj(message_market.MktSnap)

            elif msg_type == MsgType.MKT_SNAP_PLUS:
                msg_obj = f.get_obj(message_market.MktSnapPlus)

            elif msg_type == MsgType.MKT_SNAP_FUT:
                snap_obj = f.get_obj(message_market.MktSnapFut)
                self.write_points(self.dump_frame_info_to_flux(snap_obj.to_influx(), f))

            elif msg_type == MsgType.MKT_SNAP_OPT:
                msg_obj = f.get_obj(message_market.MktSnapOpt)

            elif msg_type == MsgType.MKT_BAR:
                msg_obj = f.get_obj(message_market.MktBar)

            elif msg_type == MsgType.MKT_BAR_GEN:
                msg_obj = f.get_obj(message_market.MktBarGen)

            elif msg_type == MsgType.MKT_TRADE:
                msg_obj = f.get_obj(message_market.MktTrade)

            elif msg_type == MsgType.MKT_INDEX:
                idx_obj = f.get_obj(message_market.MktIndex)
                self.write_points(self.dump_frame_info_to_flux(idx_obj.to_influx(), f))

            elif msg_type == MsgType.MKT_ORDER:
                order_obj = f.get_obj(message_market.MktOrder)
                self.write_points(self.dump_frame_info_to_flux(order_obj.to_influx(), f))

            elif msg_type == MsgType.MKT_TRADE:
                trade_obj = f.get_obj(message_market.MktTrade)
                self.write_points(self.dump_frame_info_to_flux(trade_obj.to_influx(), f))

            elif msg_type == MsgType.MKT_BAR:
                bar_obj = f.get_obj(message_market.MktBar)
                self.write_points(self.dump_frame_info_to_flux(bar_obj.to_influx(), f))

            elif msg_type == MsgType.MKT_BAR_GEN:
                bar_obj = f.get_obj(message_market.MktBarGen)
                self.write_points(self.dump_frame_info_to_flux(bar_obj.to_influx(), f))

            elif msg_type == MsgType.MKT_VOL:
                vol_obj = f.get_obj(message_market.MktVol)
                self.write_points(self.dump_frame_info_to_flux(vol_obj.to_influx(), f))

        elif MsgType.is_trading_data_type(msg_type):
            if msg_type == MsgType.RSP_ORDER_INSERT:
                msg_obj = f.get_obj(message_trade.RspOrderInsert)

            elif msg_type == MsgType.RSP_ORDER_CANCEL:
                msg_obj = f.get_obj(message_trade.RspOrderCancel)

            elif msg_type == MsgType.RTN_ORDER:
                msg_obj = f.get_obj(message_trade.RtnOrder)

            elif msg_type == MsgType.RTN_TRADE:
                msg_obj = f.get_obj(message_trade.RtnTrade)

            elif msg_type == MsgType.RSP_POSITION:
                pos_d = json.loads(f.get_string())
                msg_obj = message_trade.RspPosition(pos_d)

            elif msg_type == MsgType.RSP_ACCOUNT:
                msg_obj = f.get_obj(message_trade.RspAccount)

            elif msg_type == MsgType.RSP_ACTIVE_ORDERS:
                ods_d = json.loads(f.get_string())
                msg_obj = message_trade.RspActiveOrders(ods_d)

            elif msg_type == MsgType.RSP_CANCEL_ACTIVE_ORDERS:
                msg_obj = f.get_obj(message_trade.RspCancelActiveOrders)

        elif MsgType.is_system_status_data_type(msg_type):
            if msg_type == MsgType.GTW_CONNECTION:
                msg_obj = f.get_obj(message_common.GatewayConnectionStatus)

            elif msg_type == MsgType.GTW_HEART_BEAT:
                msg_obj = f.get_obj(message_common.GatewayHeartBeat)

        if msg_obj:
            for client in self.clients:
                client.writes(msg_obj, f)
            # TODO need refactor
            self.write_points(self.dump_frame_info_to_flux(msg_obj.to_influx(), f))

    # csv setting
    def add_csvfile_client(self, path):
        if not os.path.exists(path):
            os.makedirs(path)
        elif not os.path.isdir(path):
            raise FileExistsError("'{}' is an existing file.".format(path))

        csv_file_client_paths = [client.base_path for client in self.clients if isinstance(client, CsvFileClient)]
        normpath = os.path.normpath(path)
        if normpath in csv_file_client_paths:
            print("The path csv_file_client already exists")
            print(csv_file_client_paths)
            return

        csv_file_client = CsvFileClient(normpath)
        self.clients.append(csv_file_client)

    def on_close(self):
        self.stop_clients()


if __name__ == "__main__":
    import time
    recorder = Recorder('recorder', 'mac1', 'tcp://localhost:9000')
    recorder.sub_router('market1')
    recorder.add_csvfile_client('/shared/data/recorder')
    recorder.start()
    recorder.join()
