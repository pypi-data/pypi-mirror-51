# auto generated by update_py.py
import json
import os
import time

import tlclient.linker.message_comm as message
from tlclient.linker.constant import FistType, MsgType
from tlclient.linker.fist import Fist
from tlclient.linker.frame import Frame
from tlclient.linker.timer import Timer
from tlclient.linker.utility import bytify
from tlclient.trader.recorder import Recorder

FIST_READY_MARK = '$FIST_READY$'
FIST_FAIL_MARK = '$FIST_FAIL$'

CONFIG_FOLDER = '/shared/etc'
CONFIG_DEFAULT_PATH = '{}/config.json'.format(CONFIG_FOLDER)

DEFAULT_LATEST_CONFIG_VERSION = "0.3"


class GunStartHelper(object):

    proc_types = {
        FistType.MARKET_GATEWAY: 'mg',
        FistType.TRADE_GATEWAY: 'tg',
        FistType.MARKET_ROUTER: 'mr',
        FistType.TRADE_ROUTER: 'tr',
        FistType.ORDER_MANAGER: 'oms',
        FistType.RISK_MANAGER: 'rms',
        FistType.BASKET_SERVER: 'bs',
        FistType.ALGO_SERVER: 'algo',
    }

    @classmethod
    def to_proc_type(cls, fist_type):
        fist_type_code = FistType.parse(fist_type)
        return cls.proc_types.get(fist_type_code)

    @classmethod
    def to_gun_start_cmd(cls, config):
        fist_name = config.get('fist_name')
        fist_type = cls.to_proc_type(config.get('fist_type'))
        assert None not in [fist_name, fist_type], 'None fist type or fist name (type/name){}/{}'.format(fist_type, fist_name)

        cmd = 'gun start -t {} -f {} -d '.format(fist_type, fist_name)
        if fist_name is not None:
            cmd += '-a {} '.format(fist_name)
        gateway_name = config.get('gateway_name')
        if gateway_name is not None:
            cmd += '-g {} '.format(gateway_name)
        router_name = config.get('router_name')
        if router_name is not None:
            cmd += '-r {}'.format(router_name)

        return cmd


class GunClientHelper(object):

    def __init__(self, fist_name, config_path=None, env_name=None, master_addr=None):
        if env_name is None or master_addr is None:
            j = json.load(open(config_path))
            # init recorder
            env_name = j['env']
            master_addr = j['master_rep']
        self.fist_client = Fist(fist_name, FistType.BASE, env_name, master_addr)
        self.fist_client.reg_req_master()
        # force to set LINGER=0
        import zmq
        self.fist_client.req_master_sock.setsockopt(zmq.LINGER, 0)

    def stop(self, fist_name):
        req = message.ReqFistSuicide()
        req.fist_name = bytify(fist_name)
        f = Frame()
        f.set_msg_type(MsgType.CMD_SUICIDE)
        f.set_nano(Timer.nano())
        f.set_data(req)
        try:
            self.fist_client.req_master(f)
        except:
            pass

    def get_status(self):
        f = Frame()
        f.set_msg_type(MsgType.GET_STATUS)
        f.set_nano(Timer.nano())
        f.set_string('')
        rsp = self.fist_client.req_master(f)
        return rsp.get_string()

    def join(self, fist_name, join_wait_seconds):
        is_running = True
        try:
            while is_running:
                is_running = False
                js = json.loads(self.get_status())
                for item in js:
                    if fist_name == item['fist_name'] and item['is_running']:
                        time.sleep(join_wait_seconds)
                        is_running = True
                        break
            print('{} is not running'.format(fist_name))
        except:
            print('master invalid')


class ConfigHelper(object):

    def __init__(self, config_dir=CONFIG_FOLDER, latest_config_version=DEFAULT_LATEST_CONFIG_VERSION):
        self.latest_config_version = latest_config_version
        self.config_dir = config_dir
        self.config_path = os.path.join(config_dir, 'config.json')

        self.config = None
        self.load_config()
        self.current_config_version = self.config.get("config_version", "0.1")
        self.current_backup_path = None

    def _print_and_run_sys_cmd(self, cmd):
        print(cmd)
        os.system(cmd)

    def backup_config(self):
        backup_path = os.path.join(self.config_dir, 'config.json.bak.{}'.format(len(os.listdir(self.config_dir))))
        cmd = "cp {} {}".format(self.config_path, backup_path)
        self._print_and_run_sys_cmd(cmd)
        self.current_backup_path = backup_path

    def _extract_port(self, addr):
        return int(addr.split(':')[-1])

    def _update_config_0_1(self, config):
        config['config_version'] = '0.2'
        config['master_rep_port'] = self._extract_port(config["master_rep"])
        config['master_rep'] = "tcp://127.0.0.1:{}".format(config['master_rep_port'])
        config['env'] = 'env1'
        config["env_infos"] = [
            {
                "env_name": "env1",
                "private_ip": "192.168.108.177",
                "public_ip": "36.110.14.214"
            },
            {
                "env_name": "env2",
                "private_ip": "192.168.108.177",
                "public_ip": "36.110.14.214"
            }
        ]
        for module in config['modules']:
            for comm_type, value in module['addrs'].items():
                if value.startswith("tcp"):
                    module['addrs'][comm_type] = {
                        'comm_method': "TCP",
                        "port": self._extract_port(value)
                    }
                else:
                    print('[ERROR] unhandled addr (key){} (value){}'.format(comm_type, value))

    def _update_config_0_2(self, config):
        config['config_version'] = '0.3'
        new_accounts = {
            'ctp_test': {
                'gateway_name': 'ctp',
                'gateway_type': 'TRADE_GATEWAY'
            },
            'ctp1': {
                'gateway_name': 'ctp',
                'gateway_type': 'MARKET_GATEWAY'
            }
        }
        for gw_name, gw_accounts in config['accounts'].items():
            for acc_tag, acc_info in gw_accounts.items():
                new_acc_tag = acc_tag
                while new_acc_tag in new_accounts:
                    new_acc_tag += "1"
                new_accounts[new_acc_tag] = acc_info
                new_accounts[new_acc_tag]['gateway_name'] = gw_name
                new_accounts[new_acc_tag]['gateway_type'] = 'MARKET_GATEWAY' if 'market' in new_acc_tag or 'qts' in new_acc_tag else 'TRADE_GATEWAY'
        config['accounts'] = new_accounts

    def update_config(self):
        if self.current_config_version == self.latest_config_version:
            print('already in latest version: {}'.format(self.latest_config_version))
            if self.current_backup_path is not None:
                os.remove(self.current_backup_path)
                print('removed backup file {}'.format(self.current_backup_path))
                self.current_backup_path = None
        while self.current_config_version != self.latest_config_version:
            print('current_version: {}'.format(self.current_config_version))
            eval('self._update_config_{}(self.config)'.format(self.current_config_version.replace('.', '_')))
            self.current_config_version = self.config['config_version']

    def load_config(self):
        self.config = json.load(open(self.config_path))

    def dump_config(self):
        json.dump(self.config, open(self.config_path, "w+"), indent=4)

    def check_version(self):
        if self.current_config_version != self.latest_config_version:
            print("[ERROR] outdated config version: {}. the latest version is {}".format(self.current_config_version, self.latest_config_version))
            return False
        else:
            print("already in latest version {}".format(self.current_config_version))
            return True

    def add_account_config(self, acc_name, acc_config, encrypt_fields=None, auto_encrypt=True, encrypt_key=None):
        # assert acc_name not in self.config['accounts']

        encrypt_fields = set(encrypt_fields) if encrypt_fields is not None else set()
        acc_config['_fields_to_encrypt'] = list()
        acc_config['_encrypted'] = False

        if auto_encrypt:
            for f in ['secret_key', 'password']:
                if f not in encrypt_fields:
                    encrypt_fields.add(f)

        for f in encrypt_fields:
            if f in acc_config:
                print('{} is automatically encrypted'.format(f))
                acc_config[f] = Encrypter.encrypt(acc_config[f], encrypt_key)
                acc_config['_fields_to_encrypt'].append(f)
                acc_config['_encrypted'] = True

        self.config['accounts'][acc_name] = acc_config

    def remove_account_config(self, acc_name):
        if acc_name in self.config['accounts']:
            del self.config['accounts'][acc_name]
        else:
            print('[warning] {} not existed'.format(acc_name))

    def get_account_configs(self, acc_names=None, to_decrypt=True, encrypt_key=None):
        configs = {}
        if acc_names is None:
            acc_names = self.config['accounts'].keys()
        elif not isinstance(acc_names, list):
            acc_names = [acc_names]

        for acc_name in acc_names:
            assert acc_name in self.config['accounts'], 'acc "{}" not found'.format(acc_name)
            acc_config = self.config['accounts'][acc_name].copy()
            if acc_config.get('_encrypted', False) and to_decrypt:
                acc_config['_encrypted'] = False
                for f in acc_config.get('_fields_to_encrypt', []):
                    acc_config[f] = Encrypter.decrypt(acc_config[f], encrypt_key)
                acc_config['_fields_to_encrypt'] = []
            configs[acc_name] = acc_config

        return configs


# FISTS


class Router(object):

    def __init__(self, tag, fist_name):
        import libtrader
        if tag == 'tr':
            if fist_name is None:
                fist_name = 'trade1'
            self._obj = libtrader.TradeRouter(fist_name)
        elif tag == 'mr':
            if fist_name is None:
                fist_name = 'market1'
            self._obj = libtrader.MarketRouter(fist_name)
        else:
            raise Exception("unexpected tag: " + tag)
        self._obj.init()

    def run(self):
        self._obj.start()
        print(FIST_READY_MARK)
        self._obj.join()


class Gateway(object):

    def __init__(self, gw_tag, gw_name, acc_tag, router_name, secondary_router_name=None):
        import libtrader
        assert gw_tag == "tg" or gw_tag == "mg", "unexpected gateway tag" + gw_tag
        if gw_tag == 'tg' and gw_name == 'mock':
            if secondary_router_name is None:
                raise Exception('[MISSING_ARGS] {} also requires -s'.format(gw_tag))
            self._obj = libtrader.MockGateway(acc_tag)
            self._obj.init_market(secondary_router_name)
        elif gw_tag == 'mg' and gw_name == 'replay':
            self._obj = libtrader.ReplayGateway(acc_tag)
        else:
            lib_name = 'lib{}{}'.format(gw_tag, gw_name)
            imported_lib = None
            try:
                imported_lib = __import__(lib_name)
                globals()[lib_name] = imported_lib
            except:
                raise Exception("cannot find lib named {}".format(lib_name))
            self._obj = imported_lib.Gateway(acc_tag)
        self._obj.set_account()
        self._obj.init(router_name)

    def run(self):
        self._obj.start()
        print(FIST_READY_MARK)
        self._obj.join()


class PythonGateway(object):

    def __init__(self, package_name, gw_tag, gw_name, router_name, acc_tag=None, fist_name=None):
        assert gw_tag in ['tg', 'mg'], 'unexpected gateway tag ' + gw_tag

        class_name = gw_name.title().replace('_', '')
        if gw_tag == 'mg':
            class_name += 'MarketGateway'
            kwargs = {
                'fist_name': fist_name or '{}_{}'.format(gw_tag, gw_name),
                'mrouter_name': router_name or 'market1'
            }

        elif gw_tag == 'tg':
            from .helpers import AccountHelper
            # get account config from db
            assert acc_tag is not None
            account = AccountHelper().get_account(acc_tag)
            assert account is not None, 'could not find account config in db'
            acc_config = account.get_decrypted_acc_config()
            # prep tg args
            class_name += 'TradeGateway'
            kwargs = {
                'acc_tag': acc_tag,
                'router_name': router_name or 'trade1',
                'acc_config': acc_config
            }
        mylib = __import__(package_name)
        self.obj = eval('mylib.{}(**kwargs)'.format(class_name))

    def run(self):
        self.obj.start()
        print(FIST_READY_MARK)
        self.obj.join()


class OrderService(object):

    def __init__(self, fist_name=None, router_name=None, with_db=False):
        fist_name = fist_name or 'oms1'
        router_name = router_name or 'trade1'

        if with_db:
            lib_name = 'libtrader'
            imported_lib = None
            try:
                imported_lib = __import__(lib_name)
                globals()[lib_name] = imported_lib
            except:
                raise Exception('cannot find lib named {}'.format(lib_name))
            self._obj = imported_lib.OrderService(fist_name)
        else:
            import libtrader
            self._obj = libtrader.OrderManagerService(fist_name)
        self._obj.init(router_name)

    def run(self):
        self._obj.start()
        print(FIST_READY_MARK)
        self._obj.join()


class RiskManagementService(object):

    def __init__(self, fist_name=None, router1=None):
        fist_name = fist_name or 'rms1'
        router1 = router1 or 'trade1'

        import libtrader
        self._obj = libtrader.RiskManager(fist_name)
        self._obj.init(router1)

    def run(self):
        self._obj.start()
        print(FIST_READY_MARK)
        self._obj.join()


class BasketServer(object):

    def __init__(self, fist_name=None, trade_router=None):
        fist_name = fist_name or 'basket'
        trade_router = trade_router or 'trade1'

        import libtrader
        self._obj = libtrader.BasketServer(fist_name)
        self._obj.init_trade(trade_router)

    def run(self):
        self._obj.start()
        print(FIST_READY_MARK)
        self._obj.join()


class AlgoServer(object):

    def __init__(self, algo_type, trade_router=None, market_router=None):
        assert algo_type is not None, 'must specify algo type'
        trade_router = trade_router or 'trade1'
        market_router = market_router or 'market1'

        lib_name = 'libalgo{}'.format(algo_type)
        imported_lib = __import__(lib_name)
        globals()[lib_name] = imported_lib
        self._obj = imported_lib.AlgoServer()
        self._obj.init_trade(trade_router)
        self._obj.init_market(market_router)

    def run(self):
        self._obj.start()
        print(FIST_READY_MARK)
        self._obj.join()


class GunRecorder(object):

    def __init__(self, fist_name, router_names, data_dir=None):
        j = json.load(open(CONFIG_DEFAULT_PATH))
        # init recorder
        env_name = j['env']
        master_addr = j['master_rep']
        self._obj = Recorder(fist_name or 'recorder', env_name, master_addr)
        # set routers
        router_names = router_names or ['market1', 'trade1']
        for router_name in router_names:
            self._obj.sub_router(router_name)
        # set csv dumper
        data_dir = data_dir or '/shared/data/recorder'
        self._obj.add_csvfile_client(data_dir)
        # set db
        if 'influxdb' in j:
            influx_db_info = j['influxdb']
            _info = influx_db_info[influx_db_info['mode']]
            self._obj.set_influxdb(host=_info['host'],
                                   port=_info['port'],
                                   user=_info['username'],
                                   passwd=_info['password'],
                                   db=_info['db'])

    def run(self):
        self._obj.start()
        print(FIST_READY_MARK)
        self._obj.join()
